


動態規劃 - 維基百科，自由的百科全書






























 






動態規劃

維基百科，自由的百科全書


					前往：					導覽，					搜尋

動態規劃（英語：Dynamic programming，簡稱DP）是一種在數學、管理科學、計算機科學、經濟學和生物信息學中使用的，通過把原問題分解為相對簡單的子問題的方式求解複雜問題的方法。
動態規劃常常適用於有重疊子問題[1]和最優子結構性質的問題，動態規劃方法所耗時間往往遠少於樸素解法。
動態規劃背後的基本思想非常簡單。大致上，若要解一個給定問題，我們需要解其不同部分（即子問題），再合併子問題的解以得出原問題的解。
通常許多子問題非常相似，為此動態規劃法試圖僅僅解決每個子問題一次，從而減少計算量：一旦某個給定子問題的解已經算出，則將其記憶化存儲，以便下次需要同一個子問題解之時直接查表。這種做法在重複子問題的數目關於輸入的規模呈指數增長時特別有用。



目錄


1 概述
2 適用情況
3 實例

3.1 斐波那契數列（Fibonacci polynomial）
3.2 背包問題


4 使用動態規劃的算法
5 參考
6 外部連結



概述[編輯]
動態規劃在查找有很多重疊子問題的情況的最優解時有效。它將問題重新組合成子問題。為了避免多次解決這些子問題，它們的結果都逐漸被計算並被保存，從簡單的問題直到整個問題都被解決。因此，動態規劃保存遞歸時的結果，因而不會在解決同樣的問題時花費時間。
動態規劃只能應用於有最優子結構的問題。最優子結構的意思是局部最優解能決定全局最優解（對有些問題這個要求並不能完全滿足，故有時需要引入一定的近似）。簡單地說，問題能夠分解成子問題來解決。
適用情況[編輯]

最優子結構性質。如果問題的最優解所包含的子問題的解也是最優的，我們就稱該問題具有最優子結構性質（即滿足最優化原理）。最優子結構性質為動態規劃算法解決問題提供了重要線索。
無後效性。即子問題的解一旦確定，就不再改變，不受在這之後、包含它的更大的問題的求解決策影響。
子問題重疊性質。子問題重疊性質是指在用遞歸算法自頂向下對問題進行求解時，每次產生的子問題並不總是新問題，有些子問題會被重複計算多次。動態規劃算法正是利用了這種子問題的重疊性質，對每一個子問題只計算一次，然後將其計算結果保存在一個表格中，當再次需要計算已經計算過的子問題時，只是在表格中簡單地查看一下結果，從而獲得較高的效率。

實例[編輯]
斐波那契數列（Fibonacci polynomial）[編輯]
計算斐波那契數列（Fibonacci polynomial）的一個最基礎的算法是，直接按照定義計算（函數遞歸）：

   function fib(n）
       if n = 0 or n = 1
           return n
       return fib(n − 1) + fib（n − 2）

當n=5時，fib(5)的計算過程如下:

fib(5)
fib(4) + fib(3)
(fib(3) + fib(2)) + (fib(2) + fib(1))
((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
(((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))

由上面可以看出，這種算法對於相似的子問題進行了重複的計算，因此不是一種高效的算法。實際上，該算法的運算時間是指數級增長的。 改進的方法是，我們可以通過保存已經算出的子問題的解來避免重複計算：

array map [0...n] = { 0 => 0, 1 => 1 }
fib（n）
    if（map m does not contain key n）
        m[n] := fib(n − 1) + fib（n − 2）
    return m[n]

將前n個已經算出的數保存在數組map中，這樣在後面的計算中可以直接應用前面的結果，從而避免了重複計算。算法的運算時間變為O（n）
背包問題[編輯]
背包問題作為NP完全問題，暫時不存在多項式時間算法。動態規劃屬於背包問題求解最優解的可行方法之一。此外，求解背包問題最優解還有搜索法等，近似解還有貪心法等，分數背包問題有最優貪心解等。 背包問題具有最優子結構和重疊子問題。動態規劃一般用於求解背包問題中的整數背包問題（即每種物品所選的個數必須是整數）。 解整數背包問題： 設有n件物品，每件價值記為Pi，每件體積記為Vi，用一個最大容積為Vmax的背包，求裝入物品的最大價值。 用一個數組f[i,j]表示取i件商品填充一個容積為j的背包的最大價值，顯然問題的解就是f[n,Vmax].
f[i,j]=

      f[i-1,j] {j<Vi}
      max{f[i-1,j],f[i,j-Vi]+Pi} {j>=Vi}
      0 {i=0 OR j=0}

對於特例01背包問題（即每件物品最多放1件，否則不放入）的問題，狀態轉移方程：
f[i,j]=

      f[i-1,j] {j<Vi}
      max{f[i-1,j],f[i-1,j-Vi]+Pi} {j>=Vi}
      0 {i=0 OR j=0}

參考Pascal代碼


for i:=1 to n do
  for j:=totv downto v[i] do
    f[j]:=max(f[j],f[j-v[i]]+p[i]);
writeln(f[totv]);

參考C++代碼（不含include和數組聲明）


#define max(x,y) x>y?x:y //max宏函數，也可以自己寫或者調取algorithm
for(int i=1;i<=n;i++)
  for (j=totv;j>=v[i];j--)
    f[j]=max(f[j],f[j-v[i]]+p[i]);
printf("%d",f[totv]); //或std:cout<<f[totv];

使用動態規劃的算法[編輯]

最長公共子序列
Floyd-Warshall算法
Viterbi算法

參考[編輯]

^ S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani, 'Algorithms', p 173, available at http://www.cs.berkeley.edu/~vazirani/algorithms.html

外部連結[編輯]








閱
論
編


算法






排序




比較排序



冒泡排序
選擇排序
插入排序
希爾排序
快速排序
歸併排序
堆排序
雞尾酒排序
梳排序
侏儒排序（英語：Gnome sort）
圖書館排序
內省排序
奇偶排序








線性時間排序



鴿巢排序
基數排序
桶排序








並行排序



排序網絡（英語：Sorting network）
Batcher歸併網絡








不實用的



Bogo排序
臭皮匠排序








圖



拓撲排序











搜索




列表



線性搜索
二分搜索








樹・圖



廣度優先搜索

最良優先搜索（英語：Best-first search）
均一開銷搜索
A*


深度優先搜索

疊代深化深度優先搜索
深度限制搜索（日語：深さ制限探索）


雙方向探索（英語：Bidirectional search）
分枝限定法（英語：Branch and bound）








字符串



克努斯-莫裡斯-普拉特算法
Boyer-Moore字符串搜索算法
AC自動機算法
Rabin-Karp算法（英語：Rabin–Karp algorithm）
位圖算法（英語：Bitap algorithm）











最短路徑問題



戴克斯特拉算法
貝爾曼-福特算法
Floyd-Warshall算法








最小生成樹



普林姆算法
克魯斯克爾演算法








最大流問題
最小割問題



Ford–Fulkerson算法
Edmonds–Karp算法








線性規劃問題（日語：線型計畫問題）



單純形法
Karmarkar算法（英語：Karmarkar's algorithm）








順序統計量



選擇算法
中位數的中位數（英語：Median of medians）








種類



近似算法
隨機化算法








其他



分治法
動態規劃
貪心法









Category:算法











權威控制



GND: 4125677-3
NDL: 00571739












 
						取自 "https://zh.wikipedia.org/w/index.php?title=動態規劃&oldid=44359352"					
分類：最優化算法隱藏分類：含有英語的條目包含規範控制信息的維基百科條目 



導覽選單


個人工具

沒有登入對話貢獻建立帳號登入 



命名空間

條目
討論




台灣正體



不轉換
簡體
繁體
大陸簡體
香港繁體
澳門繁體
馬新簡體
台灣正體






查看

閱讀
編輯
檢視歷史



更多







搜尋



 







導航


首頁分類索引特色內容新聞動態近期變更隨機條目 



說明


說明維基社群方針與指引互助客棧知識問答字詞轉換IRC即時聊天聯絡我們關於維基百科資助維基百科 



列印/匯出


下載成 PDF 



工具


連結至此的頁面相關變更上傳檔案特殊頁面可列印版靜態連結頁面資訊維基數據 項目引用此頁面 



其他語言


العربيةБългарскиCatalàČeštinaDeutschΕλληνικάEnglishEspañolEuskaraفارسیFrançaisGalegoעבריתहिन्दीBahasa IndonesiaItaliano日本語Қазақша한국어LietuviųമലയാളംNorsk bokmålPolskiPortuguêsРусскийSrpskohrvatski / српскохрватскиSimple EnglishSlovenščinaСрпски / srpskiSvenskaไทยУкраїнськаTiếng Việt 
編輯連結 





 本頁面最後修訂於2017年5月14日 (週日) 14:51。
本站的全部文字在創用CC 姓名標示-相同方式分享 3.0 協議之條款下提供，附加條款亦可能應用（請參閱使用條款）。
Wikipedia®和維基百科標誌是維基媒體基金會的註冊商標；維基™是維基媒體基金會的商標。
維基媒體基金會是在美國佛羅里達州登記的501(c)(3)免稅、非營利、慈善機構。


隱私政策
關於維基百科
免責聲明
開發人員
Cookie 聲明
手機版檢視



 

 






﻿
演算法筆記 - Dynamic Programming

Dynamic Programming
長江後浪催前浪，一替新人趲舊人。《張協狀元》
資之深，則取之左右逢其原。《孟子》

Dynamic Programming
先透過一個簡單的例子，感受一下動態規劃吧！
範例：階乘（Factorial）
1 × 2 × 3 × ⋯ × N。整數1到N的連乘積。N階乘。N!。
N!源自(N-1)!，如此就遞迴分割問題了。

陣列的每一格對應每一個問題。設定第一格的答案，再以迴圈依序計算其餘答案。


const int N = 10;
int f[N];

void factorial()
{
	f[0] = 0;
	f[1] = 1;
	for (int i=2; i<=N; ++i)
		f[i] = f[i-1] * i;
}


const int N = 10;

void factorial()
{
	int f = 1;
	for (int i=2; i<=N; ++i)
		f *= i;
}

UVa 623 568 10220 10323
時間複雜度
總共N個問題，每個問題花費O(1)時間，總共花費O(N)時間。
空間複雜度
求1!到N!：總共N個問題，用一條N格陣列儲存全部問題的答案，空間複雜度為O(N)。
只求N!：用一個變數累計乘積，空間複雜度為O(1)。

Dynamic Programming: recurrence

Dynamic Programming= Divide and Conquer + Memoization
動態規劃是分治法的延伸。當遞迴分割出來的問題，一而再、再而三出現，就運用記憶法儲存這些問題的答案，避免重複求解，以空間換取時間。
動態規劃的過程，就是反覆地讀取數據、計算數據、儲存數據。


1. 把原問題遞迴分割成許多更小的問題。（recurrence）
   1-1. 子問題與原問題的求解方式皆類似。（optimal sub-structure）
   1-2. 子問題會一而再、再而三的出現。（overlapping sub-problems）
2. 設計計算過程：
   2-1. 確認每個問題需要哪些子問題來計算答案。（recurrence）
   2-2. 確認總共有哪些問題。（state space）
   2-3. 把問題一一對應到表格。（lookup table）
   2-4. 決定問題的計算順序。（computational sequence）
   2-5. 確認初始值、計算範圍。（initial states / boundary）
3. 實作，主要有兩種方式：
   3-1. Top-down
   3-2. Bottom-up

1. recurrence
遞迴分割問題時，當子問題與原問題完全相同，只有數值範圍不同，我們稱此現象為recurrence，再度出現、一再出現之意。
【註：recursion和recurrence，中文都翻譯為「遞迴」，然而兩者意義大不相同，讀者切莫混淆。】
此處以爬樓梯問題當作範例。先前於遞歸法章節，已經談過如何求踏法，而此處要談如何求踏法數目。

踏上第五階，只能從第四階或從第三階踏過去。因此「爬到五階」源自兩個子問題：「爬到四階」與「爬到三階」。

「爬到五階」的踏法數目，就是總合「爬到四階」與「爬到三階」的踏法數目。寫成數學式子是「f(5) = f(4) + f(3)」，其中「f(‧)」表示「爬到某階之踏法數目」。
依樣畫葫蘆，得到「f(4) = f(3) + f(2)」、「f(3) = f(2) + f(1)」。
「爬到兩階」與「爬到一階」無法再分割、沒有子問題，直接得到「f(2) = 2」、「f(1) = 1」。
整理成一道簡明扼要的遞迴公式：

f(n) =
 { 1                , if n = 1
 { 2                , if n = 2
 { f(n-1) + f(n-2)  , if n >= 3 and n <= 5

爬到任何一階的踏法數目，都可以藉由這道遞迴公式求得。n代入實際數值，遞迴計算即可。
為什麼分割問題之後，就容易計算答案呢？因為分割問題時，同時也分類了這個問題的所有可能答案。分類使得答案的規律變得單純，於是更容易求得答案。

2-1. recurrence

f(n) =
 { 1                , if n = 1
 { 2                , if n = 2
 { f(n-1) + f(n-2)  , if n >= 3


2-2. state space
想要計算第五階的踏法數目。
全部的問題是「爬到一階」、「爬到二階」、「爬到三階」、「爬到四階」、「爬到五階」。

至於「爬到零階」、「爬到負一階」、「爬到負二階」以及「爬到六階」、「爬到七階」沒有必要計算。
2-3. lookup table
建立六格的陣列，儲存五個問題的答案。
表格的第零格不使用，第一格是「爬到一階」的答案，第二格是「爬到二階」的答案，以此類推。

如果只計算「爬完五階」，也可以建立三個變數交替使用。
2-4. computational sequence
因為每個問題都依賴「階數少一階」、「階數少二階」這兩個問題，所以必須由階數小的問題開始計算。
計算順序是「爬到一階」、「爬到二階」、……、「爬到五階」。

2-5. initial states / boundary
最先計算的問題是「爬到一階」與「爬到二階」，必須預先將答案填入表格、寫入程式碼，才能繼續計算其他問題。心算求得「爬到一階」的答案是1，「爬到二階」的答案是2。
最後計算的問題是原問題「爬到五階」。
為了讓表格更順暢、為了讓程式碼更漂亮，可以加入「爬到零階」的答案，對應到表格的第零格。「爬到零階」的答案，可以運用「爬到一階」的答案與「爬到兩階」的答案，刻意逆推而得。

最後可以把初始值、尚待計算的部份、不需計算的部分，統整成一道遞迴公式：

f(n) =
 { 0                , if n < 0               [Exterior]
 { 1                , if n = 0               [Initial]
 { 1                , if n = 1               [Initial]
 { f(n-1) + f(n-2)  , if n >= 2 and n <= 5   [Compute]
 { 0                , if n > 5               [Exterior]

UVa 11069
3. 實作
直接用遞迴實作，而不使用記憶體儲存各個問題的答案，是最直接的方式，也是最慢的方式。時間複雜度是O(f(n))。問題一而再、再而三的出現，不斷呼叫同樣的函式求解，效率不彰。剛接觸DP的新手常犯這種錯誤。

int f(int n)
{
	if (n == 0 || n == 1)
		return 1;
	else
		return f(n-1) + f(n-2);
}

正確的DP，是一邊計算，一邊將計算出來的數值存入表格，以後便不必重算。這裡整理了兩種實作方式，各有優缺點：

1. Top-down
2. Bottom-up


3-1. Top-down

int table[6];	// 表格，儲存全部問題的答案。
bool solve[6];	// 記錄問題是否已經計算完畢

int f(int n)
{
	// [Initial]
	if (n == 0 || n == 1) return table[n] = 1;

	// [Compute]
	// 如果已經計算過，就直接讀取表格的答案。
	if (solve[n]) return table[n];

	// 如果不曾計算過，就計算一遍，儲存答案。
	table[n] = f(n-1) + f(n-2);	// 將答案存入表格
	solve[n] = true;			// 已經計算完畢
	return table[n];
}

void stairs_climbing()
{
	for (int i=0; i<=5; i++)
		solve[i] = false;

	int n;
	while (cin >> n && (n >= 0 && n <= 5))
		cout << "爬到" << n << "階，" << f(n) << "種踏法";
}


int table[6];	// 合併solve跟table，簡化程式碼。

int f(int n)
{
	// [Initial]
	if (n == 0 || n == 1) return 1;

	// [Compute]
	// 用 0 代表該問題還未計算答案
//	if (table[n] != 0) return table[n];
	if (table[n]) return table[n];
	return table[n] = f(n-1) + f(n-2);
}

void stairs_climbing()
{
	for (int i=0; i<=5; i++)
		table[i] = 0;

	int n;
	while (cin >> n && (n >= 0 && n <= 5))
		cout << "爬到" << n << "階，" << f(n) << "種踏法";
}

這個實作方式的好處是不必斤斤計較計算順序，因為程式碼中的遞迴結構會迫使最小的問題先被計算。這個實作方式的另一個好處是只計算必要的問題，而不必計算所有可能的問題。
這個實作方式的壞處是程式碼採用遞迴結構，不斷呼叫函式，執行效率較差。這個實作方式的另一個壞處是無法自由地控制計算順序，因而無法妥善運用記憶體，浪費了可回收再利用的記憶體。
UVa 10285 10446 10520
3-2. Bottom-up
訂定一個計算順序，然後由最小的問題開始計算。特色是程式碼通常只有幾個迴圈。這個實作方式的好處與壞處與前一個方式恰好互補。
首先建立表格。

int table[6];


int table[5 + 1];

心算「爬到零階」的答案、「爬到一階」的答案，填入表格當中，作為初始值。分別填到表格的第零格、第一格。

table[0] = 1;
table[1] = 1;

尚待計算的部份就是「爬到兩階」的答案、……、「爬到五階」的答案。通常是使用迴圈，按照計算順序來計算。
計算過程的實作方式，有兩種迥異的風格。一種是「往回取值」，是常見的實作方式。

int table[6];

void dynamic_programming()
{
	// [Initial]
	table[0] = 1;
	table[1] = 1;

	// [Compute]
	for (int i=2; i<=5; i++)
		table[i] = table[i-1] + table[i-2];
}

另一種是「往後補值」，是罕見的實作方式。

int table[6];

void dynamic_programming()
{
	// [Initial]
	for (int i=0; i<=5; i++) table[i] = 0;
	table[0] = 1;
//	table[1] = 1;	// 剛好可以被算到

	// [Compute]
	for (int i=0; i<=5; i++)
	{
		if (i+1 <= 5) table[i+1] += table[i];
		if (i+2 <= 5) table[i+2] += table[i];
	}
}

計算完畢之後，最後印出答案。

void stairs_climbing()
{
	dynamic_programming();

	int n;
	while (cin >> n && (n >= 0 && n <= 5))
		cout << "爬到" << n << "階，" << f(n) << "種踏法";
}

UVa 495 900 10334
總結
第一。先找到原問題和其子問題們之間的關係，寫出遞迴公式。如此一來，便可利用遞迴公式，用子子問題的答案，求出子問題的答案；用子問題的答案，求出原問題的答案。
第二。確認可能出現的問題全部總共有哪些，這樣才能知道要計算哪些問題，才能知道總共花多少時間、多少記憶體。
第三。有了遞迴公式之後，就必須安排出一套計算的順序。大問題的答案，總是以小問題的答案來求得的，所以，小問題的答案是必須先算的，否則大問題的答案從何而來呢？
一個好的安排方式，不但使程式碼容易撰寫，還可重複利用記憶體空間。
第四。記得先將最小、最先被計算的問題，心算出答案，儲存入表格，內建於程式碼之中。一道遞迴公式必須擁有初始值，才有辦法計算其他項。
第五。實作DP的程式時，會建立一個表格，在表格存入所有大小問題的答案。安排好每個問題的答案在表格的哪個位置，這樣計算時才能知道該在哪裡取值。
切勿存取超出表格的元素，產生溢位情形，導致答案算錯。計算過程當中，一旦某個問題的答案出錯，就會如骨牌效應般一個影響一個，造成很難除錯。
範例：不重複組合（Combination）

兩個子問題的組合數目加起來，就是原問題的組合數目。遞迴公式就是著名的巴斯卡公式（Pascal's Formula）：

c(n, m) =
 { c(n-1, m-1) + c(n-1, m)  , if n > 1 and m > 1 and n >= m
 { n                        , if m = 1
 { 1                        , if n = 1

範例：河內塔（Tower of Hanoi）


f(n) =
 { f(n-1) + 1 + f(n-1)  , if n > 1
 { 1                    , if n = 1


Dynamic Programming: counting / optimization

範例：樓梯路線（Staircase Walk），計數問題
一個方格棋盤，從左上角走到右下角，每次只能往右走一格或者往下走一格。請問有幾種走法？

對於任何一個方格來說，只可能「從左走來」或者「從上走來」，答案是兩者相加。

「從左走來」是一個規模更小的問題，「從上走來」是一個規模更小的問題，答案是兩者相加。

二維陣列的每一格對應每一個問題。設定第零行、第零列的答案，再以迴圈依序計算其餘答案。

時間複雜度分析：令X和Y分別是棋盤的長和寬。計算一個問題需要O(1)時間（兩個子問題答案相加的時間）。總共XY個問題，所以計算所有問題需要O(XY)時間。
空間複雜度分析：總共XY個問題，所以需要O(XY)空間，簡單來說就是二維陣列啦！如果不需要儲存所有問題的答案，只想要得到其中一個特定問題的答案，那隻需要一維陣列就夠了，也就是O(min(X,Y))空間。

const int X = 8, Y = 8;
int c[X][Y];

void staircase_walk()
{
	// [Initial]
	for (int i=0; i> x >> y)
		cout << "由(0,0)走到(x,y)有" << c[x][y] << 種走法;
}

節省記憶體是動態規劃當中重要的課題！
如果只打算求出一個問題，那麼只需要儲存最近算出來的問題答案，讓計算過程可以順利進行就可以了。
兩條陣列輪替使用，就足夠儲存最近算出來的問題答案、避免c[i-1][j]超出陣列範圍。

const int X = 8, Y = 8;
int c[2][Y];	// 兩條陣列，儲存最近算出來的問題答案。

void staircase_walk()
{
	// [Initial]
	for (int j=0; j
事實上，一條陣列就夠了。也不能再少了。

const int X = 8, Y = 8;
int c[Y];	// 一條陣列就夠了

void staircase_walk()
{
	// [Initial]
	for (int j=0; j

const int X = 8, Y = 8;
int c[Y];	// 一條陣列就夠了

void staircase_walk()
{
	// [Initial]
	c[0] = 1;	// 部分步驟移到[Compute]

	// [Compute]
	for (int i=0; i
如果某些格子上有障礙物呢？把此格設為零。
如果也可以往右下斜角走呢？添加來源c[i-1][j-1]。
如果可以往上下左右走呢？不斷繞圈子，永遠不會結束，走法無限多種。
UVa 10599 825 926 ICPC 4787
遞迴公式
若瞭解遞迴關係，就不必強記遞迴公式。若瞭解圖片意義，就不必強記數學符號。

count(i, j) =
 { 0                              , if i < 0 or j < 0     [Exterior]
 { 1                              , if i = 0              [Initial]
 { 1                              , if j = 0              [Initial]
 { count(i-1, j) + count(i, j-1)  , if i > 0 and i < 8    [Compute]
 {                                  and j > 0 and j < 8   [Compute]
 { 0                              , if i >= 8 or j >= 8   [Exterior]

count(i, j)：從格子 (0, 0) 走到格子 (i, j) 的走法數目。

遞歸方向
這個問題雙向都可以遞歸。對於任何一個方格來說，只可能「向右走出」或者「向下走出」。

範例：樓梯路線（Staircase Walk），極值問題
動態規劃的問題，可以分為「計數問題」和「極值問題」。方纔介紹「計數問題」，現在介紹「極值問題」。
一個方格棋盤，格子擁有數字。從左上角走到右下角，每次只能往右走一格或者往下走一格。請問總和最小的走法？（或者總和最大的走法？）


const int X = 8, Y = 8;
int a[X][Y];
int c[X][Y];

void staircase_walk()
{
	// [Initial]
	c[0][0] = a[0][0];
	for (int i=1; i> x >> y)
		cout << "由(0,0)走到(x,y)的最小總和" << c[x][y];
}

想要印出路線，另外用一個陣列，記錄從哪走來。

const int X = 8, Y = 8;
int a[X][Y];
int c[X][Y];
int p[X][Y];
int out[X+Y-1];

void staircase_walk()
{
	// [Initial]
	c[0][0] = a[0][0];
	p[0][0] = -1;	// 沒有源頭
	for (int i=1; i c[i][j-1])
			{
				c[i][j] = c[i][j-1] + a[i][j];
				p[i][j] = 1;	// 從左走來
			}
			else /*if (c[i-1][j] == c[i][j-1])*/
			{
				// 從上走來、從左走來都可以，這裡取左。
				c[i][j] = c[i][j-1] + a[i][j];
				p[i][j] = 1;
			}

	// 反向追蹤路線源頭
	int n = 0;	// out size
	for (int i=X-1, j=Y-1; i>=0 && j>=0; )
	{
		out[n++] = p[i][j];
		if (p[i][j] == 0) i--;
		else if (p[i][j] == 1) j--;
	}

	// 印出路線
	for (int i=n-1; i>=0; --i)
		cout << out[i];
}

額外介紹一個技巧。為了避免減一超出邊界，需要添補許多程式碼。整個棋盤往右下移動一格，就能精簡許多程式碼。

const int X = 8, Y = 8;
int a[X+1][Y+1];	// 整個棋盤往右往下移動一格
int c[X+1][Y+1];	// 全域變數，將自動初始化為零。
int p[X+1][Y+1];
int out[X+Y-1];

void staircase_walk()
{
	// [Initial]

	// [Compute]
	for (int i=1; i<=X; i++)
		for (int j=1; j<=Y; j++)
			if (c[i-1][j] < c[i][j-1])
			{
				c[i][j] = c[i-1][j] + a[i][j];
				p[i][j] = 0;	// 從上走來
			}
			else /*if (c[i-1][j] >= c[i][j-1])*/
			{
				c[i][j] = c[i][j-1] + a[i][j];
				p[i][j] = 1;	// 從左走來
			}

	// 反向追蹤路線源頭
	int n = 0;	// out size
	for (int i=X, j=Y; i>0 && j>0; )
	{
		out[n++] = p[i][j];
		if (p[i][j] == 0) i--;
		else if (p[i][j] == 1) j--;
	}

	// 印出路線
	for (int i=n-1; i>=0; --i)
		cout << out[i];
}


const int X = 8, Y = 8;
int a[X+1][Y+1];	// 整個棋盤往右往下移動一格
int c[X+1][Y+1];	// 全域變數，將自動初始化為零。
int p[X+1][Y+1];
int out[X+Y-1];

void staircase_walk()
{
	// [Initial]

	// [Compute]
	const int x[2] = {1, 0};
	const int y[2] = {0, 1};

	for (int i=1; i<=X; i++)
		for (int j=1; j<=Y; j++)
		{
			if (c[i-1][j] < c[i][j-1]) p[i][j] = 0;
			else                       p[i][j] = 1;

			int& d = p[i][j];
			c[i][j] = c[i-x[d]][j-y[d]] + a[i][j];
		}

	// 反向追蹤路線源頭
	int n = 0;	// out size
	for (int i=X, j=Y; i>0 && j>0; )
	{
		int& d = p[i][j];
		out[n++] = d;
		i -= x[d]; j -= x[d];
	}

	// 印出路線
	for (int i=n-1; i>=0; --i)
		cout << out[i];
}

範例：樓梯路線（Staircase Walk），極值問題

節省記憶體是動態規劃當中重要的課題！
方纔的分割方式：分割最後一步，窮舉最後一步從哪走來；方纔的實作方式：由小到大的迴圈。問題答案c[i][j]，可以精簡成一維陣列。路線來源p[i][j]，無法精簡成一維陣列。
想讓路線來源精簡成一維陣列，必須採用另一種分割方式：從地圖中線分割，窮舉穿過中線的所有地點；同時採用另一種實作方式：由大到小的遞迴。


Dynamic Programming: state / DAG（Under Construction!）

State / DAG

以State和DAG的觀點，重新看待動態規劃。
動態規劃得類比成「狀態State」：「問題」變「狀態」，「全部問題」變「狀態空間」，「遞迴關係」變「狀態轉移函式」。
動態規劃得類比成「有向無環圖DAG」：既然遞迴關係不能循環，顯然就是DAG。「問題」變「點」，「遞迴關係」變「邊」，「計算順序」變「拓撲順序」。
即便讀者不懂State和DAG也沒關係，只要抓住兩個要點：每個小問題各是一個狀態，只有數值範圍不同；狀態之間是單行道，依序求解，不能循環。
ICPC 5104
範例
http://algorithms.tutorialhorizon.com/

Maximum Subarray
1D p-Center Problem
Longest Increasing Subsequence
Longest Common Subsequence
Longest Palindrome Substring
0/1 Knapsack Problem
Shortest Path

範例：巴斯卡三角形（Pascal's Triangle）

巴斯卡三角形左右對稱，可以精簡掉對稱部分。巴斯卡三角形逆時針轉45˚，視覺上就可以一一對應至表格。
時間複雜度為O(N²)，空間複雜度為O(N²)。
UVa 369 485 10564
範例：矩陣相乘次序（Matrix Chain Multiplication）

一連串矩陣相乘，無論從何處開始相乘，計算結果都一樣，然而計算時間卻有差異。兩個矩陣，大小為a x b及b x c，相乘需要O(abc)時間（當然還可以更快，但是此處不討論）。那麼一連串矩陣相乘，最少需要多少時間呢？

一連串矩陣，從最後一次相乘的地方分開，化作兩串矩陣相乘。考慮所有可能的分法。


f(i, k) = min { f(i, j) + f(j+1, k) + r[i] ⋅ c[j] ⋅ c[k] }
         i≤j< k

f(i, k)：從第i個矩陣乘到第k個矩陣，最少的相乘次數。
r[i]：第i個矩陣的row數目。
c[i]：第i個矩陣的column數目。


int f[100][100];
int r[100], c[100];

void matrix_chain_multiplication()
{
	memset(array, 0x7f, sizeof(array));
	for (int i=0; i
可以調整成online版本。

	for (int k=1; k=0; --i)
			for (int j=k-1; j>=i; --j)
//			for (int j=i; j
同類型的動態規劃問題：

Matrix Chain Multiplication
Optimal Binary Search Tree
Hu-Tucker Compression
Minimum Weight Triangulation of Convex Polygon
Cocke-Younger-Kasami Algorithm

UVa 348 442
範例：Longest Increasing Subsequence
把解答編入狀態之中。
詳見「Longest Increasing Subsequence」。
範例：Weighted Interval Scheduling Problem
有了權重之後greedy就不管用了。
範例：Word Wrap

一大段英文，適度換行，讓文字不超過紙張邊界，美化版面。
窮舉行數，再窮舉一行擠入多少字數。自行定義留白的代價。
UVa 709 848 400
範例：二進位數字
ICPC 4833 5101
範例：Sequence Combination【尚無正式名稱】
逐步消去一連串同色彩珠，找到步驟最少的消除方式。
UVa 10559 11523
範例：節省記憶體
ICPC 6435
範例：???

Problem J: Subway Timing
http://www.csc.kth.se/~austrin/icpc/finals2009solutions.pdf

ICPC 4454

http://codeforces.com/blog/entry/13007

ICPC 6669


Dynamic Programming: bitset

bitset

bitset是一個二進位數字，每一個bit分別代表每一件東西，1代表開啟，0代表關閉。例如現在有十個燈泡，編號設定為零到九，其中第零個、第三個、第九個燈泡是亮的，剩下來的燈泡是暗的。我們用一個10 bit的二進位數字1000001001，表示這十個燈泡的亮暗狀態。
建立一個大小為2¹⁰的陣列，便囊括了所有可能的狀態。陣列的每一格，就代表一種燈泡開關的狀態。

int array[1<<10];
array[521] = 想記錄的數字;
/* 1000001001(2進位) = 521(10進位) */

當狀態數量呈指數成長，可以利用bitset作為狀態。
UVa 10952 ICPC 4794
範例：Maximum Matching

以線相連的兩物，可以配對在一起。求最大配對數目暨配對方式。
「Maximum Matching」有多項式時間演算法，可是很難實作；動態規劃雖然慢了些，是指數時間演算法，但是容易實作。移除匹配成一對的點，就得到遞迴公式。

f[S+{i}+{j}] = max { f[S] + adj[i,j] }   i,j∉S
f[S] = max { f[S-{i}-{j}] + adj[i,j] }   i,j∉S

使用bitset，已匹配標成1，未匹配標成0。時間複雜度為O(2ᴺ N²)，空間複雜度為O(2ᴺ)。
這個方法需要大量記憶體，所以無法計算N很大的情況，何況編譯器也不准我們建立太大的陣列，N=28就是極限了。這個方法同時也需要大量時間，以現在的個人電腦來說，N=17就已經要花上幾分鐘才能求出答案了。

// top-down DP
const int N = 10;
int adj[N][N];	// adjacency matrix。連線為1，否則為0。
int dp[1<
這個演算法可以再修正，讓時間複雜度成為O(2ᴺ N)。各位可以試試看。
UVa 10888 10911 11439 10296 11156
範例：Hamilton Path

找到一條路徑，剛好每一個點都去過一次。有可能找不到。
「Hamilton Path」尚無多項式時間演算法。直覺的解法是backtracking，窮舉所有點的各種排列方式，一種排列方式當作一條路徑，判斷是不是Hamilton Path。
運用動態規劃，可以減少計算時間。拆掉一條路徑的最後一條邊，就得到遞迴公式。需要額外維度，記錄路徑終點。

path[S+{j},j] = or_all { path[S,i] && adj[i,j] }   i∈S, j∉S
path[S,j] = or_all { path[S-{j},i] && adj[i,j] }   i∈S, j∉S

時間複雜度為O(2ᴺ N²)，空間複雜度為O(2ᴺ)。

const int N = 10;
bool adj[N][N];		// adjacency matrix
bool dp[1<
UVa 216 10068 10496 10818 10937 10944 10605 10890 265
範例：不重複路線（Self-avoiding Walk）

先前介紹過樓梯路線（Staircase Walk）。樓梯路線問題，只能往兩個方向走，可以簡單的遞迴分割，得到多項式時間演算法。不重複路線問題，可以往四個方向走，無法簡單的遞迴分割，只有指數時間演算法。儘管如此，不重複路線還是可以使用動態規劃。
http://blog.sina.com.cn/s/blog_51cea4040100gmky.html
中文網路稱為「插頭DP」或「輪廓線DP」。
UVa 10572 10531 ICPC 4789 4793 Timus 1519
範例：Domino Tiling
https://github.com/indy256/olymp-docs/raw/master/dp2.pdf
http://www.math.ntu.edu.tw/~shing_tung/PDF/4th/04Jiang.pdf
UVa 11741


Dynamic Programming: stack / deque

概論

F[n] = min/max { F[i] ⋅ W[i] + C[i] }
       0<=i< n

F[n]是未知數，F[i] W[i] C[i]是已知數。計算到F[n]時，F[i]早已計算完畢，因此F[i]是已知數。
這種形式的recurrence，直接計算是O(N²)。此處介紹更快的演算法。
stack
括號配對極值。stack保持嚴格遞增（嚴格遞減），以便即時獲取過往最大值（最小值）、即時移除已處理數值。

          maximize problem
          keep monotone increasing  ---->
      ---------------------------------------
stack | F[2] | F[4] | F[6] |   ...   | F[10] 
      ---------------------------------------
                                      ^^^^^^^ extract maximum
                clean tops until monotonicity
                    then push new F[i] at top

F[i]放入尾端。放入前，先清除尾端數值，使得F[i]放入尾端之後，stack呈嚴格遞增。最大值從尾端取得。
範例：Largest Empty Rectangle
詳見「Largest Empty Rectangle」。
範例：All Nearest Smaller Values
http://en.wikipedia.org/wiki/All_nearest_smaller_values
deque
滑動視窗極值。deque保持嚴格遞增（嚴格遞減），以便即時獲取過往最小值（最大值）、即時移除已處理數值。

            minimize problem
            keep monotone increasing  ---->
        --------------------------------------
deque    F[2] | F[4] | F[6] |   ...   | F[10] 
        --------------------------------------
        ^^^^^^                         ^^^^^^^
     extract minimum          clean tails until monotonicity
                              then push new F[i] at end

F[i]放入尾端。放入前，先清除尾端數值，使得F[i]放入尾端之後，deque呈嚴格遞增。放入後，再清除頭端數值，使得元素個數符合滑動視窗大小。最小值從頭端取得。
中文網路稱為「單調隊列優化」。
ICPC 4327
範例：Maxium Sum Subarray
詳見「Maxium Sum Subarray」。
範例：Maximum Average Subarray
詳見「Maxium Average Subarray」。
由於斜率是關鍵，因此中文網路稱為「斜率優化」。

Dynamic Programming: convex hull

概論

F[n] = min/max { F[i] ⋅ W[n] + C[i] }
       0<=i< n

W[i]換成W[n]。前章節W[i]不隨時間n而變化，但是各有不同；本章節W[n]隨著時間n而變化，但是一律相同。
envelope
直線y = F[i] x + C[i]、鉛直線x = W[n]，交點Y座標是F[n]。
最小（大）值對應最低（高）交點。

最小（大）值位於下（上）包絡線。

convex hull
如果討厭包絡線，可透過點線對偶，從包絡線變成凸包。
直線穿過點(F[i], -C[i])，斜率W[n]，Y軸截距是-F[n]。
垂直方向翻轉，讓最小（大）值對應最低（高）截距。
直線穿過點(F[i], C[i])，斜率-W[n]，Y軸截距是F[n]。

最小（大）值位於下（上）凸包的切線，跟Y軸的交點。

如果不熟悉點線對偶，可透過移項推導，得到相同結論：
http://www.cnblogs.com/Rlemon/p/3184899.html
根據F[i]與W[n]的性質，時間複雜度隨之變化：
一、W[n]皆相同：不必維護凸包，只需維護每個點在「斜率-W[n]的直線的垂直方向上」的先後順序，彷彿「單調隊列優化」。一個常見的例子是W[n] = 1。O(N)。

二、F[i]與W[n]皆單調：Andrew's monotone chain維護下凸包（求最小值時）。切線斜率-W[n]遞減/增。直接從上次切點開始，往左/右找到新切點。O(N)。

三、F[i]單調：Andrew's monotone chain 維護下凸包（求最小值時）。切線斜率-W[n]會變。三分搜尋找到切點，或者二分搜尋凸包斜率找到切點。O(NlogN)。

四、無特別性質：動態凸包資料結構。O(NlogNlogN)。


http://blog.csdn.net/madaidao/article/details/40823207

UVa 12524 ICPC 5133
範例：1D p-Median Problem
詳見「p-Median Problem」。
https://algnotes.wordpress.com/2013/10/25/p-median/
範例：Bounded Knapsack Problem
詳見「Bounded Knapsack Problem」。

Dynamic Programming: unimodal function

概論

F[n] = min/max { M[i] }   M[i] is monotone/unimodal
       0<=i< n

根據M[i]的性質，時間複雜度隨之變化：
一、F[n]的子問題們，其答案M[0]...M[n-1]恰好是單調函數：根本沒啥好算，最佳解顯然是第一個（最後一個）子問題。O(N)。
二、F[n]的子問題們，其答案M[0]...M[n-1]恰好是單峰函數：三分搜尋山峰，或者二分搜尋斜率。O(NlogN)。
三、每個問題的單峰函數，山峰位置恰好遞增（往右移動）：用同一條掃描線尋找山峰。O(N)。
unimodal function
什麼時候會是單峰函數呢？舉兩個例子。

F[n] = min { max(F[i], G[i]) + 5 }
     0<=i< n

F遞增、G遞減，則max(F[i], G[i]) + 5是單峰函數。不過這個例子有點蠢，山谷恰好永遠不動。


F[n] = min { F[i] + G[i] }
     0<=i< n

F G皆是凸函數，則F[i] + G[i]是凸函數，即是單峰函數。不過這個例子也有點蠢，山谷恰好永遠不動。

範例：Egg Drop
一堆蛋，已知耐力皆相同，不知耐力為多少。試求耐力。
耐力是以樓層衡量：大於某樓層，摔下必破，無法重複使用；小於等於某樓層，摔下必不破，完全不會折損，可以重複使用。
這個問題有許多變形，此處討論實驗場地是n層樓的情況：
一、最少摔破幾顆蛋？需要事先準備幾顆蛋？
答：一顆蛋。從一樓開始摔，逐步上樓，直到摔破為止。
二、無限多蛋，運氣不好時，最少摔幾次？
答：二分搜尋。F[0] = 0, F[1] = 1, F[n] = F[ceil((n-1)/2)] + 1。
三、一顆蛋，運氣不好時，最少摔幾次？
答：n次。耐力不幸是n樓，從一樓開始摔，要摔n次。
四、兩顆蛋，運氣不好時，最少摔幾次？
答：首發選在i樓。如果摔破了，剩下一顆蛋，只好從一樓開始測試；最差的情況，耐力是i-1樓，要摔i-1次。如果沒有摔破，仍是兩顆蛋，問題仍相同，範圍縮小成n-i樓。兩種情況取最大值。窮舉i，找到次數最少者。

F[n] = 1 +  min { max(i-1, F[n-i]) }
          1<=i<=n
F[n] = 1 +  min { max(i, F[n-1-i]) }   調整索引值
          0<=i< n

i遞增，F[n-1-i]遞減，因此max(i, F[n-1-i])是單峰函數，而且山谷持續往右移動，可以使用掃描線解決。另外也有數學公式解：
https://www.ptt.cc/bbs/Prob_Solve/M.1398152375.A.C05.html
五、k顆蛋，運氣不好時，最少摔幾次？
答：留給讀者。
UVa 10934 882 ICPC 4554
範例：Isotonic Regression
https://algnotes.wordpress.com/2015/01/28/isotonic-regression/
http://stackoverflow.com/questions/10460861/

Dynamic Programming: totally monotone matrix

概論

F[n] = min/max { M[i][n] }   M[i][n] is monotone/totally monotone
       0<=i< n

根據M[i][n]的性質，時間複雜度隨之變化：
一、M[i][n]是上三角monotone matrix：似乎沒有特別快的演算法，仍是O(N²)。
二、M[i][n]是上三角totally monotone matrix：兩個演算法，O(NlogN)與O(Nα(N))。以下只談第一個，分成凹凸兩種情況。
三、M[i][n]是上三角Monge matrix：至今仍然沒有專屬演算法，大家都是沿用totally monotone matrix的演算法。
Monge matrix比較常見。常見的形式是：

F[n] = min/max { F[i] ⋅ W[i] + C[i][n] }
       0<=i< n

(1) F[i] is non-negative
(2) W[i] is non-negative
(3) C[i][n] is Monge
thus M[i][n] = F[i] ⋅ W[i] + C[i][n] is Monge (non-negative linearity)

區間觀點：本章節是尾端區間C[i,n]，前章節是頭端區間C[0,i]（省略了0）。
時變觀點：本章節C[i][n]隨著時間n而變化（C[i][n]改寫成C[n][i]），前章節C[i]不隨時間n而變化。
Monge matrix的不等式曾經稱作quadrangle inequality，因此中文網路稱為「四邊形不等式優化」。
convex totally monotone matrix
大意：直條最小值位置往上遞減。使用stack。
首先畫出C[i][n]，一個上三角矩陣。圖片省略了實際數值。

計算F[1]：F[0] ⋅ W[0]加到C[0][1]即得。
計算F[2]：F[0] ⋅ W[0]加到C[0][2]，F[1] ⋅ W[1]加到C[1][2]，取直條C[:][2]最小值。
以此類推。時間複雜度為O(N²)。

重新反省計算過程，改良演算法：
一、算出F[i]之後，F[i] ⋅ W[i]加到對應的橫條，比較省事。由於F[i] ⋅ W[i]非負，結果仍是凸Monge矩陣，亦是凸全單調矩陣！
二、計算F[i]，即是取直條最小值。隨時記錄每個直條的最小值位置，每次F[i] ⋅ W[i]加到對應的橫條，順手更新最小值位置。
得到一個更容易解釋的演算法。時間複雜度仍為O(N²)。

凸全單調矩陣（直條版本），每個子矩陣都是凸單調矩陣，直條最小值位置總是往上遞減！
算出F[i]之後，從左往右更新最小值位置。最小值位置可能變i、可能不變。變與不變有著唯一一條分界線，左側一律變i，右側一律不變，以滿足遞減性質。
雖然可以提早break，但是時間複雜度仍為O(N²)。

位置相同者，合併成一個區間，最多N個區間。每當更新最小值位置，從左往右判斷每個區間的右端位置，直到遭遇不變的位置。然後二分搜尋該區間，找到分界線。
使用stack實作，一筆資料有兩個參數：區間右端的直條編號、最小值位置。每回合pop一些區間、做一次二分搜尋、push一個區間。時間複雜度為O(NlogN)。
concave totally monotone matrix
大意：直條最小值位置往下遞增。使用deque。
改成從右往左更新最小值位置。時間複雜度為O(NlogN)。

範例：Word Wrap
https://algnotes.wordpress.com/2013/10/26/word-wrap/

Dynamic Programming: interval

Knuth's optimization

F[i,j] =  min  { F[i,k] + F[k,j] + C[i,j] }
        i<=k<=j

C[i,j] satisfies "monge matrix" and "sorted matrix".
                (upper trianglar)     (toward ↗)

interval coverage: C[a,b] <= C[c,d] when [a,b] ⊆ [c,d]
interval coverage: C[a,b] <= C[c,d] when c<=a<=b<=d
    sorted matrix: ← <= → and ↓ <= ↑
      (toward ↗)

四邊形不等式，得到單調性的左邊界。已排序矩陣，得到單調性的右邊界。
問題依大小排列，問題的最佳分割點恰好也依大小排列。中文網路稱為「決策單調性」。
http://www.quora.com/What-is-Knuths-optimization-in-dynamic-programming
範例：Optimal Binary Search Tree
N筆資料，欲建立成一棵「Binary Search Tree」。並且預測了每筆資料的搜尋次數。
請問Binary Search Tree是什麼形狀，才能讓拜訪到的節點數量最少呢？也就是說，每個節點的「深度」乘上「搜尋次數」，總和要最小。

遞迴公式類似於Matrix Chain Multiplication，都是記錄區間。窮舉樹根，分割成左右兩棵子樹遞迴下去。子問題總共O(N²)個，一個子問題要窮舉O(N)種分割點，故時間複雜度為O(N³)。


// 陣列邊界左右各加一格，省去判斷陣列邊界的麻煩。
int freq[8+2] = {0, 4, 2, 1, 2, 3, 1, 2, 1};

int pre[8+2];		// 累積和
int c[8+2][8+2];	// 實行DP所用的陣列。
int p[8+2][8+2];	// 記錄樹根，也就是分割點。

// 區間和
int sum(int i, int j) {return pre[j] - pre[i-1];}

void optimal_binary_search_tree()
{
	for (int i=1; i<=8; ++i)
		pre[i] = pre[i-1] + freq[i];

	for (int i=1; i<=8; ++i)
	{
		dp[i][i] = freq[i];
		p[i][i] = i;
	}

	// 計算順序為online版本
	for (int k=2; k<=8; ++k)		// 區間終點
		for (int i=k-1; i>=1; --i)	// 區間起點
		{
			c[i][k] = 1e9;
			for (int j=i; j<=k; ++j)	// 分割點
				if (c[i][j-1] + c[j+1][k] + sum(i,k) < c[i][k])
				{
					c[i][k] = c[i][j-1] + c[j+1][k] + sum(i,k)
					p[i][k] = j;
				}
		}

	cout << "總共拜訪到的節點數量" << c[1][8];
}

由於第二層迴圈的sum(i,k)維持定值，不會影響最大值的判斷結果，所以可以挪到迴圈外面，減少加法次數，減少執行時間。

	for (int k=2; k<=8; ++k)		// 區間終點
		for (int i=k-1; i>=1; --i)	// 區間起點
		{
			c[i][k] = 1e9;
			for (int j=i; j<=k; ++j)	// 分割點
				if (c[i][j-1] + c[j+1][k] < c[i][k])
				{
					c[i][k] = c[i][j-1] + c[j+1][k];
					p[i][k] = j;
				}
			// 挪到迴圈外面，最後再加上去。
			c[i][k] += sum(i,k);
		}

總共O(N²)個子問題，每個子問題必須窮舉O(N)個分割點，所以時間複雜度是O(N³)。
到這裡都和普通的Dynamic Programming沒兩樣。接下來要更進一步。
每次計算一個子問題，總是得窮舉所有的分割點。然而有些分割點顯然是錯誤的，尤其是靠近區間邊界的那些分割點，實在不太可能將兩棵子樹分割的夠均勻、令總和最小。

相近的子問題，其分割點也很相近。子問題[a,b]，嘗試從從右端拿掉一筆資料，成為子問題[a,b-1]；子問題[a,b]、[a,b-1]的分割點很相近。
為了讓左右子樹均勻，[a,b]的分割點一定要大於等於[a,b-1]的分割點，才能降低總和。小於[a,b-1]的分割點，沒有窮舉的必要，樹只會越不平衡、總和只會更大不會更小！
子問題[a+1,b]的情況也十分類似，不再贅述。
也就是說，子問題[a,b]的分割點，必定位於更小的子問題[a,b-1]和[a+1,b]的分割點之間。計算一個子問題，大可不必窮舉所有的分割點。

			for (int j=p[i][k-1]; j<=p[i+1][k]; ++j)	// 分割點


觀察分割點表格，[a,b-1]是左方格子，[a+1,b]是下方格子。要計算一個分割點，窮舉範圍就是左方格子的值到下方格子的值。也就是說每一個格子都會大於等於左方格子、小於等於下方格子。
每一條左上右下斜線，左上最小值是0，右下最大值是N-1，每一條斜線最多窮舉2N = O(N)個分割點。
除了初始值之外，總共N-1條斜線，需要窮舉的分割點總共O(N²)個，所以時間複雜度下降為O(N²)。
UVa 10304 10003 12057 12809 ICPC 7464
範例：1D p-Center Problem
詳見「p-Center Problem」。
Hu's optimization

F[i,j] =  min  { F[i,k] + F[k,j] + C[i]⋅C[j]⋅C[k] }
        i<=k<=j

Matrix Chain Multiplication可加速至O(NlogN)。
我沒有研究。
參考文獻
https://www.ptt.cc/bbs/Prob_Solve/M.1458211168.A.907.html

[slope]
using geometric techniques to improve dynamic programming algorithms
for the economic lot-sizing problem and extensions

[totally monotone matrix 1]
dynamic programming with convexity, concavity and sparsity

[totally monotone matrix 2]
an almost linear time algorithm for generalized matrix searching

[Knuth's optimization]
optimum binary search trees

[Hu's optimization]
computation of matrix chain products, part I, part II


















動態規劃






light
dark


 我的部落格:
人權


玩具



快速跳到:


	社群活動
本層目錄
上層目錄
此頁@朝陽
此頁@資管
English























動態規劃

在 「愚公移山與遞迴」
  一篇當中談到 exhaustive search 類問題。 其實此類問題,
  未必都真的需要用愚公移山的方式來解。 有一部分看似需要用遞迴解的問題,
  其實可以用更有效率的 動態規劃 dynamic programming
  演算法來解。
最長共同子序列
研究物種演化關係的生物學家, 比對不同物種的 DNA 到底有多麼接近,
  據此可以建立出 phylogenetic
  tree。 我們研究這個問題的簡化版: Longest Common Subsequence
  最長共同子序列 問題: 找出 X 與 Y 兩個序列最長的共同部分,
  例如:
  X = (A G C T A T
A C G A T G A C
  T)
  Y = (G T C A G T A T
A G T C A T A T
  G)
  這兩個序列最長的共同部分, 就是:
G C T A T A G A T A T
構想一: 大不了將 X 的所有子序列找出來, 逐一檢查看看 X
  的每個子序列是否也是 Y 的子序列。 ==> 用遞迴解。 Q:
  試寫一個遞迴程式, 產生 X 的所有子序列。
構想二: 我們設法將原問題拆成幾個小一號, 但與原問題類似的問題。
  假設輸入資料為 X = (x(1),x(2),...x(m)) 及 Y = (y(1),y(2),...y(n))
  兩個序列。 "X 與 Y 的尾巴元素是否相同? x(m) == y(n) 嗎?"
  我們根據這個問題的所有可能答案 (其實只有兩種可能) 分項來討論。

若尾巴相同, 那麼顯然這個共同的尾巴會出現在 LCS 的尾巴。
    所以可以把 X 的尾巴切掉得到 X', 又把 Y 的尾巴切掉得到 Y', 求 X' 與
    Y' 的 LCS, 然後在這個 LCS 的尾巴接上 x(m) (也就是 y(n))
    就可以了。
若尾巴不同, 那麼這兩個尾巴元素不可能同時對 LCS 都有貢獻。 改求
    X' 與 Y 的 LCS, 及 X 與 Y' 的 LCS,
    兩者之中必然有一個就是我們要的答案。

==> 構想二還是用遞迴解。 如果我們寫一個遞迴程式 lcs
  計算最長共同子序列的長度, 其中最核心的工作將是:

        int lcs(char *x, char *y) {
            ...
            if (x[0] == y[0])
                return lcs(x+1, y+1) + 1;
            else {
                a = lcs(x, y+1);
                b = lcs(x+1, y);
                return a > b ? a : b;
            }
            ...
        }

這裡我們順著 c 語言的規定 (字串尾巴固定是 '\0') 遞迴時採取截頭,
  而非去尾, 但觀念是一樣的。

                              A...ACT
                         /----G...ATG----\
                         |               |
                       A...AC          A...ACT
                   /---G...ATG--\      G...AT
                   |            |          |
                 A...A        A...AC       |
              /--G...ATG--\ /-G...AT-----\ |
              |           | |            | |
             A...        A...A          A...AC
             G...ATG     G...AT         G...A

如果真的用這個演算法去解, 會花蠻多時間的, 這個問題應該放到
  「愚公移山與遞迴」 那一章去討論。
  但我們註意到遞迴時, 不同的子問題會 重複地問相同的孫問題,
  非常浪費。 例如上圖當中的 lcs("A...A", "G...AT") 與 lcs("A...AC",
  "G...A") 都各被問了兩次。 何不改採由下而上的順序解題: 先解孫問題,
  把答案存在表格裡, 然後再解子問題, 最後才解父問題?
  這樣當子問題需要孫問題的答案時, 直接查表即可, 不論孫問題被查詢多少次,
  都不會再重複計算, 省下許多時間。 於是得到一個動態規劃類的演算法
  lcs 範例程式 。
除了記載最長共同子序列的 長度 之外,
  還要記取每步截短問題時,
  究竟選取那一個子問題的答案來當做本問題的基礎。 在 lcs
  範例程式 當中, path 陣列的功用正是如此。 最後可藉著 path
  陣列一路往回走, 方可找出最長共同子序列。 走斜角方向的步驟, x, y
  兩序列該元素相同, 也正是共同子序列的一部分。
  走垂直或水平方向的則對共同子序列沒有貢獻。 動態規劃版的 LCS,
  所使用的表格大小 O(mn), 耗時 O(mn)。
背包問題
背包問題 knapsack problem: 有 n 種物品 x(1), x(2),
  ...x(n), 其價值與重量各為 v(i) 與 w(i) (i=1,2,...n), 其中所有的
  w(i) 均為整數。 如何搭配選取這 n 種物品, 使得選出的物品價值最高,
  但總重量不超過負重限制 m? 例如 m=23, n=5,
  各種物品的價值與重量分別為:


品名 x(i)
A
B
C
D
E


價值 v(i)
19
24
33
45
50


重量 w(i)
5
6
8
11
12


限量 c(i)
6
6
5
1
1


背包問題其實有好幾個版本:

限量供應版: 每種物品數量有限, 像上面 A 只有 6 個, B 只有 6 個,
    C 只有 5 個, D 與 E 各只有 1 個, 拿完就沒有了。 而且只能拿整數個,
    不可以拿 0.3 個之類的。
0-1 knapsack: 每種物品只有一個。
    相當於第一種版本當中, c(1)=c(2)...=c(n)=1
integral knapsack: 每種物品無限量供應。
    相當於第一種版本當中, c(1)=c(2)...=c(n)=無窮大
fractional knapsack: 每樣物品可不取, 全取,
    或只取一部分 (想像是一大桶的金粉, 一大桶的銀粉, ...)。 用下節的
    greedy algorithm 解。

範例程式 knapsack 裡面有兩個版本: ks_ul
  (修改自 Sedgewick 書中程式) 是無限量供應版; ks_count 是第一種
  (彈性最大, 最麻煩的) 限量供應版。
先看較簡單的無限量版 integral knapsack。 想解決這個問題,
  我們先自問一個簡單的問題: 最佳解裡面, 究竟有沒有取 x(n)?
  只有兩種可能:

有。 那麼何妨請另外一位頭腦比我們發達, 四肢比我們簡單, 僅能負重
    m-w(n) 的人, 來幫我們解決小一號的問題?
    等他將他的背包以最佳方式填滿之後, 我們再將 x(n) 放進去,
    就是我們的最佳解了。
沒有。 那麼 x(n) 的存在, 不過是在擾亂我們的心智,
    其實一點用處也沒有。 不如當做 x(n) 根本不存在, 直接解小一號的問題:
    "只有 x(1) ... x(n-1) 可選取, 負重限制為 m"。

如果在解 "有 x(1) ... x(n) 可選取, 負重限制為 m" 的問題時,
  已有上述問題的答案, 就只需要查表。 從這裡可以看出應如何製作表格。
  定義 P(i,j) 為這個問題: "有 x(1) ... x(j) 可選取, 負重限制為 j"。
  我們將 P(i,j) 的答案, 放在第 i 列, 第 j 行, 由上而下, 由左而右,
  逐一填表, 得到以下演算法:

        for (每多一種物品 x(j) 加入可選擇行列) {
            for (由小而大考慮負重限制為 i 的小一號問題) {
                if (value[i] < value[i-w[j]] + v[j]) {
                    value[i] = value[i-w[j]] + v[j];
                    last[i] = j;
                }
            }
        }


                           * (少一種物品可選)
                           |
                           v
                * -------->*
              (負重稍輕)   (要解的問題)
   --- .. -- 5-------------10-------------15-------------20-------------25
 A:  0 .. 0 19 19 19 19 19 38 38 38 38 38 57 57 57 57 57 76 76 76 76 76 95
     - .. -  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A
 B:  0 .. 0 19 24 24 24 24 38 43 48 48 48 57 62 67 72 72 76 81 86 91 96 96
     - .. -  A  B  B  B  B  A  B  B  B  B  A  B  B  B  B  A  B  B  B  B  B
 C:  0 .. 0 19 24 24 33 33 38 43 48 52 57 57 66 67 72 76 81 85 90 91 99100
     - .. -  A  B  B  C  C  A  B  B  C  C  A  C  B  B  C  C  C  C  B  C  C
 D:  0 .. 0 19 24 24 33 33 38 45 48 52 57 57 66 69 72 78 81 85 90 93 99102
     - .. -  A  B  B  C  C  A  D  B  C  C  A  C  D  B  D  C  C  C  D  C  D
 E:  0 .. 0 19 24 24 33 33 38 45 50 52 57 57 66 69 74 78 83 85 90 95100102
     - .. -  A  B  B  C  C  A  D  E  C  C  A  C  D  E  D  E  C  C  E  E  D
   --- .. -- 5-------------10-------------15-------------20-------------25

註意表格畫出來雖然是二維的, 但程式裡面其實只用到兩個一維陣列。
  計算 "至 x(i) 可拿" 問題時, 只需要參考到 "至 x(i-1) 可拿" 的答案;
  更早的答案並不需要, 所以不必記住。
至於最後究竟應該取那這樣物品才會達成最佳解, 只要沿著 last
  陣列倒退找即可。 因為 last[m] 記載著最後取的那件物品,
  如果將它從背包取出不算, 那麼剩下來的 (其他該取的) 物品, 可以從
  "負重限制 m-w[last[m]] 問題" 的解答裡讀出來, 依此類推... 以上例來說,
  從表格的 E-25 當中讀出最後取的物品為 D; 於是倒退回去查 E-14 讀出 C;
  再查 E-6 讀出 B。 所以最佳解為 D,C,B。 又例如 m=21 呢? 從 E-21 讀出
  C; 於是倒退回去查 E-13 讀出 C; 再查 E-5 讀出 A。 所以最佳解為
  C,C,A。
為什麼都是查 e 那一列呢? 如果最後拿的不是 e,
  本來應該向上查而不是向左查呀? 其實向左查,
  會發現它的答案根本就是從上面抄下來的。 所以兩種查法都正確;
  但若向上查, 則陣列空間無法重複使用, 必須真的使用二維陣列; 向左查,
  則舊的資料就可以直接丟棄不用, 比較節省演算法的空間。
表格使用空間為 O(m); 整個演算法耗時 O(mn)
接下來看限量供應版。 最後一件物品所取的不是 x(n),
  未必就表示完全不取 x(n) -- 有可能因為 x(n) 已經取光了。
  也可能因此而必須回頭取從前考慮過的其他類物品, 如 x(1),x(2),... 到
  x(n-1) 呀! 我們改問另外一句話: 如果從最佳解裡面刪除一件物品的話,
  得到的會是那一個 (小一號) 問題的最佳解?
  如果從最佳解的袋中刪除一件物品 x(i), 得到的應該是 「負重限制為
  m-w(i)」 的最佳解。 所有可能刪除的物品完全試過一遍之後,
  也就將原問題的所有可能性尋遍了。 當然也有最後一種可能: 根本就沒有
  「可能刪除的物品」 -- 因為負重限制太低, 連最輕的東西都拿不起。
  這樣的想法會造成某些答案重複考慮, 不過這無傷大雅, 大不了降低一點效率;
  重點是不可以有遺漏。 於是必須修改建表的順序,
  兩層迴圈的內外關係對調過來, 得到不同的表格:

                           * (負重稍輕)
                           |
                           v
        *       *          *
        |       |          ^
        |  ...  |          |
        -------------------/
           (少取一件物品)

    val/lim | bi  A  B  C  D  E     95/ 23 |  D  0  0  0  1  1
      0/  1 |  -  0  0  0  0  0     99/ 24 |  C  0  0  3  0  0
      0/  2 |  -  0  0  0  0  0    102/ 25 |  A  1  0  1  0  1
      0/  3 |  -  0  0  0  0  0    107/ 26 |  B  0  1  1  0  1
      0/  4 |  -  0  0  0  0  0    111/ 27 |  C  0  0  2  1  0
     19/  5 |  A  1  0  0  0  0    116/ 28 |  C  0  0  2  0  1
     24/  6 |  B  0  1  0  0  0    119/ 29 |  B  0  1  0  1  1
     24/  7 |  B  0  1  0  0  0    123/ 30 |  B  0  1  3  0  0
     33/  8 |  C  0  0  1  0  0    128/ 31 |  C  0  0  1  1  1
     33/  9 |  C  0  0  1  0  0    132/ 32 |  C  0  0  4  0  0
     38/ 10 |  A  2  0  0  0  0    135/ 33 |  A  1  0  2  0  1
     45/ 11 |  D  0  0  0  1  0    140/ 34 |  B  0  1  2  0  1
     50/ 12 |  E  0  0  0  0  1    144/ 35 |  C  0  0  3  1  0
     52/ 13 |  A  1  0  1  0  0    149/ 36 |  C  0  0  3  0  1
     57/ 14 |  B  0  1  1  0  0    152/ 37 |  B  0  1  1  1  1
     57/ 15 |  A  3  0  0  0  0    156/ 38 |  B  0  1  4  0  0
     66/ 16 |  C  0  0  2  0  0    161/ 39 |  C  0  0  2  1  1
     69/ 17 |  A  1  0  0  0  1    165/ 40 |  C  0  0  5  0  0
     74/ 18 |  B  0  1  0  0  1    168/ 41 |  A  1  0  3  0  1
     78/ 19 |  C  0  0  1  1  0    173/ 42 |  B  0  1  3  0  1
     83/ 20 |  C  0  0  1  0  1    177/ 43 |  C  0  0  4  1  0
     85/ 21 |  A  1  0  2  0  0    182/ 44 |  C  0  0  4  0  1
     90/ 22 |  B  0  1  2  0  0    185/ 45 |  B  0  1  2  1  1

如表格所示, 這次我們真的用一個 m*n 的二維陣列來存, 所以使用空間為
  O(mn)。 每填一列, 需要做以下工作:

檢查先前填的 n 列:

      
在 m-w(i) 列裡面, x(i) 用完了嗎?
m-w(i) 的的價值, 加上 v(i) 是多少?


從上面挑出最佳解 (最大值)
將上面某一列拷貝下來, 其中一個數字加一

也就是每一列花 O(n) 的時間, 所以整個演算法耗時 O(mn)。
也可以多花一些時間, 少用一些空間。 先前的 m*n 二維陣列叫做 taken
  好了, taken[i][j] 裡面存的是 「負重限制 i」 的最佳解裡面, x(j)
  取了幾個。 現在不用 taken 陣列, 改用一個函數 taken(int i, int j)
  來取代它的功能。 回想先前 「無限量供應版」 最後印出所有物品的方式,
  同樣的方法可以在 O(m) 時間內算出答案。 這個函數在上面的 1.1
  步需要用到; 至於第 3 步則不存在。 所以總共使用空間為 O(m)
  而使用時間為 O(m^2 n)。 範例程式裡面的 ks_count 其實的是這一版。
安排一連串矩陣的乘法
線性代數 當中學到: 一連串 n 個矩陣相乘時,
  只要矩陣排列的順序不變, 不論先算那個乘法, 都會得到相同的答案
  (因為矩陣的乘法滿足 結合律 associativity)。 先算那個乘法,
  雖然不影響答案, 卻會影響效率。 例如: (以下有關矩陣的範例以 rlab 的語法表示。 簡要地說, 以 ';' 分隔列,
  以 ',' 分隔同一列上的元素) 例如若 A1=[5;2;-1;8]; A2=[-3,2];
  A3=[7,0,-4;6,2,5]; 要相乘, 也就是要算:

        / 5 \  *  [ -3 2 ] *  / 7 0 -4 \
        | 2 |                 \ 6 2  5 /
        |-1 |
        \ 8 /

如果先算左邊再算右邊, 要花 8+24 個乘法; 如果先算右邊再算左邊,
  則只要花 6+12 個乘法。 又如: A1=[1,2,3,4,5]; A2=[6;7;8;9;10];
  A3=[11,12,13,14,15,16]; A4=[17;18;19;20;21;22] 則最快的方法是
  (A1*A2)*(A3*A4) 共需要做 5+6+1 個數字的乘法; 最慢的方法是
  (A1*(A2*A3))*A4 共需要做 30+30+6 個數字的乘法。 三個矩陣相乘,
  只有兩種順序; 四個相乘就有五種; 如果有十幾個矩陣相乘,
  有那麼多不同的運算順序, 究竟應該按照什麼樣的順序, 才可以節省時間呢?
  在眾多不同的運算順序當中, 如何找出最有效率的一種 "括小括弧的方式" ,
  這個問題稱為 matrix-chain multiplication problem。
構想: 大不了將所有 "括小括弧的方式" 逐一列舉,
  並逐一計算需要花多少個數字乘法, 再挑出最好的 ==> exhaustive
  search, 可以用遞迴解決! 我們想解決 n 個矩陣相乘的問題,
  先假設有人可以替我們解決任何小一號或更小的問題 (給他 n-1 個矩陣,
  他可以告訴我們如何相乘最有效率) 那麼我們的工作變得很簡單:
  如果最後做的乘法是 A1*(A2.....An), 那麼需要花多少個數字乘法?
  如果最後做的乘法是 (A1..A2)*(A3.....An), 又需要多少個數字的乘法呢?
  如果最後做的乘法是 (A1..A3)*(A4.....An) 呢? ... 如果最後做的乘法是
  (A1..A(n-1))*An) 呢? 每一個小問題都可請這位包工回答,
  我們只需要負責整理他的答案即可。
可以看得出來, 每個小問題其實是兩個類似原題的問題。 作業:
  請寫一個遞迴的程式解決此問題。
每一種括小括弧的方法, 其實正對應到一棵 expression tree。 總共有多少種? a(1)=1,
  a(n)=a(1)*a(n-1)+a(2)*a(n-2)...+a(n-1)*a(1) 這個數列稱為 Catalan
  numbers。 a(n) 大約為 Theta(4^n/n^1.5)。
  想用遞迴演算法檢查每一種括小括弧的方法, 非常耗時。
仔細觀察, 發覺遞迴時, 不同的子問題, 卻經常會有共同的「孫問題」。
  例如 100 個矩陣相乘時, "A31*A32..*A40 要如何乘比較有效率?"
  這個孫問題, 被重複問了好多次, 像是 "A1*A2...*A40 要如何乘比較有效率?"
  或是 "A31*A32...*A50 要如何乘比較有效率?" 都會用到它。
  如果不要由上往下遞迴, 而是改成由下往上建「答案表」, 就快多了。
  這樣要解決上層的問題時, 就不再需要一層層往下遞迴,
  只要花一點點時間查現成的表格就可以了。
以下用 範例程式 做一個例子來說明。 有有
  A,B,C, ... H 等八個矩陣要連乘, 其大小各為: 32x35, 35x24, 24x30,
  30x36, 36x25, 25x40, 40x34, 34x35。 在程式開頭處設定: @chain =
  qw(32 A 35 B 24 C 30 D 36 E 25 F 40 G 34 H 35); 然後執行 perl
  matrixchain 得到以下輸出:

    B          C          D          E          F          G          H    
26880:A|B  49920:B|C  80448:B|C  91080:B|C 123080:E|F 152280:E|F 181720:B|C  A
           25200:B|C  56160:B|C  66000:B|C 101000:E|F 127960:B|C 157360:B|C  B
                      25920:C|D  45000:C|D  69000:E|F  99400:E|F 127960:G|H  C
                                 27000:D|E  57000:E|F  86500:E|F 117000:E|F  D
                                            36000:E|F  64600:E|F  95250:E|F  E
                                                       34000:F|G  63750:G|H  F
                                                                  47600:G|H  G

例如 B-G 這一格 (第 B 列, 第 G 行) 是如何算出來的呢? 考慮
  「最後一個乘法究竟發生在何處?」 這個問題有五種可能性:


發生在...
左半代價
右半代價
兩半相乘代價
總計


B 與 C 之間:
0
+ 99400
+ 35*24*34
= 127960
<== 最小


C 與 D 之間:
25200
+ 86500
+ 35*30*34
= 147400


D 與 E 之間:
56160
+ 64600
+ 35*36*34
= 163600


E 與 F 之間:
66000
+ 34000
+ 35*25*34
= 129750


F 與 G 之間:
101000
+ 0
+ 35*40*34
= 148600


得知拆成 B 與 (C*...*G) 最佳, 共需要 127960 個乘法。
又例如 D-H 計算過程如下:


發生在...
左半代價
右半代價
兩半相乘代價
總計


A 與 A 之間:
0
+ 95250
+ 30*36*35
= 133050


A 與 A 之間:
27000
+ 63750
+ 30*25*35
= 117000
<== 最小


A 與 A 之間:
57000
+ 47600
+ 30*40*35
= 146600


A 與 A 之間:
86500
+ 0
+ 30*34*35
= 122200


得知拆成 (D*E) * (F*...*H) 最佳, 共需要 117000 個乘法。
最後, 從 A-H 那一格 (第 A 列, 第 H 行) 開始, 往回查表,
  可以讀出完整的最佳 expression tree。 先從 A-H
  得知最後一個乘法發生的位置在 B 與 C 之間, 再遞迴分別從 A-B 與 C-H
  讀出他們的最佳乘法分別發生在 A 與 B 之間, 及 G 與 H 之間, ...,
  由上而下畫出 expression tree, 進而得到最佳括括弧方式:

          /---*------------------------\
          |                            |
         /*\                /----------*-\
         | |                |             |
         A B       /--------*----\        H
                   |             |
                 /-*---\        /*\
                 |     |        | |
                 C    /*\       F G
                      | |
                      D E
        (   ) * (                         )
         A*B    (                    ) * H
                (         ) * (     )
                 C * (   )      F*G
                      D*E

很明顯, 使用空間為 O(n^2), 而表格的每一格需要花 O(n) 來填寫,
  所以整個演算法耗時 O(n^3), 比直接遞迴快多了。
結論
本單元中的每個問題, 都是要 從許多排列組合當中,
  找出最佳解:

(LCS) X 與 Y 的許多共同子序列當中, 誰的長度最長?
(Knapsack) 那麼多種不同的物件取法, 誰的價值最高?
(Matrix Chain) 許多可能的 expression tree 當中,
    誰的運算花費最低?

這些都是 combinatorial optimization problems。
  解這類問題, 最簡單的想法就是窮舉所有可能性, 逐一比較優劣。 首先
  數數看 如果要窮舉所有可能性,
  把每一種排列組合列舉出來, 大約有多少組可能解需要檢查? (可高估,
  不可低估) 然後就可以按照 「愚公移山與遞迴」 一篇當中的步驟,
  寫出一個遞迴程式。 這個版本速度可能極慢, 但邏輯通常很簡單,
  比較不容易出錯。 先求正確, 等一下再求改進效率。
撰寫遞迴程式時, 需要 「將一個大問題拆成幾個小一號的類似問題」。
  筆者觀察發現: 同一個問題, 可能有很多不同的拆法, 因而會寫出不同的
  遞迴程式; 但其中只有部分的拆法,
  最後可以改成較有效率的動態規劃演算法。 密訣在於: 試著問一個
  分類問題, 用這個問題將所有排列組合分成幾大類,
  再逐類檢查看看最佳解到底落在那一類當中。 例如:

(LCS, X 的尾巴與 Y 的尾巴不相同時)
    誰的尾巴在最佳解裡面沒有派上用場?
(無限量 integral knapsack) 最佳解裡面, 有還是沒有 x(n)?
(限量 integral knapsack) 可以從最佳解裡面刪除那一件物品?
(Matrix Chain) 最佳解的最後一個乘法發生在何處?

這個 "分類" 必須涵蓋所有可能性, 但不必具有唯一性 -- 每種排列組合
  (每個可能解) 都必須屬於至少一個分類; 一種排列組合 (一個可能解)
  重複出現在不同分類裡面, 並沒有關係。 例如限量 integral knapsack, 其實
  "刪除 x(1) 的狀況" 與 "刪除 x(2) 的狀況" 可能重複解了某些小問題
  (最佳解裡面可能兩者都出現 ...) 但這只浪費一點時間,
  並不影響答案的正確性。 而且如果做了下一步,
  把演算法改成查表式的動態規劃, 浪費的時間就更有限了。
接下來觀察遞迴過程當中, 是否有些一模一樣的孫問題,
  先後被不同的子問題重複問了很多次? 若否, 恐怕就很難改用動態規劃; 若是,
  那麼或許可以改設計成動態規劃演算法。 它的特色是由下而上建立表格:
  預先將所有可能問到的孫問題解好, 才考慮如何解子問題。
  這樣孫問題不論被問多少次, 只需要計算一次就好,
  以後都只需要簡單的查表動作。 以下是筆者歸納的 「遞迴演算法 ==>
  動態規劃演算法」 轉換 "公式":

將所有可能問到的小問題列出。 以 LCS 為例, 可能問到的小問題有:
    lcs("", ""), lcs("A", ""), lcs("", "G"), lcs("A", "G"), ...
改用一個陣列來儲存這些小問題的結果。 這個陣列有多大呢?
    每個主要參數參數, 大約對應到陣列的一個維度 (dimension);
    一個參數變化的範圍, 就是那個維度的大小。 例如 lcs(... , ...)
    有兩個主要參數, 所以用二維陣列來儲存; 第一個參數的值, 可能有 m+1
    種變化 (X 的前 0 個元素, X 的前 1 個元素, ... X 的前 m 個元素);
    第二個參數的值, 可能有 n+1 種變化 (Y 的前 0 個元素, Y 的前 1
    個元素, ... Y 的前 n 個元素), 所以需要一個 (m+1)*(n+1)
    的陣列。
看著 (或腦海裡想像著) 這個二維陣列或三維陣列,
    找出所有格子之間的相依關係。
    記得這個陣列的每一格, 對應到一個題目。 解每一格的時候,
    需要用到那些格? 據此決定迴圈的寫法。 例如 LCS 的兩層迴圈,
    順序並不重要; 但兩個版本的 integral knapsack, 迴圈的順序就很重要,
    而且正好相反。 Matrix Chain 的迴圈順序, 看程式有點複雜;
    看表格就很清楚為什麼必須照這個順序。 (Q:
    還有那些不同的順序也可以?)
把遞迴版的 "遞迴" 那句話, 改成 "查表"

許多常見的問題, 把程式由 exhaustive search 版改成動態規劃版,
  時間複雜度往往也從 exponential time 降為 polynomial time;
  當然也需要付出一點代價 -- space complexity 往往會提高一些。
  不過相較於時間的改進, 空間的浪費也不過是 polynomial 而已,
  相當值得的。 Q: 本篇各題如果用遞迴的方式解, 各要花多少時間?


本頁最新版網址: 
       http://www.cyut.edu.tw/~ckhung/b/al/dynaprog.php;
      您所看到的版本: February 14 2012 10:32:24. 
作者: 朝陽科技大學 資訊管理系 洪朝貴
寶貝你我的地球, 請 
      減少列印, 多用背面, 丟棄時做垃圾分類。
本文件以 
      Creative Commons Attribution-ShareAlike License
      或以 
      Free Document License 方式公開授權大眾自由複製/修改/散佈。

























動態規劃 - ACM/ICPC大專程式讀書會






 








ACM/ICPC大專程式讀書會Search this site












Home相關網路資源演算法動態規劃最短路徑相關雜事解題近況Sitemap
Site ownersHamilton Liang



 

演算法‎ > ‎
  

動態規劃



100個動規方程 1.        資源問題1—–機器分配問題F[I,j]:=max(f[i-1,k]+w[i,j-k])2.        資源問題2——01背包問題F[I,j]:=max(f[i-1,j-v]+w,f[i-1,j]);3.        線性動態規劃1—–樸素最長非降子序列F:=max{f[j]+1}4.        剖分問題1—–石子合並F[i,j]:=min(f[i,k]+f[k+1,j]+sum[i,j]);5.        剖分問題2—–多邊形剖分F[I,j]:=min(f[i,k]+f[k,j]+a[k]*a[j]*a);6.        剖分問題3——乘積最大f[i,j]:=max(f[k,j-1]*mult[k,i]);7.        資源問題3          —–系統可靠性(完全背包)F[i,j]:=max{f[i-1,j-c*k]*P[I,x]}8.        貪心的動態規劃1—–快餐問題F[i,j,k]:=max{f[i-1,j',k']+(T-(j-j’)*p1-(k-k’)*p2) div p3} 9.        貪心的動態規劃2—–過河 f=min{{f(i-k)} (not stone)                      {f(i-k)}+1} (stone); +貪心壓縮狀態10.        剖分問題4—–多邊形-討論的動態規劃F[i,j]:=max{正正 f[I,k]*f[k+1,j];                   負負 g[I,k]*f[k+1,j];             正負 g[I,k]*f[k+1,j];              負正 f[I,k]*g[k+1,j];} g為min11.        樹型動態規劃1—–加分二叉樹 (從兩側到根結點模型)        F[I,j]:=max{f[I,k-1]*f[k+1,j]+c[k]}12.        樹型動態規劃2—–選課 (多叉樹轉二叉樹,自頂向下模型)        F[I,j]表示以i為根節點選j門功課得到的最大學分         f[i,j]:=max{f[t.l,k]+f[t.r,j-k-1]+c}13.        計數問題1—–砝碼稱重f[f[0]+1]=f[j]+k*w[j];(1<=i<=n; 1<=j<=f[0]; 1<=k<=a;)14.        遞推天地1——核電站問題f[-1]:=1; f[0]:=1;                      f:=2*f[i-1]-f[i-1-m]       15.        遞推天地2——數的劃分f[i,j]:=f[i-j,j]+f[i-1,j-1];16.        最大子矩陣1—–一最大01子矩陣f[i,j]:=min(f[i-1,j],v[i,j-1],v[i-1,j-1])+1;  ans:=maxvalue(f);                          17.        判定性問題1—–能否被4整除g[1,0]:=true; g[1,1]:=false; g[1,2]:=false; g[1,3]:=false;g[i,j]:=g[i-1,k] and ((k+a[i,p]) mod 4 = j)18.        判定性問題2—–能否被k整除f[I,j±n mod k]:=f[i-1,j];      -k<=j<=k; 1<=i<=n20.        線型動態規劃2—–方塊消除游戲f[i,i-1,0]:=0f[i,j,k]:=max{f[i,j-1,0]+sqr(len(j)+k),              f[i,p,k+len[j]]+f[p+1,j-1,0]}ans:=f[1,m,0]21.        線型動態規劃3—–最長公共子串，LCS問題f[i,j]={0(i=0)&(j=0);        f[i-1,j-1]+1        (i>0,j>0,x=y[j]);        max{f[i,j-1]+f[i-1,j]}} (i>0,j>0,x<>y[j]);22.        最大子矩陣2—–最大帶權01子矩陣O(n^2*m)枚舉行的起始，壓縮進數列，求最大字段和，遇0則清零23.            資源問題4—–裝箱問題(判定性01背包)f[j]:=(f[j] or f[j-v]);24.        數字三角形1—–樸素的數字三角形f[i,j]:=max(f[i+1,j]+a[I,j],f[i+1,j+1]+a[i,j]);25.        數字三角形2—–晴天小豬曆險記之Hill同一階段上暴力動態規劃                if[i,j]:=min(f[i,j-1],f[I,j+1],f[i-1,j],f[i-1,j-1])+a[i,j]26.        雙向動態規劃1數字三角形3—–小胖辦證f[i,j]:=max(f[i-1,j]+a[i,j],f[i,j-1]+a[i,j],f[i,j+1]+a[i,j])27. 數字三角形4—–過河卒//邊界初始化f[i,j]:=f[i-1,j]+f[i,j-1];28.        數字三角形5—–樸素的打磚塊f[i,j,k]:=max(f[i-1,j-k,p]+sum[i,k],f[i,j,k]);29.        數字三角形6—–優化的打磚塊f[I,j,k]:=max{g[i-1,j-k,k-1]+sum[I,k]}30.        線性動態規劃3—–打鼴鼠’f:=f[j]+1;(abs(x-x[j])+abs(y-y[j])<=t-t[j])31.        樹形動態規劃3—–貪吃的九頭龍32.        狀態壓縮動態規劃1—–炮兵陣地Max(f[Q*(r+1)+k],g[j]+num[k])If (map and plan[k]=0) and               ((plan[P] or plan[q]) and plan[k]=0)33.        遞推天地3—–情書抄寫員f:=f[i-1]+k*f[i-2]34.        遞推天地4—–錯位排列f:=(i-1)(f[i-2]+f[i-1]);f[n]:=n*f[n-1]+(-1)^(n-2);35.        遞推天地5—–直線分平面最大區域數f[n]:=f[n-1]+n    :=n*(n+1) div 2 + 1;36.        遞推天地6—–折線分平面最大區域數f[n]:=(n-1)(2*n-1)+2*n;37.        遞推天地7—–封閉曲線分平面最大區域數f[n]:=f[n-1]+2*(n-1)    :=sqr(n)-n+2;38        遞推天地8—–凸多邊形分三角形方法數f[n]:=C(2*n-2,n-1) div n;對於k邊形f[k]:=C(2*k-4,k-2) div (k-1); //(k>=3)39        遞推天地9—–Catalan數列一般形式1,1,2,5,14,42,132f[n]:=C(2k,k) div (k+1);40        遞推天地10—–彩燈佈置排列組合中的環形染色問題f[n]:=f[n-1]*(m-2)+f[n-2]*(m-1);   (f[1]:=m; f[2]:=m(m-1);41        線性動態規劃4—–找數線性掃描sum:=f+g[j];     (if sum=Aim then getout; if sum<Aim then inc(i) else inc(j);)42        線性動態規劃5—–隱形的翅膀            min:=min{abs(w/w[j]-gold)};             if w/w[j]<gold then inc(i) else inc(j);43        剖分問題5—–最大獎勵f:=max(f,f[j]+(sum[j]-sum)*i-t44        最短路1—–Floydf[i,j]:=max(f[i,j],f[i,k]+f[k,j]);ans[q[i,j,k]]:=ans[q[i,j,k]]+s[i,q[i,j,k]]*s[q[i,j,k],j]/s[i,j];45        剖分問題6—–小H的小屋F[l,m,n]:=f[l-x,m-1,n-k]+S(x,k);46        計數問題2—–隕石的秘密（排列組合中的計數問題）Ans[l1,l2,l3,D]:=f[l1+1,l2,l3,D+1]-f[l1+1,l2,l3,D];F[l1,l2,l3,D]:=Sigma(f[o,p,q,d-1]*f[l1-o,l2-p,l3-q,d]);47        線性動態規劃——合唱隊形兩次F:=max{f[j]+1}＋枚舉中央結點48        資源問題——明明的預算方案：加花的動態規劃f[i,j]:=max(f[i,j],f[l,j-v-v[fb]-v[fa]]+v*p+v[fb]*p[fb]+v[fa]*p[fa]);49        資源問題—–化工場裝箱員50        樹形動態規劃—–聚會的快樂f[i,2]:=max(f[i,0],f[i,1]);f[i,1]:=sigma(f[t^.son,0]);f[i,0]:=sigma(f[t^.son,3]);51        樹形動態規劃—–皇宮看守f[i,2]:=max(f[i,0],f[i,1]);f[i,1]:=sigma(f[t^.son,0]);f[i,0]:=sigma(f[t^.son,3]);52        遞推天地—–盒子與球f[i,1]:=1;f[i,j]:=j*(f[i-1,j-1]+f[i-1,j]);53        雙重動態規劃—–有限的基因序列f:=min{f[j]+1}g[c,i,j]:=(g[a,i,j] and g[b,i,j]) or (g[c,i,j])54        最大子矩陣問題—–居住空間            f[i,j,k]:=min(min(min(f[i-1,j,k],f[i,j-1,k]),                         min(f[i,j,k-1],f[i-1,j-1,k])),                                min(min(f[i-1,j,k-1],f[i,j-1,k-1]),                                f[i-1,j-1,k-1]))+1;55        線性動態規劃——日程安排f:=max{f[j]}+P[I]; (e[j]<s)56        遞推天地——組合數C[I,j]:=C[i-1,j]+C[I-1,j-1]C[I,0]:=157        樹形動態規劃—–有向樹k中值問題F[I,r,k]:=max{max{f[l,I,j]+f[r,I,k-j-1]},f[f[l,r,j]+f[r,r,k-j]+w[I,r]]}58        樹形動態規劃—–CTSC 2001選課F[I,j]:=w(if i∈P)+f[l,k]+f[r,m-k](0≤k≤m)(if l<>0)59        線性動態規劃—–多重曆史f[i,j]:=sigma{f[i-k,j-1]}(if checked)60        背包問題(+-1背包問題+回溯)—–CEOI1998 Substractf[i,j]:=f[i-1,j-a] or f[i-1,j+a]61        線性動態規劃(字符串)—–NOI 2000 古城之謎f[i,1,1]:=min{f[i+length(s),2,1], f[i+length(s),1,1]+1}f[i,1,2]:=min{f[i+length(s),1,2]+words[s],f[i+length(s),1,2]+words[s]}62        線性動態規劃—–最少單詞個數f[i,j]:=max{f[I,j],f[u-1,j-1]+l}63        線型動態規劃—–APIO2007 數據備份狀態壓縮＋剪掉每個階段j前j*2個狀態和j*2+200後的狀態貪心動態規劃f:=min(g[i-2]+s,f[i-1]);64        樹形動態規劃—–APIO2007 風鈴f:=f[l]+f[r]+{1 (if c[l]<c[r])}g:=1(d[l]<>d[r]) 0(d[l]=d[r])g[l]=g[r]=1 then Halt;65        地圖動態規劃—–NOI 2005 adv19910F[t,i,j]:=max{f[t-1,i-dx[d[[t]],j-dy[d[k]]]+1],f[t-1,i,j];66        地圖動態規劃—–優化的NOI 2005 adv19910F[k,i,j]:=max{f[k-1,i,p]+1} j-b[k]<=p<=j;67        目標動態規劃—–CEOI98 subtraF[I,j]:=f[I-1,j+a] or f[i-1,j-a]68        目標動態規劃—– Vijos 1037搭建雙塔問題F[value,delta]:=g[value+a,delta+a] or g[value,delta-a]69        樹形動態規劃—–有線電視網f[i,p]:=max(f[i,p],f[i,p-q]+f[j,q]-map[i,j])           leaves>=p>=l, 1<=q<=p;70        地圖動態規劃—–vijos某題F[I,j]:=min(f[i-1,j-1],f[I,j-1],f[i-1,j]);71        最大子矩陣問題—–最大字段和問題f:=max(f[i-1]+b,b); f[1]:=b[1]72        最大子矩陣問題—–最大子立方體問題枚舉一組邊i的起始，壓縮進矩陣 B[I,j]+=a[x,I,j]枚舉另外一組邊的其實，做最大子矩陣73        括號序列—–線型動態規劃f[I,j]:=min(f[I,j],f[i+1,j-1](ss[j]=”()”or(”[]”)),f[I+1,j+1]+1 (s[j]=”(”or”[” ] , f[I,j-1]+1(s[j]=”)”or”]” )74        棋盤切割—–線型動態規劃f[k,x1,y1,x2,y2]=min{min{f[k-1,x1,y1,a,y2]+s[a+1,y1,x2,y2],f[k-1,a+1,y1,x2,y2]+s[x1,y1,a,y2]min{}}75        概率動態規劃—–聰聰和可可(NOI2005)x:=p[p[i,j],j]f[I,j]:=(f[x,b[j,k]]+f[x,j])/(l[j]+1)+1f[I,i]=0f[x,j]=176        概率動態規劃—–血緣關系F[A, B]=(f[A0, B]+P[A1, B])/2f[I,i]=1f[I,j]=0(I,j無相同基因)77        線性動態規劃—–決鬥F[I,j]=(f[I,j] and f[k,j]) and (e[I,k] or e[j,k]),i<k<j78        線性動態規劃—–舞蹈家F[x,y,k]=min(f[a[k],y,k+1]+w[x,a[k]],f[x,a[k],k+1]+w[y,a[k]])79        線性動態規劃—–積木游戲F[I,a,b,k]=max(f[I,a+1,b,k],f[i+1,a+1,a+1,k’],f[I,a+1,a+1,k’])80        樹形動態規劃（雙次記錄）—–NOI2003 逃學的小孩樸素的話枚舉節點i和離其最遠的兩個節點 j,k O(n^2)每個節點記錄最大的兩個值，並記錄這最大值分別是從哪個相鄰節點傳過來的。當遍曆到某個孩子節點的時候，只需檢查最大值是否是從該孩子節點傳遞來的。如果是，就取次大，否則取最大值81        樹形動態規劃(完全二叉樹)—–NOI2006 網絡收費F[I,j,k]表示在點i所管轄的所有用戶中，有j個用戶為A，在I的每個祖先u上，如果N[a]>N則標0否則標1，用二進制狀態壓縮進k中，在這種情況下的最小花費F[I,j,k]:=min{f[l,u,k and (s<<(i-1))]+w1,f[r,j-u,k and(s<<(i-1))]}82        樹形動態規劃—–IOI2005 河流F:=max83        記憶化搜索—–Vijos某題,忘了F[pre,h,m]:=sigma{SDP(I,h+1,M+i)} (pre<=i<=M＋1)84        狀態壓縮動態規劃—–APIO 2007 動物園f[I,k]:=f[i-1,k and not (1<<4)] + NewAddVal85        樹形動態規劃—–訪問術館f[i,j-c×2]:= max ( f[l,k], f[r,j-c×2-k] )86        字符串動態規劃—–Ural 1002 Phoneif exist(copy(s,j,i-j)) then f:=min(f,f[j]+1);87        多進程動態規劃—–CEOI 2005 serviceMin( f[i,j,k], f[i-1,j,k] + c[t[i-1],t] )Min( f[i,t[i-1],k], f[i-1,j,k] + c[j,t] )Min( f[i,j,t[i-1]], f[i-1,j,k] + c[k,t] )88        多進程動態規劃—–Vijos1143 三取方格數max(f[i,j,k,l],f[i-1,j-R[m,1],k-R[m,2],l-R[m,3]]);if (j=k) and (k=l) then inc(f[i,j,k,l],a[j,i-j]) elseif (j=k) then inc(f[i,j,k,l],a[j,i-j]+a[l,i-l]) elseif (k=l) then inc(f[i,j,k,l],a[j,i-j]+a[k,i-k]) elseif (j=l) then inc(f[i,j,k,l],a[j,i-j]+a[k,i-k]) elseinc(f[i,j,k,l],a[j,i-j]+a[k,i-k]+a[l,i-l]);89        線型動態規劃—–IOI 2000 郵局問題f[i,j]:=min(f[I,j],f[k,j-1]+d[k+1,i]);90        線型動態規劃—–Vijos 1198 最佳課題選擇if j-k>=0 then Min(f[i,j],f[i-1,j-k]+time(i,k));91        背包問題—– USACO Raucous Rockers多個背包，不可以重複放物品，但放物品的順序有限制。           F[I,j,k]表示決策到第i個物品、第j個背包，此背包花費了k的空間。f[I,j,k]:=max(f[I-1,j,k],f[I-1,j,k-t]+p,f[i-1,j-1,maxtime-t])92        多進程動態規劃—–巡游加拿大（IOI95、USACO）d[i,j]=max{d[k,j]+1(a[k,i] & j<k<i),d[j,k]+1(a[I,j] & (k<j))}。f[i,j]表示從起點出發，一個人到達i，另一個人到達j時經過的城市數。d[i,j]=d[j,i]，所以我們限制i>j分析狀態(i,j)，它可能是(k,j)(j<k<i)中k到達i得到（方式1），也可能是(j,k)(k<j)中k超過j到達i得到（方式2）。但它不能是(i,k)(k<j)中k到達j得到，因為這樣可能會出現重複路徑。即使不會出現重複路徑，那麼它由(j,k)通過方式2同樣可以得到，所以不會遺漏解時間複雜度O(n3)93        動態規劃—–ZOJ cheesef[i,j]:=f[i-kk*zl[u,1],j-kk*zl[u,2]]+a[i-kk*zl[u,1],j-kk*zl[u,2]]94        動態規劃—–NOI 2004 berry 線性F[I,1]:=sF[I,j]:=max{min{s-s[l-1]},f[l-1,j-1]} (2≤j≤k, j≤l≤i)95        動態規劃—–NOI 2004 berry 完全無向圖F[I,j]:=f[i-1,j] or (j≥w) and (f[i-1,j-w])96        動態規劃—–石子合並 四邊形不等式優化m[i,j]=max{m[i+1,j], m[i,j-1]}+t[i,j] 97        動態規劃—–CEOI 2005 service（k≥long，i≥1）g[i, j, k]=max{g[i-1,j,k-long]+1，g[i-1,j,k]}（k<long，i≥1） g[i, j, k]=max{g[i-1,j-1,t-long]+1，g[i-1,j,k]}(0≤j≤m， 0≤k<t) g[0,j,k]=0;ans:=g[n,m,0]。狀態優化：g[i, j]=min{g[i-1,j]，g[i-1,j-1]+long}其中(a, b)+long=(a’, b’)的計算方法為：當b+long ≤t時： a’=a;       b’=b+long;當b+long ＞t時： a’=a+1;   b’=long;規劃的邊界條件：當0≤i≤n時，g[i,0]=(0,0)98        動態規劃—–AHOI 2006寶庫通道f[k]:=max{f[k-1]+x[k,j]-x[k,i-1], x[k,j]-x[k,i-1]}99        動態規劃—–TravelA) 費用最少的旅行計劃。設f表示從起點到第i個旅店住宿一天的最小費用；g表示從起點到第i個旅店住宿一天，在滿足最小費用的前提下所需要的最少天數。那麼：f=f[x]+v,    g=g[x]+1x滿足：1、        x<i，且d – d[x] <= 800（一天的最大行程）。2、        對於所有的t < i, d – d[t] <= 800，都必須滿足：A. g[x] < g[t](f[x] = f[t]時)     B. f[x] < f[t] (其他情況)f[0] = 0，g[0] = 0。 Ans:=f[n + 1]，g[n+1]。B). 天數最少的旅行計劃。方法其實和第一問十分類似。設g’表示從起點到第i個旅店住宿一天的最少天數；f’表示從起點到第i個旅店住宿一天，在滿足最小天數前提下所需要的最少費用。那麼：g’ = g’[x] + 1,    f’ = f’[x] + vx滿足：1、        x<i，且d – d[x] <= 800（一天的最大行程）。2、        對於所有的t < i, d – d[t] <= 800，都必須滿足：f’[x] < f’[t]       g’[x] = g’[t]時g’[x] < g’[t]        其他情況f’[0] = 0，g’[0] = 0。 Ans:=f’[n + 1]，g’[n+1]。100        動態規劃—–NOI 2007 cashy:=f[j]/(a[j]*c[j]+b[j]);g:=c[j]*y*a+y*b;f:=max(f,g)



 



Comments
















Sign in|Recent Site Activity|Report Abuse|Print Page|Powered By Google Sites






















 





8-1 Introduction to Dynamic Programming (動態規劃)













8-1 Introduction to Dynamic Programming (動態規劃)



[english][all](請註意：中文版本並未隨英文版本同步更新！)

Slides
「動態規劃」（Dynamic Programming，簡稱 DP）是一個很有效的方法來求得一個問題的最佳解，DP 的精神是來自於 Richard Bellman 所提出的 Principle of Optimality：



An optimal policy has the property that whatever the initial state and the initial decisions are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the first decision.

簡單地說，就是在一條最佳路徑上，其中任一條子路徑（Partial Path）也都必須是相關子問題的最佳路徑，否則原路徑就不是最佳路徑。這是一個很明顯的道理，可以很直覺地使用矛盾法來加以證明，可是在實際應用上面，可以有許多複雜的變形。


To employ the procedure of DP to solve a problem, usually we need to specify the following items:

Define the optimum-value function.
Derive the recursive formula for the optimum-value function, together with its initial condition.
Specify the answer of the problem in term of the optimum-value function.

舉例來說，以下列的圖形為例：





假設：

每一條連結（Link）代表一條公路，連結上的數字則代表通過此公路所需的時間。我們使用 p(a, b) 來代表通過連接 Node a 和 Node b 的公路所需的時間。
每一個節點（Node）代表一個城市，節點上的數字則代表通過此程式所需的時間。我們使用 q(a) 來代表通過 Node a 所需的時間。

假設起點是 Start，終點是 Node 7，請問我們如何找到一條路徑，使得從起點到終點所花的時間最短？這是一個很典型的 DP 問題，我們可以經由下列三個步驟來迅速地解決這個問題：



First of all, we can define the optimum-value function t(h) as the minimum time from the start point to node h (including the time for passing node h).
Secondly, the optimum-value function should satisfy the following recursive formula:

t(h) = min{t(a)+p(a,h), t(b)+p(b,h), t(c)+p(c,h)} + q(h)

在上述方程式中，我們假設連接到 Node h 的節點有三個，分別是 a, b, c。示意圖如下：






And the initial condition is t(0)=0 where 0 is the start node.

And finally, the answer to the original problem should be t(7). By using the recursion, we can have the following steps for computing the time required by the optimum path:

t(0) = 0
t(1) = t(0)+4+5 = 9
t(2) = t(0)+2+4 = 6
t(3) = t(0)+3+1 = 4
t(4) = min(9+3, 6+2)+2 = 10
t(5) = min(6+5, 4+1)+4 = 9
t(6) = min(6+5, 4+8)+6 = 17
t(7) = min(10+1, 9+3, 17+3)+1 = 12

The value of the optimum-value function is shown as the red number in each node in the following figure:




Hint你可以點選上圖以開啟新視窗，然後就可以使用滑鼠點選新視窗，看到 DP 逐步計算的結果。

The above formulation of DP is usually referred to as the forward DP. On the other hand, we can define the formula for backward DP in a similar manner:

Firstly, the optimum-value function s(h) is defined as the minimum time from a node h to the end node (including the time for passing the end node but excluding the time for passing node h.)
Secondly, the optimum-value function should satisfy the following recursive formula:

s(h) = q(h) + min{p(h,a)+s(a), p(h,b)+s(b), p(h,c)+s(c)}

where a, b, c are the fan-out of node h. The initial condition is s(7) = q(7).
Finally, the answer to the original problem is s(0). By using the recursion, we can have the following steps for computing the time required by the optimum path:

s(7) = 1
s(6) = q(6)+3+s(7) = 6+3+1 = 10
s(5) = q(5)+3+s(7) = 4+3+1 = 8
s(4) = q(4)+1+s(7) = 2+1+1 = 4
s(3) = q(3)+min{1+s(5), 8+s(6)} = 1 + min{9, 18} = 10
s(2) = q(2)+min{2+s(4), 5+s(5), 5+s(6)} = 4 + min{6, 13, 15} = 10
s(1) = q(1)+3+s(4) = 5 + 3 + 4 = 12
s(0) = min{4+s(1), 2+s(2), 3+s(3)} = min(16, 12, 13} = 12

The answer obtained from backward DP is the same as that of the forward DP.

換句話說，在我們計算 DP 的過程中，可以反覆利用先前所計算出來的結果，而省掉許多不必要的運算。DP 的特性，可列出如下：

在計算 DP 的過程中，必須在每個節點記錄最佳路徑的來源，才能在走到終點後，經由回溯（Back Tracking）來找到整個過程的最佳路徑。
若要尋求第二最佳路徑，則必須使用較複雜的 Top-N 計算方法，而不能只靠上述簡單的 DP 算法。



Data Clustering and Pattern Recognition (資料分群與樣式辨認)







            DP -動態規劃-華人百科                     DP    動態規劃  更多義項 ▼ 收起更多 ▲    Digital Projection公司停泊蛋白動力定位付款交單死亡先知動態規劃口袋妖怪鑽石/珍珠國際文憑組織的高中階段資料處理雙精度型浮點數PROFIBUS標準新興面料加拿大吟唱詩人長度單位(設備獨立像素)學英語節目（DailyPronunciation）雙人遊戲單人操作雙人遊戲個體識別率聚合度developing people描述性編程Digital PlaygroundDP接口      動態規劃(dynamic programming)是運籌學的一個分支，是求解決策過程(decision process)最最佳化的數學方法。20世紀50年代初美國數學家R.E.Bellman等人在研究多階段決策過程(multistep decision process)的最佳化問題時，提出了著名的最最佳化原理(principle of optimality)，把多階段過程轉化為一系列單階段問題，利用各階段之間的關系，逐個求解，創立瞭解決這類過程最佳化問題的新方法--動態規劃。1957年出版了他的名著Dynamic Programming，這是該領域的第一本著作。      基本信息20世紀50年代初美國數學家R.E.Bellman等人在研究多階段決策過程(multistep decision process)的最佳化問題時，提出了著名的最最佳化原理(principle of optimality)，把多階段過程轉化為一系列單階段問題，利用各階段之間的關系，逐個求解，創立瞭解決這類過程最佳化問題的新方法——動態規劃。1957年出版了他的名著Dynamic Programming，這是該領域的第一本著作。 Dynamic Programming  詳細介紹動態規劃問世以來，在經濟管理、生產調度、工程技術和最優控製等方面得到了廣泛的套用。例如最短路線、庫存管理、資源分配、設備更新、排序、裝載等問題，用動態規劃方法比用其它方法求解更為方便。雖然動態規劃主要用於求解以時間劃分階段的動態過程的最佳化問題，但是一些與時間無關的靜態規劃(如線性規劃、非線性規劃)，隻要人為地引進時間因素，把它視為多階段決策過程，也可以用動態規劃方法方便地求解。 動態規劃程式設計是對解最最佳化問題的一種途徑、一種方法，而不是一種特殊演算法。不象前面所述的那些搜尋或數值計算那樣，具有一個標準的數學表達式和明確清晰的解題方法。動態規劃程式設計往往是針對一種最最佳化問題，由於各種問題的性質不同，確定最優解的條件也互不相同，因而動態規劃的設計方法對不同的問題，有各具特色的解題方法，而不存在一種萬能的動態規劃演算法，可以解決各類最最佳化問題。因此讀者在學習時，除了要對基本概念和方法正確理解外，必須具體問題具體分析處理，以豐富的想象力去建立模型，用創造性的技巧去求解。我們也可以通過對若幹有代表性的問題的動態規劃演算法進行分析、討論，逐漸學會並掌握這一設計方法。如果一類活動過程可以分為若幹個互相聯系的階段，在每一個階段都需作出決策(採取措施)，一個階段的決策確定以後，常常影響到下一個階段的決策，從而就完全確定了一個過程的活動路線，則稱它為多階段決策問題。各個階段的決策構成一個決策序列，稱為一個策略。每一個階段都有若幹個決策可供選擇，因而就有許多策略供我們選取，對應於一個策略可以確定活動的效果，這個效果可以用數量來確定。策略不同，效果也不同，多階段決策問題，就是要在可以選擇的那些策略中間，選取一個最優策略，使在預定的標準下達到最好的效果. 階段介紹把所給求解問題的過程恰當地分成若幹個相互聯系的階段，以便於求解，過程不同，階段數就可能不同．描述階段的變數稱為階段變數。在多數情況下，階段變數是離散的，用k表示。此外，也有階段變數是連續的情形。如果過程可以在任何時刻作出決策，且在任意兩個不同的時刻之間允許有無窮多個決策時，階段變數就是連續的。 狀態介紹狀態表示每個階段開始面臨的自然狀況或客觀條件，它不以人們的主觀意志為轉移，也稱為不可控因素。在上面的例子中狀態就是某階段的出發位置，它既是該階段某路的起點，同時又是前一階段某支路的終點。過程的狀態通常可以用一個或一組數來描述，稱為狀態變數。一般，狀態是離散的，但有時為了方便也將狀態取成連續的。當然，在現實生活中，由於變數形式的限製，所有的狀態都是離散的，但從分析的觀點，有時將狀態作為連續的處理將會有很大的好處。此外，狀態可以有多個分量(多維情形)，因而用向量來代表；而且在每個階段的狀態維數可以不同。當過程按所有可能不同的方式發展時，過程各段的狀態變數將在某一確定的範圍內取值。狀態變數取值的集合稱為狀態集合。 其他資料我們要求狀態具有下麵的性質：如果給定某一階段的狀態，則在這一階段以後過程的發展不受這階段以前各段狀態的影響，所有各階段都確定時，整個過程也就確定了。換句話說，過程的每一次實現可以用一個狀態序列表示，在前面的例子中每階段的狀態是該線路的始點，確定了這些點的序列，整個線路也就完全確定。從某一階段以後的線路開始，當這段的始點給定時，不受以前線路（所通過的點）的影響。狀態的這個性質意味著過程的歷史隻能通過當前的狀態去影響它的未來的發展，這個性質稱為無後效性。一個階段的狀態給定以後，從該狀態演變到下一階段某個狀態的一種選擇（行動）稱為決策。在最優控製中，也稱為控製。在許多問題中，決策可以自然而然地表示為一個數或一組數。不同的決策對應著不同的數值。描述決策的變數稱決策變數，因狀態滿足無後效性，故在每個階段選擇決策時隻需考慮當前的狀態而無須考慮過程的歷史。決策變數的範圍稱為允許決策集合。由每個階段的決策組成的序列稱為策略。對於每一個實際的多階段決策過程，可供選取的策略有一定的範圍限製，這個範圍稱為允許策略集合。允許策略集合中達到最優效果的策略稱為最優策略。給定k階段狀態變數x(k)的值後，如果這一階段的決策變數一經確定，第k+1階段的狀態變數x(k+1)也就完全確定，即x(k+1)的值隨x(k)和第k階段的決策u(k)的值變化而變化，那麽可以把這一關系看成(x(k)，u(k))與x(k+1)確定的對應關系，用x(k+1)=Tk(x(k),u(k))表示。這是從k階段到k+1階段的狀態轉移規律，稱為狀態轉移方程。最最佳化原理:作為整個過程的最優策略，它滿足：相對前面決策所形成的狀態而言，餘下的子策略必然構成“最優子策略”。一個問題滿足最最佳化原理也稱其擁有最優子結構性質。最最佳化原理實際上是要求問題的最優策略的子策略也是最優。        相關搜尋   dpi     dps     大鵬     丁佩     鬥破蒼穹     鄧樸方     毒品     dpph     單片機     戴佩妮           DP -動態規劃@ 華人百科  勵志人生 國語字典辭典 詩詞大全 小語 腦筋急轉彎    