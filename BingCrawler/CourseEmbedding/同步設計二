




課程大綱










同步設計(二)CONCURRENT DESIGN(2)






開課系所 Department/Institute:  工設所          Industrial Design
開課教師 Instructor:   蕭世文 Hsiao, Shih-Wen               ;謝孟達 Shieh, Meng-Dar               
開課學年 Academic Year:   0102
開課學期 Semester:    2
開課序號 Serial Number:   024

課程屬性碼 Attribute Code:   ID  6123 
課程碼 Course Number:   P356500 
分班碼 Class Code: 
學分數 No. of Credits:           3
課程語言 Medium of Instruction:   中文


課程網址 Course Website: 

先修課程或先備能力 Prerequisite Course(s):   同步設計（一）      

教師聯絡資訊 Contact with Teacher
  	    蕭世文老師   swhsiao@mail.ncku.edu.tw
謝孟達老師  mdshieh@mail.ncku.edu.tw
       

助教資訊 Contact with Tutor


學習規範 Course Policy


評量方式 Grading


方法百分比%

個人口頭報告 Presentations
20個人書面報告 Projects
20作業 Assignments
30小組報告 Group Projects
30




教學方法 Teaching Strategies
      本教學活動透過個別及分組實作，以實用及創意設計為主，將同步設計之觀念帶入產品設計中。    

		※請遵守智慧財產權觀念  不得不法影印
		 Please follow the Intellectual Property instruction and No illegal copy
	

課程教材 Course Material
	    lecture note    

參考書目 References


備註 Remarks





基本素養 Basic Literacy
■ 人文素養
 
■ 公民素養
 
□ 社會關懷
 
■ 國際視野
 
 

核心能力 Competence
□ 培養「整合設計」、「策略設計企劃」、「程序設計」以及「通用設計」等專業能力。
 
□ 培養學生具有以人類行為之角度去探討產品、介面與互動等相關研究之能力
 
■ 培養學生運用電腦輔助設計及其相關理論之能力
 
□ 培養感性工學理論之研究能力
 
 

課程概述 Course Description
       以降低整體設計過程中所需耗費的人力、時間與物力為主要研究目標，藉以提高設計的競爭力，在產業發展的過程中，能夠佔有一席之地。 

課程學習目標 Course Objectives    
	    Let students understand the significant part of the concurrent design method, which the individual engineer is given much more involvement in the overall design process due to the collaborative nature of concurrent engineering.    

課程進度 Course Outline


週次 Week進度說明 Progress Description
1Introduction2Cross-functional teams3Problem definition4Team discussion5Concurrent product realization6Design thinking method7Think aloud method8Design various subsystems simultaneously9Midterm Project10Incremental information sharing11Information shared and integrated into the design12Table prototyping13First Prototyping14Integrated project management15Team management16Second Prototyping17Final Prototyping18Final Project presentation 

　以上每週進度教師可依上課情況做適度調整。The schedule may be subject to change.


課程學習融入下列議題或具有下列內涵的程度 Immersing the Following Issues or Contents
議題或內容 Issues or Contents關聯性 Correlation觀光旅遊產業 Tourism
無相關 No correlation綠色能源產業 Green Energy Industry
間接相關 Indirect correlation文創產業 Cultural and creative Industry
間接相關 Indirect correlation環境保護 Environmental Protection
間接相關 Indirect correlation人權教育 Human Rights Education
間接相關 Indirect correlation服務學習 Service Learning
無相關 No correlation性別平等 Gender Equity
無相關 No correlation法治教育 Law-Related Education
無相關 No correlation工作實務取向 Pragmatic Orientation
直接相關 Direct correlation生命教育 Life Education
無相關 No correlation智慧財產權 Intellectual Property
直接相關 Direct correlation環境安全 Environmental Safety
間接相關 Indirect correlation健康醫療照護產業 Health,Medical Treatment, Nursing Industry
直接相關 Direct correlation精緻農業產業 Advanced Agriculture
無相關 No correlation生物科技產業 Biotechnology Industry
間接相關 Indirect correlation學術研究取向 Academic Orientation
間接相關 Indirect correlation 

有關課程其他調查 Other Surveys of Courses
                   1.本課程是否規劃業界教師參與教學或演講?   是，約 1 次            
Is there any industry specialist invited in this course? How many times? Yes, about 1 times.
			
           2.本課程是否規劃內含校外實習 (並非參訪)?   否		   
Is there any in (out of) school practicum involved in this course? How many hours?  No









挑戰類比大廠　擎力強推同步整流控制IC - 熱門新聞 - 新電子科技雜誌 Micro-electronics



















 







會員登入
|
註冊會員
|
加入粉絲團
|
設成首頁
|
加入我的最愛
|
前往新通訊
2017年07月21日星期五





 



        熱門關鍵字：機器視覺 | 穿戴式 | 工業4.0 | IoT 



















 

首頁

追新聞

懂市場

學技術

查圖表

探商情

瘋研討

找廠商

訂雜誌

白皮書

影音專區

 









會員



紅利點數



收藏文章



訂閱電子報















登入








訂閱電子報

立刻輸入Email，獲取最新的資訊：

訂閱












首頁 》熱門新聞 》文章內容





收藏功能：



分享報新知：






其他功能：








挑戰類比大廠　擎力強推同步整流控制IC

文‧黃耀瑋 發布日期：2012/05/11

關鍵字：蕭特基二極體．擎力科技．CCM．DCM．同步整流控制IC．MOSFET．PWM．能源之星



                                    節能設計當道，讓同步整流控制IC需求看漲。瞄準此一發展契機，台灣類比IC新秀擎力，遂鎖定交流對直流(AC-DC)應用，研發二次側同步整流控制IC，取代傳統蕭特基二極體(Schottky Diode)，可提升電源供應器2～4%的轉換效率，期在大廠環伺的類比IC市場中，搶占一席之地。



擎力科技總經理譚永禾指出，改用同步整流控制IC不僅提升可轉換效率，還能縮小電源供應器的體積，實現輕薄化設計。



擎力科技總經理譚永禾表示，雲端風潮興起促使各種AC-DC電源供應器，更加重視電源轉換效率，以節省設備用電。不僅帶動高效率電源管理IC需求，更讓台灣電源IC設計新秀，能與國際大廠站在同一起跑點上，分食市場大餅。

其中，尤以同步整流控制IC最受矚目，儘管該元件技術門檻較高，但對改善AC-DC電源供應器效率助益良多，包括可促進系統微型化、降低運作溫度，並提高單位功率密度。目前，包括恩智浦(NXP)、安森美(ON Semiconductor)及意法半導體(ST)等國際大廠皆已有產品推出，而擎力則是台灣類比IC業者中，較早投入發展的先驅。

譚永禾透露，擎力握有四項關於同步整流控制IC設計的專利，包括預測開關時機、同步支援連續導通模式(CCM)與非連續導通模式(DCM)、雜訊偵查和導通延遲時間調整技術等。藉由專利技術，擎力不但擁有獨特的產品競爭力，更可針對各家電源供應器廠商設計需求，打造客製化的解決方案，逐步擴大市場滲透率。

不僅如此，擎力也成為南港IC設計育成中心的輔導廠商，藉由共用中心內的電子設計自動化(EDA)工具，減少軟體採購經費，進而降低晶片研發成本，並加快產品上市時程。

據瞭解，目前臺灣一線電源供應器大廠均已採納擎力的解決方案。為滿足不同客戶需求，擎力亦與世界先進、茂矽等晶圓代工廠密切配合，以爭取足夠的晶圓產能，讓客製化晶片供貨無虞。譚永禾不諱言，擎力也已接獲韓國、中國大陸，甚至是以色列電源供應器開發商的合作邀約，可望開拓全球市場版圖。

譚永禾也提到，雖然導入同步整流控制IC將拉高物料清單(BOM)成本1～2美元，但由於節能設計要求日益嚴苛，因此電源供應器業者仍願意採納此一方案，以提升設備電源轉換效率。

以往在切換式電源供應器輸出整流部分，均採用蕭特基二極體，但受制元件先天物理特性限制，當電壓導通後會產生0.3伏特(V)的壓降，整體電源轉換效率將難以通過能源之星(Energy Star)金牌等級認證，遑論更高階的白金、鈦金等級標準，因而導致電源供應器價值大打折扣，影響系統整合商採購意願。因此，譚永禾認為，同步整流控制IC將加速取代蕭特基二極體，成為AC-DC電源管理晶片市場新寵。
                                





若要留言，請登入會員，謝謝！ 






相關文章


ROHM以全新製程縮小SBD體積
ROHM小型蕭特基二極體具超低VF值
挑戰國際大廠　台類比IC新秀輩出
使用高壓蕭特基二極體　汽車電子模組不再意外燒毀
LTC二極體控制器提供負向輸入保護/低電流操作











研討會專區


近期研討會
精彩回顧














主題式電子報





                        穿戴式裝置特輯                    



                        傳輸介面特輯                    















下載白皮書





                        《工業4.0實戰寶典》特刊網路精選版                    



                        2017年量測儀器產業特輯                    



(立即下載 好禮等你來拿)掌握最新連網汽車技術測試解決方案                    



                        2017年智慧城市產業關鍵報告                    






熱門文章


熱門點擊
編輯推薦








 



RSS訂閱
|
關於新電子
|
About Microelectronics
|
廣告委刊
|
聯絡編輯部
|
聯絡發行部
|
隱私權政策

城邦文化事業股份有限公司版權所有、轉載必究．Copyright(c) 2016 Cite Publishing Ltd.
 



































[入門] .Net 非同步處理與同步機制全解析 (二) | .Net 2Share - 點部落


























.Net 2Share
.NET 2Share @ 點部落










2014-04-02
   

[入門] .Net 非同步處理與同步機制全解析 (二)

3259


0

.Net Programming


檢舉文章



                                
2014-11-10
   
                            




這一篇入門教學距離上一篇([入門] .Net 非同步處理與同步機制全解析 (一))已經有足足三年多的時間。之所以延宕那麼久, 主要是因為微軟已經開始提供平行處理及非同步機制的功能更新; 許多功能及用法不停地出現, 連我自己都搞不清楚, 所以我也沒辦法繼續著手這一系列文章。直到 .Net Framework 4.5 開始, 我覺得應該可以算是一個適當時機, 可以繼續來寫這個系列文章了...


	這一篇入門教學距離上一篇([入門] .Net 非同步處理與同步機制全解析 (一))已經有足足三年多的時間。之所以延宕那麼久, 主要是因為微軟已經開始提供平行處理及非同步機制的功能更新; 許多功能及用法不停地出現, 連我自己都搞不清楚, 所以我也沒辦法繼續著手這一系列文章。

	直到 .Net Framework 4.5 開始, 我覺得應該可以算是一個適當時機, 可以繼續來寫這個系列文章了。在這個版本中, .Net Framework 加入了 Async/Await 指令, 可以大幅大簡化非同步程式設計。因此, 我認為本篇可以使用比以前更簡短的方式來撰寫。因為它實在太簡單了!

	範例

	以下我舉個例子。假設我們寫了一個 Windows Form 程式, 裡面有一道指令會載入其它網頁的資料; 因為載入資料的動作耗時較久, 我要在開始載入資料之前顯示一個訊息, 讓使用者知道動作已在進行中。在以下程式中, 我使用 Thread.Sleep(5000) 來代表這些耗時的指令:

// 程式一
private void btnLoadEvent_Click(object sender, EventArgs e)
{
    lbStatus.Text = "資料載入中, 請稍候... ";
    load();
}
private void load() 
{ 
    Thread.Sleep(5000);
    lbStatus.Text = "資料已載入。";
}

	如果光從程式邏輯看, 以上程式絕不可能有任何問題, 跟非同步也沒有關係。但是當你執行程式之後, 怪事發生了。不管你執行幾次, 你只會看到「資料已載入。」這道訊息, 而「資料載入中, 請稍候...」這道訊息則是從來未曾出現。

	這是為什麼呢? 這是因為上面那三行程式都在同一個 UI thread 上面, 而 Windows Form 會在 UI thread 上的指令執行完畢並且返回之後, 才會觸發它的 Paint 事件。同樣的程式, 如果你把 lbStatus.Text = 改成 Console.WriteLine, 在 Console 程式中這個問題就不會發生, 因為 Console 程式沒有像 Windows Form 那種 Paint 事件。

	到了這邊, 這個問題就必須以非同步方式進行處理。

	在 .Net Framework 4.5 之後引進的 Async/Await 指令可以很輕易地讓我們寫出非同步的程式。寫法也相當簡單, 把原來的程式改寫如下就行了:

// 程式二
private async void btnLoadEvent_Click(object sender, EventArgs e)
{
    lbStatus.Text = "資料載入中, 請稍候... ";
    await load();
}
private async Task load() 
{ 
    Thread.Sleep(5000);
    lbStatus.Text = "資料已載入。";
}

	請留意上述程式的寫法。要把原來的程式改寫成非同步程式, 請註意包括 btnLoadEvent_Click 方法和 load() 方法都已經加上了 async 修飾詞, 同時 load() 的型別從 void 改成了 Task。被呼叫的非同步方法都必須傳回 Task 或 Task<T> 型別, 或者 void (Sub)。如果方法原本沒有回傳值 (就像本例中的 load()), 那麼把型別改成 Task 即可; 如果它原來有回傳值, 例如 int, 那麼就把它改成 Task<int>。

	此外, 請註意呼叫 load() 時必須加上 await 指令。這個 await 指令會取用緊跟在後的 Task 或 Task<T> 物件; 這就是為什麼你在非同步方法中必須把回傳型別指定為 Task 或是 Task<T>。在上例中, 如果你不嫌麻煩的話, 也可以這樣寫, 意思是一樣的:

Task task = load();
await task;

	有時候非同步方法回傳的型別不能是 Task, 也不能是 Task<T>, 那麼你就只能指定為 void, 就像程式範例中的 btnLoadEvent_Click() 方法。在什麼情況下程式只能宣告為 void 呢? 其實還蠻常見的, 像 btnLoadEvent_Click() 這種 Event Handler, 就不能回傳 Task 或 Task<T>, 一定只能為 void, 因為它必須符合 EventHandler 這個 delegate 所訂的規格。所以我們可以合理推斷, 應用程式在呼叫 btnLoadEvent_Click() 方法時, 鐵定沒有冠以 await 指令。

	將回傳型別宣告為 void 的非同步方法還是可以呼叫的, 只要前面不冠以 await 即可。當然, 如此它也不會以非同步方式執行就是了。在本文的範疇中, 我們不會遇到必須指定 void 為回傳型別的情況, 所以以下我們都會使用 Task 或 Task<T>。

	不過, 或許你會註意到, 若依程式二的寫法, 在 Visual Studio 會顯示一個 compiler warning, 但是程式仍然可以執行。結果, 當程式一執行, 「資料載入中, 請稍候...」這道訊息仍然不會出現。換句話說, 你以為你已經把程式改成非同步了, 實際上它並未以非同步方式執行。這時候, 你應該可以體會出剛才看到的 compiler warning 是什麼意思了。



	問題在哪裡呢? 請記得 async/await 必須是成對出現的。所以我們可以在 btnLoadEvent_Click() 方法中找到 async 和 await, 在 load() 方法裡面, 則找不到任何 await 關鍵字, 也找不到任何隱含執行 await 指令的指令。Thread.Sleep(5000); 指令只是一道普通的指令而已, .Net 找不到它有任何非同步執行的跡象, 所以就把它當作同步程式了。連帶的, 上述程式中所有指令都以同步方式執行了。這就是為什麼你會看到那個 compiler warning 的原因, 也是為什麼程式並未以我們預期的方式執行的原因。

	類似的錯誤, 你未來可能還是會反覆看到。所以每當你看到那一道 compiler warning 時, 千萬別把它忽略掉, 否則程式就不會以非同步方式執行。

	那麼, 我們應該如何把它改成正確的形式呢? 我先來介紹一種最簡單、最偷懶, 但是並不正規的方法。

	在很多時候, 你或許就是沒辦法把原來的程式改成非同步, 或許你只是跟我一樣, 單純地想讓「資料載入中, 請稍候...」顯示出來而已。我們可以用一種非常沒學問的方式辦到這一點, 如以下程式所示:

// 程式三
private async void btnLoadEvent_Click(object sender, EventArgs e)
{
    lbStatus.Text = "資料載入中, 請稍候... ";
    await load();
}
private async Task load() 
{ 
    await Task.Delay(5000);
    lbStatus.Text = "資料已載入。";
}

	維持程式二的既有架構, 只要把 Thread.Sleep() 指令改成 Task.Delay() 指令(以及那一道 await 指令), 就可以讓 load() 變成一個真正的非同步方法。現在你就可以看到「資料載入中, 請稍候...」這道訊息了!

	不過, 如果你的腦筋動得快的話, 你或許會想起來我前面明明說我只是使用 Thread.Sleep(5000) 來代表那些耗時的指令罷了; 實際上我們會執行的指令絕不可能是 Sleep() 或者 Delay() 指令。

	沒錯! 如果你真正要執行的並不是 Sleep() 指令, 那麼你也可以從投機取巧地在你的程式裡加上 

await Task.Delay(20);

	這道指令。這樣會讓你的程式犧牲 20 毫秒的執行時間, 但是這卻是讓你的 load() 方法立即變成非同步方法的最快方式。所以我剛才說這個是偷懶的方法。

	不過, 現在我們回頭來談談正經事吧! 如果要使用「正規」的方式修改這個程式, 我們可以使用 Task.Run() 方法:

//程式四 
private async void btnLoadEvent_Click(object sender, EventArgs e)
{
    lbStatus.Text = "資料載入中, 請稍候... ";
    await Task.Run(() => { load(); });
    lbStatus.Text = "資料已載入。";
}
private void load() 
{ 
    Thread.Sleep(5000);
}

	在這個程式中, 我們使用 Task.Run() 指令並傳入一個匿名函式以執行 load() 指令, 如此就可以了。這也是原來那個 Compiler Warning 提示我們採用的方法。請特別註意, 若採用這種作法, 我們不需要把 load() 方法改成 async 方法; 所以採用這種方式, 也能夠很快地把舊程式改成非同步方式執行。

	不過, 你應該已經發現到, 我把顯示「資料已載入。」字樣的指令搬到了 btnLoadEvent_Click() 方法中。這是因為 Task.Run() 方法事實上就像我在前一篇文章所介紹的 Thread 功能一樣, 發出去的執行緒並不能取得 UI 執行緒中物件的控制權。因此你沒辦法在另一個執行緒上面存取 lbStatus 物件。

	接下來, 我們來看看「最正式」的非同步寫法。其實 Task.Run 也算是正式的寫法, 但是我們可以在許多介紹文章中看到它們多半介紹的是以下這一種。基本上這種寫法我在上面已經介紹過了 (即第二個程式), 但是我們在那個程式中看到一個 compiler warning, 實際執行時也無法看到效果。所以, 以下我就不再使用 Thread.Sleep() 來取代真正的程式, 我將改寫程式, 讓它取出一個外部網站上的 JSON 檔案:

// 程式五
private async void btnLoadEvent_Click(object sender, EventArgs e)
{
    lbStatus.Text = "資料載入中, 請稍候... ";
    string content = await loadAsync();
}
private async Task<string><string> loadAsync() 
{ 
    using (WebClient webClient = new WebClient())
    {
        string json = await webClient.DownloadStringTaskAsync(
                "http://api.openweathermap.org/data/2.5/weather?q=Taipei,tw");
        lbStatus.Text = "資料已載入。";
        return json;
    }
}

	在這裡, 當我們要載入網頁資料時, 就不能使用 webClient.DownloadString() 方法, 而必須改用 await webClient.DownloadStringTaskAsync() 方法, 而這也是那個 compiler warning 訊息中指出的真正意義。

	此外, 我們也應該遵從 .Net 建議的命名規範, 所以我把 load() 改名成 loadAsync()。依照命名規範, 非同步方法應該在名稱後面加上 Async, 這樣才容易辨識。.Net 有提供了很多相同功能方法, 其中非同步的版本都會在原來的名稱之後加上 Async; 前面提到的 DownloadString / DownloadStringTaskAsync 就是其中一例。

	但是有一點需要特別註意: 如果我們把程式改成非同步方法, 它就再也不能支援以 ref 和 out 修飾的參數。所以, 如果你原有的同步方法支援 ref 或 out 參數, 你就不能直接把它改成非同步方法。你可以考慮修改你的程式邏輯, 或者改用上面介紹過的 Task.Run() 方法。

	再補充一點, 把 lbStatus.Text = "資料已載入。"; 這一行寫在 loadAsync() 方法中並不是很好的做法, 這會讓這個方法相依於 UI。我這樣寫只是為了示範這種做法在技術上辦得到而已, 實際上你應該把這一行移到 btnLoadEvent_Click() 方法裡去 (接在 await 那一行的下麵)。

	Async/Await的規則與限制

	當我們要使用 Async/Await 關鍵字時, 有幾個規則與限制, 不可不知:


		我們不能在 catch 和 finally 區段中使用 await 關鍵字。

		我們不能在建構函式和屬性的 getter/setter 中使用 async/await。

		在標示為 async 的非同步方法中不能採用 ref 或者 out 參數。

		我們不能在 lock 區段中使用 await 關鍵字


	由於有這些限制, 所以當我們未來在設計程式時, 或許應該先考慮使用非同步執行的可能性。如果需要, 可以同時設計同步和非同步的版本, 如此才能讓這兩個版本的呼叫方式盡量相似。而不是先設計了同步的程式, 再去修改成非同步。

	此外, 從 .Net 4.5 開始, .Net Framework 程式庫中已經把多數常用的需要耗時較久的功能加上 Async 版本, 包括網路傳輸和檔案傳輸等等。所以你應該盡量採用這些 Async 版本(如程式五)。只有在找不到 Async 版本或者你有自己撰寫的某些耗時的功能時(例如大量且反覆的數學運算), 才需要以 Task.Run 方式予以呼叫(如程式四)。

	增進效率的技巧

	我在前一篇文章中介紹過平行運算的做法。但是如果透過 Async/Await 指令, 我們也可以簡單地辦到平行運算。現在假設在一個 Windows Form 程式中, 我打算把三個網路上擷取的圖片載入三個 PictureBox 控制項, 那麼, 透過上面介紹過的方法, 我的程式如下:

// 程式六
pb1.Image = await GetImageAsync("http://img1");
pb2.Image = await GetImageAsync("http://img1");
pb3.Image = await GetImageAsync("http://img1");

	在這裡 GetImageAsync 是我寫的非同步方法。

	依照這種寫法, 由於每一行都要等待 await 指令得到結果之後, 程式流程才會往下跑, 所以雖然已使用非同步方法, 基本上這種做法能夠獲得的好處十分有限。

	但是如果把上述程式稍為改一下, 我們就可以獲得兩倍的效率。以下我同時把兩種做法列出來:

// 程式七
private async void btnLoad_Click(object sender, EventArgs e)
{
    lbStatus.Text = "資料載入中, 請稍候... ";

    Stopwatch sw = new Stopwatch();
    sw.Start();

    // Method 1 - the traditional way
    pb1.Image = await GetImageAsync("http://img1");
    pb2.Image = await GetImageAsync("http://img1");
    pb3.Image = await GetImageAsync("http://img1");

    // Method 2 - using await to make the loadings run simutaneously
    //Task<Image> task1 = GetImageAsync("http://img1");
    //Task<Image> task2 = GetImageAsync("http://img1");
    //Task<Image> task3 = GetImageAsync("http://img1");
    //pb1.Image = await task1;
    //pb2.Image = await task2;
    //pb3.Image = await task3;

    // Method 3 - using Task.WhenAll to await all tasks. This doesn't improve much
    //Task<Image> task1 = GetImageAsync("http://img1");
    //Task<Image> task2 = GetImageAsync("http://img1");
    //Task<Image> task3 = GetImageAsync("http://img1");
    //await Task.WhenAll(task1, task2, task3);
    //pb1.Image = task1.Result;
    //pb2.Image = task2.Result;
    //pb3.Image = task3.Result;

    sw.Stop();
    TimeSpan ts = sw.Elapsed;
    lbStatus.Text = string.Format("資料已載入。耗時 {0:0.000} 秒。", ts.TotalSeconds);
}
private async Task<Image> GetImageAsync(string url)
{
    WebClient client = new WebClient();
    byte[] imageData = await client.DownloadDataTaskAsync(url);
    return Image.FromStream(new MemoryStream(imageData));
}

	在上述程式中, 我把三種做法都列了出來。第一種做法就是程式六的做法, 第二種做法則是程式六的變形, 第三種做法則是另一種變形。

	如同第二種做法, 如果我們不去 await 非同步程式, 而去 await 那個 Task, 那麼這三個 Task 就不再依照它們在程式中列出的順序, 而是同時執行。而執行的結果就如預期, 足足比第一種做法快了一倍!

	第三種做法則是加上了一個 Task.WhenAll 指令, 它會整合參數中的所有 Task (即範例中的 task1, task2 和 task3), 讓我們只需 await 一個 Task。不過實務上這第三種做法在效率上並不能討到任何便宜; 經我實測多次, 它的效率比第二種做法略差一點。

	此外, 若採用第三種做法, 你絕對不能省略 Task.WhenAll 指令, 否則程式會因為 UI 被鎖定而從此停止回應。這是因為 UI 緒行道在等待非同步的結果, 而 Task.Result 又在等待 UI 釋放所導致的死結。你必須把所有會執行到 Task.Result 的 Task 物件放進 Task.WhenAll 裡面集中看管, 才不會導致這個死結的發生。

	要執行程式七, 請開啟一個 Windows Form 專案, 在 Form 裡拉一個 Button (btnLoadEvent), 一個 Label (lbStatus) 和三個 PictureBox (pb1, pb2, pb3)。把 Method 2 或 Mehod 3 的指令的註解拿掉就可以測試那一段。

	不過, 提醒大家, 我在最近的案子裡, 發現如果在 Windows Form 應用程式裡用到 Task.WhenAll 指令 (上述第三種做法), Task 數量一次不能超過 100 個。我寫了一個 非同步新增資料到 SQL 資料庫中的方法, 如果採用第三種做法把多筆資料寫入, 那麼從第 101 筆開始, 就會把這個應用程式凍住, 甚至無法關閉。但是, 同樣的做法、同樣的程式, 在 Unit Test 裡倒是一點問題也沒有; 即使幾萬筆資料都可能順利跑完。

	目前我還不瞭解真正的原因為何。但是如果你也遇到這個問題, 或許你可以避開第三種做法, 改用第一或第二種做法。

	參考資料:


Asynchronous Programming in C# - Advanced Topics

		MSDN: 使用 Async 和 Await 設計非同步程式 (C# 和 Visual Basic)

Best Practices in Asynchronous Programming


繼續閱讀: 


[入門] .Net 非同步處理與同步機制全解析 (一)

[入門] .Net 非同步處理與同步機制全解析 (二)

[入門] .Net 非同步處理與同步機制全解析 (三)


 

.NET 2Share @ 點部落





Parallel
Async
Await




迴首頁














 





廣告 







標籤雲






系列文章






贊助商連結





最新留言















Please enable JavaScript to view the comments powered by Disqus.






Verilog基本電路設計：同步、切換、 異步FIFO、去抖 - 每日頭條每日頭條Verilog基本電路設計：同步、切換、 異步FIFO、去抖2016-09-08 由 EETOP 發表於 資訊
作者：傑克淡定
原文：http://bbs.eetop.cn/thread-605419-1-1.html
Verilog基本電路設計
共包括四部分：


單bit跨時鐘域


同步時鐘無縫切換


異步FIFO


去抖濾波


...
Verilog基本電路設計之一: 單bit跨時鐘域同步
（帖子連結：bbs.eetop.cn/thread-605419-1-1.html）
看到罈子里不少朋友，對於基本數字電路存在這樣那樣的疑惑，本人決定開貼，介紹數字電路最常見的模塊單元，希望給初學者帶來幫助，也歡迎大佬們前來拍磚。如果想要做數字設計，下麵這些電路是一定會碰到的，也是所有大型IP，SOC設計必不可少的基礎，主要包括異步信號的同步處理，同步FIFO，異步FIFO，時鐘無縫切換，信號濾波debounce等等，後面會根據大家反饋情況再介紹新電路。ADVERTISEMENT
首先介紹異步信號的跨時鐘域同步問題。一般分為單bit的控制信號同步，以及多bit的數據信號同步。多bit的信號同步會使用異步FIFO完成，而單bit的信號同步，又是時鐘無縫切換電路以及異步FIFO電路的設計基礎，這裡先介紹單bit信號同步處理。

clka域下的信號signal_a，向異步的clkb域傳遞時，會產生亞穩態問題。所有的亞穩態，歸根結底就是setup/hold時間不滿足導致。在同一個時鐘域下的信號，綜合以及布線工具可以在data路徑或者clock路徑上插入buffer使得每一個DFF的setup/hold時間都滿足；但是當signal_a在clkb域下使用時，由於clka與clkb異步，它們的相位關係不確定，那麼在clkb的時鐘沿到來時，無法確定signal_a此時是否處於穩定無變化狀態，也即setup/hold時間無法確定，從而產生亞穩態。這種異步信號在前後端流程裡面是無法做時序分析的，也就是靜態時序分析里常說的false_path。ADVERTISEMENT
消除亞穩態，就是採用多級DFF來採樣來自另一個時鐘域的信號，級數越多，同步過來的信號越穩定。對於頻率很高的設計，建議至少用三級DFF，而兩級DFF同步則是所有異步信號處理的最基本要求。

單bit的信號跨時鐘域同步，又分成電平信號同步以及脈衝信號同步。電平信號，就是說clka下的信號signal_a在clkb看來，是一個很寬的信號，會保持多個clkb的時鐘周期，一定能被clkb採到。這種情況，只需要使用clkb用至少兩級DFF連續抓signal_a即可，特別需要強調的是，此時signal_a必須是clka下的寄存器信號，如果signal_a是clka下的組合邏輯信號，一定要先在clka下用DFF抓一拍，再使用兩級DFF向clkb傳遞。這是因為clka下的組合邏輯信號會有毛刺，在clka下使用時會由setup/hold時間保證毛刺不會被clka採到，但由於異步相位不確定，組合邏輯的毛刺卻極有可能被clkb採到。電平信號的同步處理，一般用於知道確定的時鐘頻率大小關係或者極慢時鐘下的信號向極快時鐘域傳遞時使用，簡單處理如下：ADVERTISEMENT
always @ (posedge clkb or negedge rst_n)begin
if (!rst_n) begin
levl_b_d1 <= #DLY 1'b0;
levl_b_d2 <= #DLY 1'b0;
levl_b_d3 <= #DLY 1'b0;
end
else begin
levl_b_d1 <= #DLY levl_a_in;
levl_b_d2 <= #DLY levl_b_d1;
levl_b_d3 <= #DLY levl_b_d2;
endend
assign puls_b_pos = levl_b_d2 & (~levl_b_d3);
assign puls_b_neg = levl_b_d3 & (~levl_b_d2);
assign levl_b_out = levl_b_d2;

上面三個輸出分別是經過同步之後，clkb下可以使用的0變1脈衝信號，1變0脈衝信號以及電平信號。再次強調：levl_a_in必須是clka的DFF信號！下麵是更常見的，clka下的脈衝信號，同步到clkb時鐘域下，它對於clka與clkb的時鐘頻率關係沒有任何限制，快到慢，慢到快都沒問題。其主要原理就是先把脈衝信號在clka下展寬，變成電平信號，再向clkb傳遞，當確認clkb已經「看見」信號同步過去之後，再清掉clka下的電平信號。脈衝信號同步處理電路，有兩個地方使用了上面的電平信號同步處理原則，請仔細揣摩原因。詳細見下麵的RTL，其中省略了信號定義聲明：ADVERTISEMENT
module sync_pulse (
// input
rst_n, // system reset
clka, // clockA
clkb, // clockB
puls_a_in, // pulse input from clka
// output
puls_b_out, // pulse output in clkb
levl_b_out // level output in clkb
);
parameter DLY = 1; //
always @ (posedge clka or negedge rst_n)
begin
if (rst_n == 1'b0)
signal_a <= # DLY 1'b0 ;
else if (puls_a_in)
signal_a <= # DLY 1'b1 ;
else if (signal_b1_a2)
signal_a <= # DLY 1'b0 ;
else ;
end
always @ (posedge clkb or negedge rst_n)
begin
if (rst_n == 1'b0)
signal_b <= # DLY 1'b0 ;
else
signal_b <= # DLY signal_a ;
end
always @ (posedge clkb or negedge rst_n)
begin
if (rst_n == 1'b0) begin
signal_b_b1 <= # DLY 1'b0 ;
signal_b_b2 <= # DLY 1'b0 ;
end
else begin
signal_b_b1 <= # DLY signal_b ;
signal_b_b2 <= # DLY signal_b_b1 ;
end
end
always @ (posedge clka or negedge rst_n)
begin
if (rst_n == 1'b0) begin
signal_b1_a1 <= # DLY 1'b0 ;
signal_b1_a2 <= # DLY 1'b0 ;
end
else begin
signal_b1_a1 <= # DLY signal_b_b1 ;
signal_b1_a2 <= # DLY signal_b1_a1 ;
end
end
assign puls_b_out = signal_b_b1 & (~signal_b_b2) ;
assign levl_b_out = signal_b_b1 ;
endmodule
下一篇講時鐘切換電路。
留下一個思考題：clka下的同一個寄存器信號signal_a，電平寬度對clkb而言足夠長，如果同時調用兩個相同的電平同步模塊向clkb時鐘傳遞，分別得到levl_b1和levl_b2，那麼在clkb時鐘域下看到的lev_b1和levl_b2信號是否一樣？
這個問題是實際設計中一不小心就會犯錯的，如果能夠想明白正確回答這個問題，異步信號的理解就可以過關了。
Verilog基本電路設計之二： 時鐘無縫切換
（帖子連結：http://bbs.eetop.cn/thread-605514-1-1.html）
時鐘切換分成兩種方式，普通切換和去毛刺無縫切換。
普通切換，就是不關心切出的時鐘是否存在毛刺，這種方式電路成本小。如果時鐘切換時，使用此時鐘的模塊電路處於非工作狀態，或者模塊內電路被全局復位信號reset住的，即使切出毛刺也不會導致DFF誤觸發，這樣的模塊可以選擇用此種切換方式。
寫法很簡單 assign clk_o = sel_clkb ? clkb : clka ,當sel_clkb為1時選擇clkb，否則選擇clka。不過在實際設計中，建議直接調用庫里的MUX單元set_dont_touch，不要採用這裡的assign寫法，因為這種寫法最後綜合得到的可能不是MUX而是複雜組合邏輯，給前後端流程的時鐘約束和分析帶來不便。

無縫切換，就是切換時無毛刺時鐘平穩過渡。在時鐘切換中，只要出現比clka或者clkb頻率更高的窄脈衝，不論是窄的高電平還是窄的低電平，都叫時鐘毛刺。工作在切換後時鐘clk_o下的電路模塊，綜合約束是在max{clka,clkb}頻率下的，也就是說設計最後signoff的時候，只保證電路可以穩定工作的最高頻率是max{clka,clkb},如果切換中出現更高頻的時鐘毛刺，電路可能出現無法預知的結果而出錯。無縫切換，一般用在處於工作狀態的模塊需要調頻或者切換時鐘源，比如內部系統總線，CPU等。你剛用手機打完遊戲後馬上關屏聽音樂，這兩種場景中，CPU在滿足性能前提下為了控制功耗，其工作頻率會動態地從很高調至較低，此時就可能是在CPU一直處於工作狀態下，通過無縫切換時鐘源頭實現的。

在無縫切換電路中，切換信號sel_clkb可以是任意時鐘域下的信號，包括但不限於clka或者clkb域，但是sel_clkb必須是一個DFF輸出信號；clka與clkb的頻率大小相位關係可以任意。無縫切換需要解決兩個問題，一是異步切換信號的跨時鐘域同步問題，這裡需要使用《Verilog基本電路設計之一》里的同步電路原理消除亞穩態；二是同步好了的切換信號與時鐘信號如何做邏輯，才能實現無毛刺。
下麵寫出無縫切換電路的主體部分，忽略了內部信號的定義聲明等。
module clk_switch (
rst_n,
clka,
clkb,
sel_clkb,
clk_o
);
always @ (posedge clka or negedge rst_n)
begin
if (!rst_n) begin
sel_clka_d0 <= 1'b0;
sel_clka_d1 <= 1'b0;
end
else begin
sel_clka_d0 <= (~sel_clkb) & (~sel_clkb_dly3) ;
sel_clka_d1 <= sel_clka_d0 ;
end
end
// part2
//always @ (posedge clka_n or negedge rst_n)
always @ (posedge clka or negedge rst_n)
begin
if (!rst_n) begin
sel_clka_dly1 <= 1'b0;
sel_clka_dly2 <= 1'b0;
sel_clka_dly3 <= 1'b0;
end
else begin
sel_clka_dly1 <= sel_clka_d1;
sel_clka_dly2 <= sel_clka_dly1 ;
sel_clka_dly3 <= sel_clka_dly2 ;
end
end
// part3
//always @ (posedge clkb_n or negedge rst_n)
always @ (posedge clkb or negedge rst_n)
begin
if (!rst_n) begin
sel_clkb_d0 <= 1'b0;
sel_clkb_d1 <= 1'b0;
end
else begin
sel_clkb_d0 <= sel_clkb & (~sel_clka_dly3) ;
sel_clkb_d1 <= sel_clkb_d0 ;
end
end
// part4
//always @ (posedge clkb_n or negedge rst_n)
always @ (posedge clkb or negedge rst_n)
begin
if (!rst_n) begin
sel_clkb_dly1 <= 1'b0;
sel_clkb_dly2 <= 1'b0;
sel_clkb_dly3 <= 1'b0;
end
else begin
sel_clkb_dly1 <= sel_clkb_d1 ;
sel_clkb_dly2 <= sel_clkb_dly1 ;
sel_clkb_dly3 <= sel_clkb_dly2 ;
end
end
// part5
clk_gate_xxx clk_gate_a ( .CP(clka), .EN(sel_clka_dly3), .Q(clka_g) .TE(1'b0) );
clk_gate_xxx clk_gate_b ( .CP(clkb), .EN(sel_clkb_dly3), .Q(clkb_g) .TE(1'b0) );
//assign clka_g = clka & sel_clka_dly3 ;
//assign clkb_g = clkb & sel_clkb_dly3 ;
assign clk_o = clka_g | clkb_g ;
endmodule
上面是我認為比較合理的無縫切換電路，其他切換方式跟這個會有些許出入，但基本大同小異原理是一樣的。有幾點說明：
1、拋開註釋掉的電路不看，由於part5部分直接調用庫里的clock gating cell，使得整個切換電路全部只需要用到時鐘上升沿，無需額外定義反向時鐘，精簡了DC綜合的時鐘約束；直接調用gating cell的 另一個好處是，前後端工具會自動檢查gating
cell的CP信號與EN信號的setup/hold時間，使得gating後的Q時鐘輸出無毛刺尖峰。TE端可以根據實際需要接上scan測試模式信號。如果使用part5部分的gating cell實現，前面的part1,2,3,4全部替換成註釋掉的反相時鐘也是沒有問題。

2、part2和part4部分，具體需要多少級DFF，甚至完全不要也是可以的，這就回到了《Verilog基本電路設計之一》里討論的到底多少級DFF消除亞穩態才算合理的問題。時鐘頻率很低可能無所謂，如果時鐘頻率達到GHz，這部分建議至少保留三級DFF，因為三級DFF延時也僅僅只有3ns的時間裕度。沒必要為了省這麼幾個DFF降低電路可靠性，在複雜IP以及大型SOC系統中，你會發現多幾十個DFF，面積上可以忽略，系統可靠性和穩定性才是首要的。
3、如果part5部分希望使用註釋掉的兩行「與」邏輯實現時鐘gating，此時part1與part3使用正相或者反相時鐘都可以，但是必須把part2和part4部分改為註釋掉的反相時鐘實現，目的是初步從RTL設計上避免「與」邏輯的毛刺，同時還需要後端配合，因為很多後端工具對時鐘「與」邏輯的clock gating
check未必會檢查。用clk下降沿拍出的en信號，再跟clk做與邏輯得到的門控時鐘，在RTL仿真階段看到的一定不會有毛刺，但是布線完成後，如果clk相對en後移，那與邏輯得到的門控時鐘就有毛刺了。這就是用與邏輯做門控的缺點，由於後端工具可能不會去檢查這個與門的時序關係而導致出錯。但直接調用庫里的gating cell，工具天然就會去檢查這個時序，免去人工確認的後顧之憂。
最後，請大家仔細看看sel_clka_d0 <= (~sel_clkb) & (~sel_clkb_dly3) 和sel_clkb_d0 <= sel_clkb & (~sel_clka_dly3)
這兩處邏輯，按理說，sel_clkb跟sel_clka_dly3以及sel_clkb_dly3之間相互都是異步的，而按照異步信號同步處理原則，兩個不同時鐘域下的信號是不允許直接做組合邏輯的，為什麼這裡可以這樣使用？
Verilog基本電路設計之三： 異步FIFO
（帖子連結：http://bbs.eetop.cn/thread-605632-1-1.html）
FIFO用於為匹配讀寫速度而設置的數據緩衝buffer，當讀寫時鐘異步時，就是異步FIFO。多bit的數據信號，並不是直接從寫時鐘域同步到讀時鐘域的，而是讀寫時鐘域分別派遣了一個信使，去通知對方時鐘域，當前本方所處的讀寫情況，來判斷還能不能寫以及可不可以讀，這兩個信使就是讀寫指針。

在《Verilog基本電路設計之一》里已討論過，即使單bit的異步信號，通過兩個相同的同步電路，達到clkb域時都可能「長」的不是一個模樣，更加不用說多bit的異步信號同時傳遞到clkb域會變成什麼五花八門的模樣了。這裡讀寫指針不是單bit信號，它們如何向對方時鐘域去同步呢？格雷碼！它的特點是每次只有一個bit發生變化，這樣就把多bit信號同步轉變為了單bit信號同步，這也是為什麼多bit的格雷碼信號，可以類似於單bit信號那樣，直接使用兩級DFF去同步的根本原因。
下麵給出異步FIFO的主體部分，同樣，省略了信號聲明定義。
module asyn_fifo (
// input
af_wclk , // async-FIFO clear in write clock
af_rclk , // async-FIFO clear in read clock
rst_n, // system reset
af_wr_en, // async-FIFO write enable
af_rd_en, // async-FIFO read enable
af_dati, // async-FIFO data in
//output
af_full , // Async-FIFO full flag
af_empty, // Async-FIFO empty flag
af_dato // Async-FIFO data out
);
//------------------------- data input --------------------------
assign nxt_wptr_wclk = (af_wr_en && !af_full) ? (wptr_wclk + 1'b1) : wptr_wclk ;
assign nxt_wptr_gray = (nxt_wptr_wclk >> 1) ^ nxt_wptr_wclk ;
always @ (posedge af_wclk or negedge rst_n)
begin
if (rst_n == 1'b0) begin
wptr_wclk <= # DLY 5'b0 ;
wptr_gray <= # DLY 5'b0 ;
end
else begin
wptr_wclk <= # DLY nxt_wptr_wclk ;
wptr_gray <= # DLY nxt_wptr_gray ;
end
end
reg [31:0] ram[15:0] ; //
always @ (posedge af_wclk)
begin
if (af_wr_en == 1'b1)
ram[wptr_wclk[3:0]] <= # DLY af_dati ;
else ;
end
//------------------------ data output ---------------------------
assign nxt_rptr_rclk = (af_rd_en && !af_empty) ? (rptr_rclk + 1'b1) : rptr_rclk ;
assign nxt_rptr_gray = (nxt_rptr_rclk >> 1) ^ nxt_rptr_rclk ;
always @ (posedge af_rclk or negedge rst_n)
begin
if (rst_n == 1'b0) begin
rptr_rclk <= # DLY 5'b0 ;
rptr_gray <= # DLY 5'b0 ;
end
else begin
rptr_rclk <= # DLY nxt_rptr_rclk ;
rptr_gray <= # DLY nxt_rptr_gray ;
end
end
assign af_dato = ram[rptr_rclk[3:0]] ;
// sync read pointer
always @ (posedge af_wclk or negedge rst_n)
begin
if (rst_n == 1'b0) begin
rptr_sp1 <= # DLY 5'b0 ;
rptr_sp2 <= # DLY 5'b0 ;
end
else begin
rptr_sp1 <= # DLY rptr_gray ;
rptr_sp2 <= # DLY rptr_sp1 ;
end
end
// sync write pointer
always @ (posedge af_rclk or negedge rst_n)
begin
if (rst_n == 1'b0) begin
wptr_sp1 <= # DLY 5'b0 ;
wptr_sp2 <= # DLY 5'b0 ;
end
else begin
wptr_sp1 <= # DLY wptr_gray ;
wptr_sp2 <= # DLY wptr_sp1 ;
end
end
assign af_full = (wptr_gray == {~rptr_sp2[4],~rptr_sp2[3],rptr_sp2[2:0]}) ;
assign af_empty = (rptr_gray == wptr_sp2) ;
assign wptr_bin[4] = wptr_sp2[4] ;
assign wptr_bin[3] = (^wptr_sp2[4:3]) ;
assign wptr_bin[2] = (^wptr_sp2[4:2]) ;
assign wptr_bin[1] = (^wptr_sp2[4:1]) ;
assign wptr_bin[0] = (^wptr_sp2[4:0]) ;
assign rptr_bin[4] = rptr_sp2[4] ;
assign rptr_bin[3] = (^rptr_sp2[4:3]) ;
assign rptr_bin[2] = (^rptr_sp2[4:2]) ;
assign rptr_bin[1] = (^rptr_sp2[4:1]) ;
assign rptr_bin[0] = (^rptr_sp2[4:0]) ;
assign af_wlevel = wptr_wclk - rptr_bin ;
assign af_rlevel = wptr_bin - rptr_rclk ;
assign af_half_full = (af_rlevel >= 5'h7) ;
endmodule
上面給出的是深度16，寬度32的示例，大家可以使用parameter參數化定義深度和寬度，方便不同需求下的調用。除了空滿信號標誌，也可以根據需要做出半空半滿之類信號。上面需要註意的一點就是，格雷碼必須在本時鐘域下DFF輸出，再往另一個時鐘域同步。同步FIFO呢，就不用有格雷碼轉換，設計更加簡單，就不專門開貼描述了。
...
Verilog基本電路設計之四： 去抖濾波
（帖子連結：http://bbs.eetop.cn/thread-605729-1-1.html）
debounce電路，就是常說的去抖濾波，主要用在晶片的PAD輸入信號，或者模擬電路輸出給數字電路的信號上。
parameter BIT_NUM = 4 ;
reg [BIT_NUM-1 : 0] signal_deb ; //
always @ (posedge clk or negedge rst_n)
begin
if (rst_n == 1'b0)
signal_deb <= {BIT_NUM{1'b0}} ;
else
signal_deb <= # DLY {signal_deb[BIT_NUM-2:0],signal_i} ;
end
always @ (posedge clk or negedge rst_n)
begin
if (rst_n == 1'b0)
signal_o <= 1'b1 ;
else if (signal_deb[3:1]==3'b111)
signal_o <= # DLY 1'b1 ;
else if (signal_deb[3:1]==3'b000)
signal_o <= # DLY 1'b0 ;
else ;
end
上面的電路，第一個always，還兼顧了去亞穩態作用。它可以濾掉的寬度是兩個clk的cycle，對於大於兩個cycle而小於三個cycle的信號，有些可以濾掉，有些不能濾掉，這與signal_i相對clk的相位有關。
根據希望濾除的寬度相關，換算到clk下是多少個cycle數，從而決定使用多少級DFF。如果希望濾除的寬度相對cycle數而言較大，可以先在clk下做一個計數器，產生固定間隔的脈衝，再在脈衝信號有效時使用多級DFF去抓signal_i；或者直接將clk分頻後再使用。
結束

相關文章數字電路一些常見問答2017-03-09↑ 點擊上方「電子工程專輯」輕鬆關註熟悉一下數字電路一些問題，從細節入手，溫故而知新。什麼是同步邏輯和異步邏輯，同步電路和異步電路的區別是什麼?同步邏輯是時鐘之間有固定的因果關係。異步邏輯是各時鐘之間沒有固定的因果關係。電路設計可分類為同步電路和異步電路設計。步進電機控制系統的設計及應用2015-11-26摘 要： 基於DSP的步進電機控制系統採用了閉環控制方式，同時以光電編碼器反饋檢測信號以及專用大功率驅動晶片THB6064H的應用不僅簡化了系統外圍硬體電路結構，而且增強了系統的可靠性和抗乾擾能力，並根據工程實際中出現的問題進行分析並且提出了具體解決措施。基於FPGA的CPCI總線多功能通信卡的設計2015-12-30摘 要： 為了提高航空航天領域對信號處理、傳輸的實時性及可靠性，以Cyclone III系列EP3C40F324I7為核心處理器，設計了一種基於CPCI總線的多功能通信卡。結合高效的FPGA算法，設計出一款實時性強、可靠性高的多功能通信卡。CIS掃描的實現2017-06-26要驅動CIS實現圖像掃描，硬體需要具備為CIS提供控制信號的主控制模塊、具備接收處理CIS原始輸出信號的模擬前端以及傳送掃描圖像到PC機的高速接口。數字IC設計工程師筆試面試經典100題2017-04-141：什麼是同步邏輯和異步邏輯？同步邏輯是時鐘之間有固定的因果關係。異步邏輯是各時鐘之間沒有固定的因果關係。同步時序邏輯電路的特點：各觸發器的時鐘端全部連接在一起，並接在系統時鐘端，只有當時鐘脈衝到來時，電路的狀態才能改變。基於430單片機的計程車計價器設計與實現2016-02-17摘 要： 計程車在交通出行中起到十分重要的作用，司機與消費者都迫切需要能夠科學合理地顯示計程車費用的計價器。在總結以往設計不足的基礎上，實現了基於430單片機的計程車計價器。CPU卡程序設計實例（一）2017-04-111. 硬體電路1.1. 電路框圖關於CPU卡的基礎知識及文件機制，請參閱相關文檔，這裡不再贅述。CPU卡一般與ESAM模塊（嵌入式安全控制模塊）配合使用，CPU卡的作用就不多說了。ESAM模塊一般與單片機一起焊接在電路板上。諧振器和振蕩器2016-01-25在以前，時常會把諧振器和振蕩器搞混。經歷了一些時間的對比，大概整理一下。我們習慣稱晶振，這個講法其實很模糊。這裡把有源的稱為振蕩器，無源的稱為諧振器。諧振器【RESONATOR】產生諧振頻率的電子元件，它是典型的無源器件，需要外圍電路驅動其工作，產生時鐘輸出。基於Multisim的數字鐘實驗電路的設計與仿真2015-03-07在電子技術實驗教學中，構建學生的電路設計理念，提高學生的電路設計能力，是教學的根本目的和核心內容。數字鐘電路的設計和仿真，涉及模擬電子技術、數字電子技術等多方面知識，能夠體現實驗者的理論功底和設計水平，是電子設計和仿真教學的典型案例。一種基於DSP線性掃頻信號源系統設計方案2014-08-05摘要 針對地震勘探中可控震源信號的高精度需求，提出了一種基於DSP線性掃頻信號源的系統軟硬體設計方案。該方法提高了掃頻信號源的精度和波形穩定性，減小了波形的失真，且系統工作穩定可靠，操作簡單實用，具有良好的應用前景。 Copyright © 2017 / 服務條款 / DMCA / 聯絡我們































[Excel]來設計個二螢一雲的隨身日記帳吧 | topcat 姍舞之間的極度凝聚 - 點部落






























topcat 姍舞之間的極度凝聚
世界上有兩樣東西分享給別人後，不但不會變少，還會變更多：一個是快樂，另一個是知識~分享...是知識累積的開始...










2010-04-22
   

[Excel]來設計個二螢一雲的隨身日記帳吧

20129


0

Office2010


檢舉文章



                                
2010-04-22
   
                            




養成記帳的習慣，是理財的第一部，而如果記帳如果無法隨身隨時隨地，那麼可能很容易的就會漏了、忘了、懶了，說好的幸福又怎麼會來呢??小喵就利用Excel來設計一個隨身記帳的檔案，除了可以隨身使用，並且可以透過同步，同步到小喵家中的Home Server，那麼就算是不在家，而且又忘了帶手機，也可以透過網路來取得該檔案。接著，就來看看以上的這些要望，要怎麼設計囉!!

緣起 養成記帳的習慣，是理財的第一部，而如果記帳如果無法隨身隨時隨地，那麼可能很容易的就會漏了、忘了、懶了，說好的幸福又怎麼會來呢??小喵就利用Excel來設計一個隨身記帳的檔案，除了可以隨身使用，並且可以透過同步，同步到小喵家中的Home Server，那麼就算是不在家，而且又忘了帶手機，也可以透過網路來取得該檔案。接著，就來看看以上的這些要望，要怎麼設計囉!! 設計概念 小喵設計是一個月一個檔案，而這個檔案不但可以從PC上的Excel使用與輸入，並且可以從Windows Mobile上的Excel Mobile來隨身維護，而當Windows Mobile插上電腦時，可以透過Windows Mobile 裝置中心，同步到小喵家中的Windows Home Server。就算小喵不在家裡，也忘記帶手機，小喵也可以借用任何一臺可以上Internet的電腦，透過Internet連回家中的電腦，取得該檔案進行維護。請看以下的示意圖。   設計Excel 首先針對會支出的一些分類，設計在不同的工作表上，如以下圖示      接著在每一個工作表，設計【日期、項目、金額】如下圖   然後在D1儲存格，設計公式【=SUM(C:C)】用來計算此一項目的金額合計，以下是填寫幾筆範例資料，而其他的支出類別也做一樣的設計  ←這是【食】的部分   ←這是【交通】的部分 接著，新增一個新的工作表，命名為【支出一覽】，並且將所有的支出全部整合到此工作表，並且將此工作表放在所有支出工作表之前，裡面設計的內容如下：   另外再設計一個工作表，用來記錄收入的部分   最後設計一個【收支合計總覽】，其中支出的部分，設計為【=支出一覽!C1*(-1)】   另外，為了讓以後支出類別可以新增後，節省對支出一覽的維護，小喵設計一個按鈕，並且寫點小小的VBA來自動加入支出的工作頁，這VBA的內容如下：  
    Dim y As Integer
    Dim Cnt As Integer
    Cnt = Sheets.Count
    
    Dim RIndex As Integer
    RIndex = 2
    
    For y = ActiveSheet.Index + 1 To Cnt
        Range("A" & RIndex) = Sheets(y).Name
        Range("B" & RIndex) = "=" & Sheets(y).Name & "!D1"
        RIndex = RIndex + 1
    Next
    
End Sub

最後，將支出的部分，做個圓餅圖，來顯示各項支出的比率，最後支出的部分如下圖：
 
存放Home Server上
小喵在Home Server上建立一個記帳的資料夾，然後將設計好的範本檔案放在上面，接著為每一年建立一個資料夾
然後在每個月，將範例檔複製一份到該年分的資料夾。這樣就可以在家透過家中的網路存取該月的記帳，而出外可以透過Internet下載或上傳該檔案。有關Home Server的相關資訊請參考小喵的這一篇【[WHS] Windows Home Server -- 分享回憶、確保電腦資料安全的備份利器】
設定與Windows Mobile同步
流水帳如果不能隨身紀錄的話，那麼可能到要記錄的時候，會忘記一些細項。因此小喵要把每個月的檔案，同步到小喵的Mobile手機上，這樣才能夠隨時隨地隨身的紀錄流水帳。設計步驟如下：

首先透過Windows Mobile裝置中心，先將Windows Mobile與小喵的NB做同步。 
接著透過以下各圖的設定步驟，就可以將Home Server上的檔案設定同步到Windows Mobile上了。 
  
  
開啟的視窗中，挑選Home Server上的04月檔案 
     
設定好後，按下完成，接著按下儲存，這樣Windows Mobile就可以透過Mobile Excel來維護這個資料了。 
      
就這樣簡單的設定，就可以同步Home Server上與Windows Mobile上的日記帳檔案了。 

Excel Mobile的操作
在Windows Mobile上的操作，就請參考以下的圖囉
  

   
 
總結
以上是小喵自己的二螢一雲方式的應用，透過Mobile裝置中心設定【檔案同步】來同步手機與電腦上的檔案，並且可以隨身編輯。透過Windows Home Server的幫助，可以將該檔案放到Internet中，透過Web去下載上傳該檔案，讓小喵可以再任意的地方都可以存取該檔案。這樣的應用方式，提供大家參考看看囉!!
 

以下是簽名：

歡迎轉貼本站的文章，不過請在貼文主旨上加上【轉貼】，並在文章中附上本篇的超連結與站名【topcat姍舞之間的極度凝聚】，感恩大家的配合。
小喵大部分的文章會以小喵熟悉的語言VB.NET撰寫，如果您需要C#的Code，也許您可以試著用線上的工具進行轉換，這裡提供幾個參考
	
http://converter.telerik.com/
http://www.carlosag.net/tools/codetranslator/
http://www.developerfusion.com/tools/convert/vb-to-csharp/









			Microsoft MVP 




 
 
topcat
			Blog:http://www.dotblogs.com.tw/topcat





 



迴首頁














 





系列文章






標籤雲






贊助商連結





官方網站



Ajax官方 
IT邦幫忙
JQuery
MSDN首頁
MVP Award Program
TechNet Taiwan 官方部落格
TechNet官方技術論壇





技術論壇



MSDN官方技術論壇
藍色小舖





推薦Blog



.Net Magazine國際中文版
.NET海角點部落(茂伯譙程式)
.NET菜鳥自救會(小歐)
ASP.NET 魔法學院 
DotNET開發聖殿
gipi的學習筆記-我的職場觀念、IT部落格 
Good ITea :: MS Tech Share
Hunterpo's IT Vision
In 91
maduka的技術日記
Will保哥Blog
小朱® 的技術隨手寫
格子樑 | 艾倫 郭
馬小玲的異想世界
康廷數位
強力鎯頭 の VB 部落
嵐色共享體
黃忠成-風雪之閣
黑暗執行緒
當麻許
聖哥的資訊站





語言學習



jarbus
多益啦啦隊





其他



AllenYen的部落格
PMP沒講的是
topcat攝影旅遊網誌
小小喵的成長日記(BabyHome)
舒舒的部落格
簡報實驗室





最新留言















Please enable JavaScript to view the comments powered by Disqus.








	如何自設畫面(一)-XQ官網



























功能教學
XS學院
如何購買
課程講座
技術支援
程式下載
全球贏家
 FB




產品介紹
程式下載
 FB



















如何自設畫面(一)

2016-04-14 15:38:19





當預設系統無法滿足自己看盤需求時，該怎麼辦呢？這時候，你就需要用到”自訂頁面”了！XQ操盤高手的另一項特色「自設頁面」，可以自行設定屬於你個人化的看盤畫面。在自設看盤畫面完成後，可以存檔方便日後使用，還可加入我的最愛，隨時都可輕鬆叫出頁面。本篇教學重點： 設計畫面樣式，分割欄框 設定欄框同步，使商品連動來看看怎麼自訂頁面吧！※小編貼心提醒：影片播放時，可點選影片播放器右下角的「齒輪圖示(設定)」，可切換播放畫質為1080p，以享有較佳的觀看畫質。  圖文介紹：(一)開啟新頁1.進入方式：(1) 點選主功能列中「自訂頁面」中的「開啟新頁」。(2) 您可以點選[頁面內容]中的功能項，或是由[系統式樣]中挑選一個由本系統提供的式樣。(3) 例如我們由以上[系統式樣]中，挑選[3_3]式樣後，按下「開啟」。2.自設看盤畫面：(1) 例如我們想自訂一個看盤畫面為：上方放報價組合，左下放商品走勢圖，右下放商品新聞。先以滑鼠點選上方「請設定欄框內容」，將出現「欄框設定精靈」，選取「報價組合」後按下一步。(2) 依據選定的顯示內容，可照精靈指示一步步完成設定，或直接按「完成」接受預設值。(3) 完成上方的欄框內容設定為「報價組合」。(4) 再依序設定左下欄框內容為「商品走勢圖」。以滑鼠點選左下方「請設定欄框內容」，選取「商品盤勢」後按下一步。(5) 商品盤勢的設定顯示參數內，可選擇「顯示方式」，例如只顯示上下兩格，其他各項則依步驟完成內容設定。(6) 最後設定右下欄框內容為「商品新聞」。以滑鼠點選右下方「請設定欄框內容」，選取「商品盤勢」後按下一步。(7) 商品盤勢的設定顯示參數內，選擇顯示方式為「單格」，預設相關資訊選擇「新聞」，其他各項則依步驟完成內容設定。(8) 已完成自設看盤畫面如下圖。 (二)分割及刪除欄框、欄框設定精靈1.分割欄框：如需要再切割畫面，則可利用「自訂頁面」→「分割欄框」→[水平等分]、[水平三等分]、[垂直等分]、[垂直三等分]執行。可利用此功能，任意調整您想要的看盤畫面喔！(1) 例如：我們將上例的上方視窗(先點選確認為紅色作用視窗)，以[垂直等分]再作切割。(2) 點選後，上方欄框已新增垂直分割，可再做內容設定。2.欄框設定精靈：針對已完成設定的欄框內容若需要調整，則可利用「自訂頁面」→「欄框設定精靈」執行。(1) 例如：我們調整左下的商品走勢圖，使其只出現走勢圖，無明細資料。(2) 進入「欄框設定精靈─設定商品盤勢」，在設定顯示參數內，改變顯示方式為「單格」，預設相關資訊選擇「走勢圖」，可直接點選「完成」略過其他設定。(3) 已完成修改欄框內容如下圖。3.刪除欄框：選取欲刪除的欄框(先點選確認為紅色作用視窗)，利用主功能列「自訂頁面」→「刪除欄框」即可完成刪除動作。(1) 例如：我們先將左上欄框，以「分割欄框→水平等分」再作切割。(2) 先點選確認剛才所新增的空白欄框為紅色作用視窗，執行「自訂頁面」→「刪除欄框」，便可刪除所選欄框。 (三)設定/解除同步資料設定同步欄框，是指定那些欄框要和目前的作用欄框成為同一個同步族群，也就是任一個同步族群欄框成為作用欄框時，切換商品，與其同屬同步欄框的畫面，即會同步將內容切換至新商品。解除欄框同步，則是將作用欄框從目前所屬的同步欄框中移除，恢復成獨立欄框。1.設定同步欄框：(1) 點選一個欄框成為作用欄框。例如我們先點選左上「報價組合」為作用欄位。(2) 按下[自訂頁面]中的[設定同步欄框]按鈕，會出現一個對話盒，此時滑鼠游標圖形改變，您可點選要同步的欄框，挑選完畢後按[完成]按鈕即可。我們將左上及右上欄框設成同一群組，再按下「完成」按鈕即可。(3) 您可依照需求，自行設定多個不同的同步群組，屬於同一群組的欄框，欄框顏色會一致。我們再將左下及右下欄框設成同一群組。(4) 重覆此步驟即可建立多組同步欄框。2.取消欄框同步：(1) 點選一個欄框成為作用欄框。例如我們點選右上「技術分析」為作用欄位。(2) 按下[自訂頁面]中的[解除欄框同步]按鈕，如此即完成解除動作，該作用欄框隨即恢復為獨立欄框。 (四)儲存頁面、開啟舊頁完成所有設定後，記得要儲存下來，方便往後使用。1.儲存頁面：(1) 點選主功能列中「自訂頁面」中的「儲存頁面」。(2) 若此頁面之前並未被命名，則此時會跳出一對話盒，在畫面中輸入自定的頁面名稱，也可同時指定快捷頁碼，再按[儲存]按鍵即完成；若此頁有命名，則系統會直接執行存檔動作。2.開啟舊頁：(1) 點選主功能列中「自訂頁面」中的「開啟舊頁」，您可以點選[最近使用的頁面]、[自定頁面]或[我的最愛]，從中挑選一個頁面。(2) 可選擇開啟剛才儲存的「報價01」頁面。(3) 或是直接在任何頁面上，輸入剛才同步設定的「500」快捷頁碼，也可快速開啟自定頁面。3.我的最愛：您也可將自訂頁面儲存到「我的最愛」，並加入快速鍵功能(500-999)，以方便往後能快速找到所要頁面。(1) 開啟剛才的自訂頁面「報價01」，並點選主功能列中「我的最愛」中的「加入我的最愛」。(2) 之後便能快速的由「我的最愛」選單中，快速前往自定頁面。 (五)另存新頁、另存式樣1.另存新頁：當既存頁面有任何修改，都可以另存新頁，以方便往後使用。(1) 我們將剛才建立的自訂頁面「報價01」，以分割欄框再調整畫面為如下所示。(2) 點選主功能列中「自訂頁面」→「另存新頁」，在畫面中輸入自定的頁面名稱，也可指定快捷頁碼，再按[儲存]按鍵即完成。例如我們將此頁面另儲存名稱為「報價02」，並同時指定快捷頁碼為「501」。2.另存式樣：為方便日後使用，可將辛苦設計出的版面儲存起來。(1) 點選主功能列中[自訂頁面]→[另存式樣]，輸入式樣名稱即可。(2) 之後在「開啟新頁」時，便可在[我的式樣]從中挑選。接下來要介紹自設畫面的其他技巧，我們繼續看下去囉！
                        


進階教學
如何自設畫面(二)











進階教學





如何自設畫面(一)
如何自設畫面(二)
如何自設畫面(三)
雲端策略中心
XQ策略模組
策略雷達串接下單
XQ權證模組
XQ選股模組

























 
圓領T恤 | O-niis 春 新品 東大門同步 小香風甜美個性露肩露臂設計上衣 二色 TOP 17042513可另搭配韓國連線懶人鞋 | Yahoo拍賣



















ga conf


 













首頁
超級商城
購物中心
中古車
帳務中心






Yahoo!奇摩拍賣


:::商品搜尋框

搜尋
搜尋:


















:::上方功能區塊






件商品已加入





前往購物車







        {{#if items_normal}}
            {{{merchant_name}}}
{{items_normal}}項商品
        {{/if}}
        {{#if items_nextbuy}}
            {{{merchant_name}}}
下次買清單
        {{/if}}
        

 









   拍賣  >    女裝與服飾配件  >    女裝上衣  >    T恤  >    短袖T恤  >    圓領T恤  






         
 檢舉商品   tumblr share   facebook share       8 
 {{#if isLoveIcon}}
	
		{{likeNums}}
	
{{else}}
    {{#if trackItem}}已喜愛商品{{else}}喜愛商品{{/if}}
{{/if}}
   


    直購 O-niis 春 新品 東大門同步 小香風甜美個性露肩露臂設計上衣 二色 TOP 17042513可另搭配韓國連線懶人鞋 Dears～商品預購追加是需要等候的，恕不受理急單。下標前請務必詳閱頁面內容，認同賣場規定後再下標哦    原　　價 $1,580   促　　銷  $480 /已售出 3 件          顏色  請選擇顏色    黑     白       尺寸  請選擇尺寸    S     M     L     XL       數　　量    Decrease  Increase  庫存僅剩件                  Yahoo拍賣保障 放心買!我們給你五萬交易保障!     付款方式    信用卡一次付清   Yahoo奇摩輕鬆付   、  現金付款  Yahoo奇摩輕鬆付現金接受付款方式  帳戶餘額 網路ATM 實體ATM FamiPort  ATM提供6家銀行：合作金庫、華南銀行、玉山銀行、臺灣銀行、國泰世華、中國信託，以上6家同行轉帳，免轉帳手續費。  、    、     Yahoo奇摩輕鬆付   、  （想使用貨到付款嗎？）       運　　費   宅配/貨運 - 單件運費$65、消費滿$1000免運費  （合併運送規則）  單件運費$65 滿2件，運費$75 消費滿$1000免運費    7-ELEVEN取貨付款 - 單件運費$65、消費滿$1000免運費  （合併運送規則）  單件運費$65 滿2件，運費$65 消費滿$1000免運費    全家取貨付款 - 單件運費$65、消費滿$1000免運費、APP全家免運  （合併運送規則）  單件運費$65 滿2件，運費$65 消費滿$1000免運費      商品狀況 全新品   預購出貨 付款完成後20天   所在地區   臺中市     商品編號 100347045798 
  {"242385598-488423869 242385599-488423871":{"model_id":714752277,"sale_quantity":99,"saleable":true},"242385598-488423869 242385599-488423872":{"model_id":714752278,"sale_quantity":98,"saleable":true},"242385598-488423869 242385599-488423873":{"model_id":714752279,"sale_quantity":99,"saleable":true},"242385598-488423869 242385599-488423874":{"model_id":714752280,"sale_quantity":99,"saleable":true},"242385598-488423870 242385599-488423871":{"model_id":714752281,"sale_quantity":98,"saleable":true},"242385598-488423870 242385599-488423872":{"model_id":714752282,"sale_quantity":99,"saleable":true},"242385598-488423870 242385599-488423873":{"model_id":714752283,"sale_quantity":99,"saleable":true},"242385598-488423870 242385599-488423874":{"model_id":714752284,"sale_quantity":99,"saleable":true}}  





 O-nii's 東大門韓國合作直營 代號 Y7573659144  加入最愛     正評99.95%  評價 2,049 則     關於我 商品問與答 (0) 全部商品 (491) 訂閱商品情報 每週三  適用活動    滿額 summer sale 












  賣場任意門  廣告            一元起標 MOSCHINO 女生長T   $696              棉麻輕薄襯衫外套   $450              全館滿千現折+免運~大尺碼格紋洋裝   $1,080              防曬 夏天必備超薄漸層色虎頭刺繡外套   $1,780         看更多商品>   我要曝光>   





{{title}}

            {{#each geList}}
            

                    {{#if thumbnail}}{{/if}}
                    {{desc}}

                {{#if sponsorLink}}
                    {{sponsor}}
                {{else}}
                    {{sponsor}}
                {{/if}}
            
            {{/each}}
        










     商品資訊    問與答(2)    商品資訊     商品說明似西服西褲材質，紡棉 / 無彈 /                全長            肩寬            胸圍            下擺寬            袖攏圍            袖長            袖口寬              S             58             33             89            49              15.5 吋             23                           M                                      93                                                                   L                                       97                                                                  XL                                       101                                                            單位 : 公分。"吋"會特別註明。 上列尺寸採抽樣測量。實際庫存尺碼請以下標時選項欄為主。  可能因為 測量方式 or 布料彈性 等因素，誤差值正負1~ 3 公分為合理範圍。東大門款較無法提供詳細尺寸，其碼數正常，請按平時穿著選擇即可，不便之處敬請包涵。      問與答 看更多問與答arrow  目前沒有任何問與答   comments   請先登入再進行發問    

賣家回覆

0/250


取消





 
  app migrate  熱門APP快下載 快下載拍賣APP，第一時間掌握賣家回覆，熱門商品別錯過！   立即下載 再等等  




  賣家推薦  






 



















