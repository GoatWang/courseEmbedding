




時間複雜度







時間複雜度(Time Complexity)的定義　　何謂Big-oh?　　常見的Big-oh　　何謂Ω(omega)　　何謂Θ(Theta)

時間複雜度(Time Complexity)的定義


        
        
　　            
在程式設計中，決定某程式區段的步驟計數是程式設計師在控制整體程式系統時間的重要因素，不過要決定精確的次數卻也真是一困難的工作。特別是在不確定型(如指令x=l和x=x2+x3.15/x-4)比較，雖然我們都將其視為一個指令，不過運用的複雜程度理所當然影響了真正精確的執行時間。由此得知花費很大的功夫去計算真正的執行次數是沒有意義的。所以我們往往以一種「概量」的精神來做為衡量的準則，稱為「時間複雜度」(Time complexity)。按著我們就來看它的詳細介紹:
             
　　            
我們定義一個T(n)，表示在一個完全理想狀態的計算機中程式所執行的實際指令次數。一個程式的執行時間並不完全和輸入量有關，演算法的好壞也會影響，所以我們可以把它當作輸入量為n的一種函數。又在此我們可以定義對輸入量n而言，它的最大執行時間就是時間複雜度(Time complexity)的衡量標準。通常在漸近表示法(Asymptotic Notation)中，我們一般以Big-oh來表示。             



top



何謂Big-oh?




        
        
　　O(f(n))可以看成是某一演算法在電腦中所需執行時間始終不會超過某一常數倍的f(n)。更清楚的說就是若某演算法的執行時間T(n)的時間複雜度是O(f(n))，意謂存在兩個常數c與n0，若n≧n0，則T(n)≦cf(n)。f(n)又可以稱為執行時間的成長率(rate of growth)。為了增加同學的瞭解，我們趕快來看看有關的一些例子。
             
例如，假設某些程序詳細分析後得到的結果是其運算的次數與參數n有關，如下：            
N(n)=3n2+11n-45
           
　　            
在這個多項式中會主導整個函式且成長最快的是n2項，一般而言，在一個多項式中會主導的項是具有最高次的那一項。用一個表來說明這個表示式中值的成長是n在主導的，如下的表所示。從這個表我們可以觀察到只使用n2項而不是使用整個公式時，它會隨著n變大而與正確值的誤差百分比會非常小。這主要是因為這個項的成長比其他二個項的成長還要快速，這二個項因此可以被忽略。我們可以說對於較大的n值，這個副程式基本上是一個3n2的處理程序。






        
        
例：請問下麵程式區段的迴圈部份實際執行次數及時間複雜度


        
        
[C]


         
　#include <stdio.h>          
　void main()           
　{       
　int i,j,k;          
　for (i=1; i<=n ; i++)          
　for (j=1; j<=n ; j++)           
　for (k=1; k<=n ; k++)           
　printf("%d %d %d \n",i,j,k);;;          
　}




    
    
[Visual BASIC]


   
　for i =1 to n           
　for j= i to n           
　for k=j to n           
　…       
　next k           
　next j           
　next i           



           
答：           
這個問題是希望釐清同學對有關實際執行次數和時間複雜度在表現意義上的不同。在本題有關實際執行次數的問題，同學先要清楚是指那一道指令的次數。由於這題是「迴圈」執行的部份，毋需考慮迴圈內部指令的多寡。因此我們可用數學式來計算：
           
　　這個n(n+l)(n+2)/6就是實際的迴圈執行次數，且我們知道必定存在c，n0使得n(n+l)(n+2)/6≦cn3，當n≧n0時，時間複雜度為O(n3)。       



top



常見的Big-oh


      
      
　　對於比較2個不同的時間複雜度，千萬不可以用直觀的方法來判斷。例如有2種演算法，時間複雜度各為O(n)與O(n2)。如果這2種方法的實際執行次數T'(n)=2n，T"(n)=n2，則n>2時，2n<n2，對時間複雜度而言，O(n)優於O(n2)(所謂"優於"，就是所花的時間較少)。註意！當n≦2時2n≧n2，則O(n2)優於O(n)。由上面的說明，我們可以清楚知道時間複雜度事實上只表示實際次數的一個量度的層級，並不是真實的執行次數。此外，有關目前常見的Big-oh有下列幾種情形：
      
1.O(1)或O(c)：稱為常數時間(constant time)
           
　　這表示演算法則的執行時間是一個常數倍，而忽略資料集合大小的變化。一個例子是在電腦中它存取RAM所花的時間，在記憶體中去讀取及寫入所用的時間是相同的，而不考慮整個記憶體的數量。如果有這樣的演算法則存在，則我們可以在任何大小的資料集合中自由的使用，而不需要擔心時間或運算的次數會一直成長或變得很高。
       
2. O(n)：稱為線性時間(linear time)
           
　　它執行的時間會隨資料集合的大小而線性成長。我們可以找到一個例子是在一個沒有排列過的資料集中要找一個最大元素，且我們以簡單的方式去解釋其內容，直到我們將所有的資料都找過並且找到最大值為止。
       
3.O(log2n)：稱為次線性時間(sub-linear time)
           
　　這一種函式的成長速度比線性的程序還慢，而此常數(它是不成長的)的情形還快。
       
4.O(n2)：稱為平方時間(quadratic time)
           
　　演算法則執行時間會成二次方的成長，這種會變得不切實際，特別是當資料集合的大小變得很大時。
       
5.O(n3)：稱為立方時間(cubic time)
           
6.O(2n)：稱為指數時間(exponential time)
           
7.O(n1og2n)
          
介於線性及二次方成長的中間之行為模式。          



top



何謂Ω(omega)





    
    
　　除了Big-oh可以視為計算機時間複雜度的最壞表現之外，我們還要認識所謂的Ω(omega)，它也是一種時間的漸近表示法。
      
定義：f(n)=Ω(g(n))，若且唯若存在大於0的常數c和n0，使得對所有n值而言，n≧n0時，f(n)≧cg(n)均成立。
      
換句話說，對於f(n)=Ω(g(n))而言，g(n)就可以看成是f(n)的下限，也就是對f(n)=Ω(g(n))而言，g(n)就是它成長的最大函數。      




top




何謂Θ(Theta)




    
    
　　          
另外一種在本書中將介紹的漸近表示法稱為Θ(Theta)。它和"big-oh"及"Omega"比較而言，是一種更為精確的方法。它的定義如下:
         
定義：f(n)=Θ(g(n))，若且唯若存在大於0的常數c1,c2和n0，使得對所有n值而言，n≧n0時，c1g(n)≦f(n)≦c2g(n)均成立。
         
事實上f(n)=Θ(g(n))，就是g(n)可同時代表f(n)的上限和下限。我們再以3n+2的例子說明：
         
　當n≧2時，3n+2≦4n即3n+2=O(n)      
　當n≧l時，3n+2≧3n即3n+2=Ω(n)      
　則我們就可以做成以下的結論3n+2=Θ(n)。
      
　　          
對於使用漸近式表示法來描述時間複雜度到底那一種是最佳的方法?在前面我們就指出了"big-oh"是對演算法的時間複雜度描述最常用的表示法。原因就是在漸近表示法中我們通常只關切其最大項目(leading term)的原因。           




top







Matlab 撠�撘�嚗�銴����摨�  Matlab Guide---Complexity



Matlab 撠�撘�嚗�銴����摨�

Matlab ������隞� clock 頛詨�� 1 銋� 6 ���摨����嚗�
��嗆�詨�潔��摨�隞�銵剁��撟� (镼踹��)�����������乓��������������蝘����
���鈭������舀迤��湔�賂��雿�蝘���舀築暺���詻����臭誑��� round(clock) ���敺���冽�舀�湔�詨�潛��蝑�獢����
蝑�獢����皞�蝣箸�抒�望�冽����函����餉�西��鞎穿�������� Matlab ��臬��雿�璆剔頂蝯梢��鋆∪��敺����鈭�鞈�������
��血����������拙�����隞支�����憪����蝯����蝣潸”嚗�

tic
撠�蝣潸”甇賊�嗡蒂���憪�閮�������
toc
���甇ＹⅣ銵剁��銝西撓��箔誑蝘���箏�桐��������������

隞乩����臬�拍�函Ⅳ銵其��皜祇�����隞文�瑁�����������靘�摮�嚗�

>> A=rand(100,100);
>> tic; B=inv(A); det(A)*det(B), toc
ans =
    1.0000
elapsed_time =
    0.1100

蝣潸”���閮���������������舀�函��撖西�勗�券�餉�血����Ｙ�����蝑�獢�������������
�����箏��鈭箸��雿輻�函����餉�蟲�����嚗������喳��銝���圈�餉�血�典�瑁��銝�餈唳��隞鬥�����鞎���� (loading) 銝����嚗�
��賣����Ｙ��銝�������閮����蝯�������雿���航�����撘����蝑�獢����閰脖�������寡��������



��蟲��������隞� cputime 頛詨�箄�芸�����銝�甈∪�瑁�� Matlab 隞乩��嚗�
蝮賢�曹蝙��其��憭�撠�蝘���� CPU ���������靘�憒� round(cputime/60) 
�����仿����券�����敺����憪�雿輻�� Matlab ��啁�桀����箸迫嚗���梁�其��憭抒��撟曉�������� CPU ���������
������銋���臭誑��典��靘�皜祇��銝�憟����隞文�曹蝙��其��憭�撠� CPU ������嚗�

>> t=cputime; B=inv(A); det(A)*det(B), cputime-t
ans =
    1.0000
elapsed_time =
    0.0900

��典凝頠�閬�蝒���啣��������鈭粹�餉�蟲��嚗�CPU ���������蝣潸”閮�������蝯������詨榆銝����憭芸之嚗�
雿���臬�典��鈭箏��撌亦��閮�蝞���啣����改��撠勗�航�賣����貊�嗥����箏�乓��



��冽�����靘�隡啗��銝�憟����隞斤����瑁��銴����摨佗����芸����舀�����蝢拍�����
�����箸����圈�餉�衣����瑁��������銝�������
��詨飛摰嗆�湧��敹������航��蝞�甇仿����詻��
Matlab ��批遣銝����閮���詨�剁��閮�敺����皜�銋���扎��甈⊥�寥��鈭���箸�祈��蝞�甇仿�����甈⊥�詻��
���隞� flops 憿舐內甇方����詨�函����潘����� flops(0) 撠���嗆飛��嗚��靘�憒�

>> flops(0); 2+(3-4*5)/6; flops
ans =
     4

���銝�鈭�蝪∪�桃����箸�砍�賣�貊��閮�蝞�甇仿��鋡怠蕭��伐��靘�憒� exp(2.5) ���
sin(2.5) ���閮�蝞�甇仿����寞�砌��閮�嚗���� sqrt(2.5) 鋡怨��銝�甈∼��
���鈭�閮�蝞�甇仿��������餈�隡澆�潘��靘�憒� sum(1:10) ��������芣�� 9 甈∪��瘜�嚗�
雿���� Matlab 蝞�摰� 10 甈∼��銋�撠望�航牧 sum(1:n) 撠梁�嗆�� n 甈∟��蝞����
��� n 敺�憭抒��������嚗�銋�撠勗榆銝�憭�鈭����靘�憒�

>> A=rand(10,10); x = rand(10,1);
>> flops(0); x'*x; flops
ans =
    20
>> flops(0); A*x; flops
ans =
   200


��拍�� flops ��臭誑敺���嫣噶��唬摯閮�������閮�蝞�蝔�撘����銴����摨� (complexity)���
���撣豢��������閮哨����嗉撓��亦�拚�����蝬剖漲��� N 銋� N ���������嚗�
銝������拚��閮�蝞����銴����摨行�� O(N p)嚗�
������隤芾��蝞�甈⊥�詨之蝝����

C N p

��嗡葉 C ��臭�����甇�撣豢�賂��N ��舐�拚�����蝬剖漲嚗�p ��舀�������湔�詻��



隞乩��������蝷箇��銝�憟�撖阡��甇仿��嚗�
��其誑隡啗�� Matlab ��� inv (�����拚��) 蝔�撘�銋�閮�蝞�銴����摨艾��
�����������乩誑 N=10���20���40���80 ���鈭���豢�寥����������拚��嚗�
銝血��摰�������閮�蝞�甈⊥�貉�������� f 摨����銝準��

>> N=[10 20 40 80];
>> for k=1:4, A=rand(N(k),N(k)); flops(0); inv(A); f(k)=flops; end;
>> f
f =
        2601       18186      136364     1056506

�����臬�� f �����潘��銝���嫣噶�����箇垢��芥�������箏祕撽�銝剔�� N 隞� 2 ��������豢����瘀��
��寞��銴����摨衣�����閮哨��f �����澆之蝝����

f = ( 10p C     
2p 10p C     
22p 10p C     
23p 10p C )

���隞亙����嗅�������支誑������嚗�敺���啁��蝑�獢����閰脤�賣�� 2p嚗�
������ log2嚗�撠勗�臭誑隡啗�� p���

>> log2(f(2:4) ./ f(1:3))
ans =
    2.8057    2.9066    2.9538

��望迨������隡潔����臭誑������ p =3�����嗅��撠勗�臭誑隡啗�� C嚗�

>> f ./ N.^3
ans =
    2.6010    2.2732    2.1307    2.0635

��望迨��航�� C 憭抒����� 2������隞伐��Matlab 閮�蝞� N 銋� N �����拚�����銴����摨血之蝝����

2 N 3

������ Matlab ��砍�貊��撠�璆凋犖��∪神���蝔�撘������������������芸楛靘�撖恬��蝯������芸����詨�����
��單�潮��蝔株�����摨行�臬�行��雿喉�����瘝������航�賢神��箄�����摨行�港����������拚��閮�蝞�蝔�撘�嚗�
撠文�嗆�� p嚗����瘝������航�� < 3嚗�
���鈭����憿����敺���詨�澆����������拚��閮�蝞����鈭�隤脖�����霈����





[ 銝�銝���桀�� ]   
[ 銝�銝���桀�� ]   
[ 銝�撅斤�桅�� ]



��桃雁敶�
銝剖亢憭批飛��詨飛蝟�
獢����嚗�銝剖ㄑ 320
shann@math.ncu.edu.tw

(C) Copyright 2000 Wei-Chang Shann ��桃雁敶�
撱箇��嚗�2000/01/09��找耨��對��2000/01/09






計算複雜性理論 - 維基百科，自由的百科全書






























 






計算複雜性理論

維基百科，自由的百科全書


					前往：					導覽，					搜尋

計算複雜性理論（Computational complexity theory）是理論計算機科學和數學的一個分支，它致力於將可計算問題根據它們本身的複雜性分類，以及將這些類別聯繫起來。一個可計算問題被認為是一個原則上可以用計算機解決的問題，亦即這個問題可以用一系列機械的數學步驟解決，例如算法。
如果一個問題的求解需要相當多的資源（無論用什麼算法），則被認為是難解的。計算複雜性理論通過引入數學計算模型來研究這些問題以及定量計算解決問題所需的資源（時間和空間），從而將資源的確定方法正式化了。其他複雜性測度同樣被運用，比如通信量（應用於通信複雜性），電路中門的數量（應用於電路複雜性）以及中央處理器的數量（應用於並行計算）。計算複雜性理論的一個作用就是確定一個能或不能被計算機求解的問題的所具有的實際限制。
在理論計算機科學領域，與此相關的概念有算法分析和可計算性理論。兩者之間一個關鍵的區別是前者致力於分析用一個確定的算法來求解一個問題所需的資源量，而後者則是在更廣泛意義上研究用所有可能的算法來解決相同問題。更精確地說，它嘗試將問題分成能或不能在現有的適當受限的資源條件下解決這兩類。相應地，在現有資源條件下的限制正是區分計算複雜性理論和可計算性理論的一個重要指標：後者關心的是何種問題原則上可以用算法解決。



目錄


1 簡介
2 歷史
3 基本概念和工具

3.1 計算模型與計算資源
3.2 判定性問題和可計算性
3.3 算法分析
3.4 複雜性類
3.5 歸約


4 NP與P關係問題及相關理論

4.1 NP和P的定義
4.2 NP與P關係問題
4.3 NP完備理論
4.4 電路複雜性
4.5 其它NP與P關係問題相關的理論


5 理論與實踐
6 參考
7 外部連結



簡介[編輯]
計算複雜性理論所研究的資源中最常見的是時間（要通過多少步演算才能解決問題）和空間（在解決問題時需要多少記憶體）。其他資源亦可考慮，例如在並行計算中，需要多少並行處理器才能解決問題。
時間複雜度是指在電腦科學與工程領域完成一個演算法所需要的時間，是衡量一個演算法優劣的重要參數。時間複雜度越小，說明該演算法效率越高，則該演算法越有價值。
空間複雜度是指電腦科學領域完成一個演算法所需要占用的存儲空間，一般是輸入參數的函數。它是演算法優劣的重要度量指標，一般來說，空間複雜度越小，演算法越好。我們假設有一個圖靈機來解決某一類語言的某一問題，設有X個字（word）屬於這個問題，把X放入這個圖靈機的輸入端，這個圖靈機為解決此問題所需要的工作帶格子數總和稱為空間。
複雜度理論和可計算性理論不同，可計算性理論的重心在於問題能否解決，不管需要多少資源。而複雜性理論作為計算理論的分支，某種程度上被認為和算法理論是一種「矛」與「盾」的關係，即算法理論專註於設計有效的算法，而複雜性理論專註於理解為什麼對於某類問題，不存在有效的算法。
歷史[編輯]
在20世紀50年代，Trahtenbrot和Rabin的論文被認為是該領域最早的文獻。而一般說來，被公認為奠定了計算複雜性領域基礎的是Hartmanis和Stearns的1960年代的論文On the computational complexity of algorithms。在這篇論文中，作者引入了時間複雜性類TIME(f(n))的概念，並利用對角線法證明瞭時間層級定理（Time Hierarchy Theorem）。
在此之後，許多研究者對複雜性理論作出了貢獻。期間重要的發現包括：對隨機算法的去隨機化（derandomization）的研究，對近似算法的不可近似性（hardness of approximation）的研究，以及交互式證明系統理論和零知識證明（Zero-knowledge proof）等。特別的複雜性理論對近代密碼學的影響非常顯著，而最近，複雜性理論的研究者又進入了博弈論領域，並創立了「算法博弈論」（algorithmic game theory）這一分支。
基本概念和工具[編輯]
計算模型與計算資源[編輯]
計算複雜性理論的研究對象是算法在執行時所需的計算資源，而為了討論這一點，我們必須假設算法是在某個計算模型上運行的。常討論的計算模型包括圖靈機（Turing machine）和電路（circuit），它們分別是一致性（uniform）和非一致性（non-uniform）計算模型的代表。而計算資源與計算模型是相關的，如對圖靈機我們一般討論的是時間、空間和隨機源，而對電路我們一般討論電路的大小。
由邱奇-圖靈論題（Church-Turing thesis），所有的一致的計算模型與圖靈機在多項式時間意義下是等價的。而由於我們一般將多項式時間作為有效算法的標誌，該論題使得我們可以僅僅關註圖靈機而忽略其它的計算模型。
判定性問題和可計算性[編輯]
主條目：判定性問題
我們考慮對一個算法問題，什麼樣的回答是我們所需要的。比如搜索問題：給定數組A，和一個數s，我們要問s在不在A中（判定性問題，decision problem）。而進一步的，s如果在A中的話，s的位置是什麼（搜索型問題，search problem）。再比如完美匹配問題（perfect matching）：給定一個二分圖G=(V,E)，我們問是不是存在邊集E，使得二分圖中每個結點恰好屬於該邊集的一條邊（判定型問題）。而進一步的，E存在的話，E具體是什麼（搜索型問題）。
自然的，我們會發現對於一般的算法問題A，我們都可以這樣來問：首先，解是不是存在的？其次，如果解存在，這個解具體是什麼？這就是A的判定型問題和A的搜索型問題（又稱函數型問題）區分來源的直觀解釋。對判定型問題的回答只需是「是」或「否」，而對搜索型問題，需要返回解的具體形式或者「解不存在」。所以一個對A的搜索型問題的算法自然的也是對A的判定型問題的算法。反之，給定了一個A的判定型問題的算法，是否存在A的搜索型問題的算法，在可計算性理論和計算複雜性理論中有著不同的回答，這也是理解計算複雜性理論與它的前身可計算性理論不同的一個基本的觀察。
在可計算性理論中，可以說明，判定型問題和搜索型問題在可計算性的意義下是等價的（見Decision problem）。而在計算複雜性中，Khuller和Vazirani在1990年代證明瞭在P≠NP的假設下，平面圖4-著色問題的判定型問題是在P中的，而尋找其字典序第一的著色是NP難的。[1]
所以在可計算性理論中，只關註判定型問題是合理的。在計算複雜性理論中，雖然一些基本的複雜性類（如P，NP和PSPACE），以及一些基本的問題（P和NP關係問題等）是用判定型問題來定義的，但函數型問題複雜性類也被定義（如FP，FNP等），而且一些特別的函數型問題複雜性類，如TFNP，也正在逐漸受到關註。
算法分析[編輯]
上面提到計算複雜性理論的研究對象是執行一項計算任務所用的資源，特別的，時間和空間是最重要的兩項資源。
我們用時間作例子來討論算法分析的一些基礎知識。如果將輸入的長度（設為n）作為變量，而我們關註的是算法運行時間與n的函數關係T(n)。因為一個算法在不同的計算模型上實現時T(n)可能會有常數因子的差別（參見可計算性理論），我們使用大O表達式來表示T(n)，這使得我們可以忽略在不同計算模型上實現的常數因子。
以搜索這個計算任務為例。在搜索問題中，給定了一個具體的數s，和長度為n的數組A（數組中數的位置用1到n作標記），任務是當s在A中時，找到s的位置，而s不在A中時，需要報告"未找到"。這時輸入的長度即為n+1。下麵的過程即是一個最簡單的算法：我們依次掃過A中的每個數，並與s進行比較，如果相等即返回當前的位置，如果掃遍所有的數而算法仍未停止，則返回"未找到"。
如果我們假設s在A中每個位置的機率都相同，那麼算法在找到s的條件下需要1/n (1+2+...+n)=n(n+1)/2n=(n+1)/2的時間。如果s不在A中，那麼需要(n+1)的時間。由大O表達式的知識我們知道算法所需的時間即為O(n)。
而如果我們進一步假設A是已排序的，那麼我們有二分查找算法，使得算法的運行時間是O(logn)。可以看出執行一項計算任務，不同的算法在運行時間上是有很大差異的。
複雜性類[編輯]
將計算問題按照在不同計算模型下所需資源的不同予以分類，從而得到一個對算法問題「難度」的類別，就是複雜性理論中複雜性類概念的來源。例如一個問題如果在確定性圖靈機上所需時間不會超過一個確定的多項式（以輸入的長度為多項式的不定元），那麼我們稱這類問題的集合為P（polynomial time Turing machine）。而將前述定義中的「確定性圖靈機」改為「不確定性圖靈機」，那麼所得到的問題集合為NP（non-deteministic polynomial time Turing machine）。類似的，設n為輸入的長度，那我們可以定義「在確定性圖靈機上所需空間不超O(logn）的算法問題的集合」（即為L），「存在深度為O(logn)，輸入的度（fan-in）為O(1)的電路族（circuit family）的算法問題的集合」（即為NC1）等等複雜性類。
定義複雜性類問題的目的是為了將所有的算法問題進行分類，以確定當前算法的難度，和可能的前進方向。這是複雜性理論的一個主線之一：對算法問題進行抽象和分類。例如透過大O表達式，我們可以對忽略因計算模型不同而引入的常數因子。而第二個重要的理論假設，就是將多項式時間作為有效算法的標誌（與之對應的是指數時間）。這樣，複雜性類使得我們可以忽略多項式階的不同而專註於多項式時間和指數時間的差別。（對多項式時間作為有效算法的標誌這一點是有一定爭議的，比如，如果算法的運行時間n10，那它也可以看作是緩慢的，見理論與實踐。）在本文的其餘章節，「有效算法」等價於「多項式算法」
歸約[編輯]
歸約（reduction）是將不同算法問題建立聯繫的主要的技術手段，並且在某種程度上，定義了算法問題的相對難度。簡單來說，假設我們有算法任務A和B，如果我們想說「A比B簡單」（記為A≤B），它應該是什麼意思呢？從歸約的觀點來看，就是說如果我們有了B的有效算法M，那麼我們有一個有效算法N，它可以引用M，最終它要解決A問題。
我們以點集覆蓋問題（vertex cover）和獨立集問題（independent set）為例來進行說明。這兩個問題都是圖論中的問題。假設給定了無向圖G=(V, E)，和一個自然數k，點集覆蓋問題是要找到V的子集S，使得對∀e∈E，有s∈ S，使得s∈ e，且|S|≤k；而獨立集問題也是要找V的子集S，要求是∀s1, s2∈S，(s1, s2)∉ E，且|S|≤k。
一個簡單的觀察即是：對G=(V, E)，一個S⊂V是覆蓋點集，若且唯若S在G的補圖中是獨立點集（而且保持集合大小）。利用這個觀察，假設我們有瞭解決覆蓋點集問題的算法M，我們設計解決獨立點集的算法N如下：

算法N。

輸入：給定無向圖G=(V, E)，自然數k；
輸出：一個大小≤ k的獨立點集（如果存在，否則返回「不存在」）；
已知：算法M，輸入為(無向圖G, 自然數k)，輸出大小≤ k的覆蓋點集，如果這樣的點集存在。否則返回「不存在」；


算法步驟：

對G，產生G的補圖G'；
調用M，輸入為(G', k)；
如果M返回「不存在」，輸出不存在。如果M返回S⊂V，輸出S。



可以看出若產生補圖這一步是有效的，那麼如果M有效，N也是有效的。一般的，如果我們有一個B有效的算法M，和利用B作為「神諭」（oracle）的解決A問題的算法N，那麼如果N是有效的，則我們有有效的解決A問題的算法N'——只需將N中查詢B的操作換作具體的M算法即可。而這一性質的基本解釋是：將多項式的不定元用另一個多項式代替，那麼得到的仍是一個多項式。
所以從歸約的觀點來看，下麵的說法可以看作與「A比B簡單」（記為A≤B）等價：

A歸約到B（reduces A to B, or A is reducible to B, or A can be reduced to B）；
存在通過查詢B問題來解決A問題的算法（there exists an algorithm that asks oracles of B, and solves A）。

NP與P關係問題及相關理論[編輯]
計算複雜性理論最成功的成果之一是NP完備理論。通過該理論，我們可以理解為什麼在程序設計與生產實踐中遇到的很多問題至今沒有找到多項式算法。而該理論更為計算複雜性中的核心問題：P與NP的關係問題指明瞭方向。
NP和P的定義[編輯]
在上面我們已經知道，NP是指「在非確定性圖靈機上有多項式時間算法的問題」的集合，而P是指「在確定性圖靈機上有多項式時間算法的問題」的集合。這裡我們都考慮的是判定型問題，即考慮一個語言L，我們要判斷一個字符串x是不是在L中。那麼，一個等價的理解是：NP是指對在L中的x，有多項式長度的證據w，而且對語言(x,w)是有多項式時間算法的；而P是指對L中的x，有多項式時間算法判斷x在不在L中。
舉個例子，就是考慮完美匹配問題、點集覆蓋問題和圖不同構問題。這三個問題都有圖論背影，問題的描述如下：

完美匹配問題：給定圖G=(V,E)，找到邊的子集F⊂E，使得對任意的v∈V，存在唯一的e∈F，v∈e；
點集覆蓋問題：給定圖G=(V,E)，和自然數k，找到點的子集U⊂V，使得對任意的e∈E，存在v∈U，v∈e，且|U|≤k；
圖不同構問題：給定圖G=(V,E)，H=(U,F)，|G|=|H|。我們說G和H是同構的，是指∃T:V→U，對任意的s, t∈V，滿足E(s,t)=F(T(s),T(t))（這裡我們把邊集E看作V×V→{0,1}的映射）。圖不同構是問對G和H，是不是不存在這樣的映射。

關於這三個問題，它們在複雜性理論中，目前的地位如下：

完美匹配問題：在P中。可以利用艾德蒙德算法（英語：Edmond's algorithm）得到



O
(


V


E
)


{\displaystyle O({\sqrt {V}}E)}

運行時間的算法；
點集覆蓋問題：在NP中，而不知道是否在P中。實際上，它是NP完備問題，給出它的多項式算法將意味著證明NP=P。它在NP中，原因是給定一個點的子集U⊂V，我們可以在多項式時間中驗證這是否是一個滿足|U|≤k的點集覆蓋：U的大小很好驗證。然後只需對每一條邊e，遍歷U中每一個元素v，檢查是否有v∈e即可。運行時間至多為



O
(
V
E
)


{\displaystyle O(VE)}

；
圖不同構問題：在AM中，而不知道是否在NP中。它之所以困難，一個直觀的想法是：給定兩個圖G和H，首先這個問題的「證據」很難定義——不像點集覆蓋問題中，一個解就是一個點集，而且點集大小≤k≤|V|是多項式大小。這裡最直接的證據的定義，是說必須遍歷所有的映射T:V→U，並對所有的映射驗證是否滿足同構的定義。而這樣一個證據是指數大小的。

這樣我們有了：在P中、在NP而不知道是不是在P中、在AM中而不知道是不是在NP中的三個問題。
NP與P關係問題[編輯]




在P ≠ NP前提下複雜性類的關係圖解。在該前提下，不在P也不是NP完備的問題的存在性由Ladner解決。[2]


由於在多項式時間可以判斷x在不在L中，蘊含著x本身就是其在L中的證據的含義，所以P⊂NP。這個包含關係是不是嚴格的呢？或者說，是不是有語言L∈NP，使得L∉P？這就是著名的NP與P關係問題。從這個問題在1970年代被正式的提出之後，有NP完備理論賦予了它在實踐上的重要性，有證明複雜性理論賦予了它純數學理論上的重要性，有PCP理論和NP完備理論賦予了它算法理論上的重要性。這些理論或者在根本上依賴於NP和P關係問題的某些假設，或者本身就是試圖去理解NP和P關係問題而發展出來的，這使得它成為了理論計算機科學乃至數學的中心問題之一。在2000年，克雷數學研究所 提出了新世紀的數學中七個中心問題，NP與P關係問題就是其中的一個。
關於NP與P關係問題最早發展出的理論是NP完備理論。我們在下麵一節簡單瞭解NP完備理論。
NP完備理論[編輯]
主條目：NP完備
由上面歸約的知識我們知道，算法問題之間可以根據歸約來定義相對的難度。即對問題A和問題B，我們認為A比B簡單，記為A≤B，就是存在使用B問題解來解決A問題的算法M，且M是多項式時間的。那麼，在一個複雜性類中，有沒有可能存在「最難的問題」呢？具體的對NP，就是說是不是存在問題A∈NP，使得對∀B∈NP，有B≤A呢？對這樣的問題，我們稱它是NP完備的。
這個問題乍看起來很不容易把握。因為這需要對所有的NP中的語言L，去找到一個L到A的歸約算法。然而1970年代的由史蒂芬·庫克和列昂尼德·列文分別發現的庫克-列文定理，證明瞭布爾表達式（Boolean formula）的可滿足性問題（SAT問題）是NP完備的。概括的說，他們證明瞭，有一個通用的過程對NP中任意語言在非確定性圖靈機上運行歷史用布爾表達式來編碼，使得該布爾表達式是可滿足的，若且唯若該運行歷史是對給定輸入，接受該輸入的。這樣，我們就有了第一個被證明是NP完備的問題。
在庫克給出SAT問題是NP完備之後不久，理察·卡普證明瞭21個圖論、組合數學中常見的問題都是NP完備的。這賦予了NP完備問題在實踐中的重要性。現在，已經有成千個在實踐中遇到的算法問題被證明是NP完備的（參見NP完備問題列表），特別的有許多問題，如旅行商問題等的最優算法會帶來很大的經濟效益（旅行商問題的最優解可以給出最優的電路布線方案，而SAT的最優算法會促進程序驗證等問題的進步）。由NP完備的定義，我們知道對這其中任何一個問題的多項式算法都將給出所有NP問題，也包括所有NP完備問題的多項式算法。然而儘管實際問題中遇到很多NP完備的問題，而且有很多問題在不同領域有著相當的重要性而被大量研究，至今，仍沒有對NP完備問題的多項式算法，這是一些理論計算機科學家認為NP≠P的理由之一。
對NP和P關係問題，NP完備理論給出瞭如下的暗示：如果要證明NP=P，一個可能的方向是對NP完備問題給出多項式算法；如果要證明NP≠P，那麼必然的一個結果是NP完備問題沒有多項式算法。
電路複雜性[編輯]
主條目：電路複雜性
電路複雜性理論在1990年代以前，被眾多研究者認為是解決NP與P關係問題的可能的途徑之一。電路複雜性研究的對象是非一致性的計算模型電路，並考慮計算一個布爾函數所需的最小的電路的深度（depth）和大小（size）等資源。其中，大小為多項式大小的電路族可以計算的布爾函數被記為P/poly。可以證明，P包含在P/poly之中，而卡普-利普頓定理（Karp-Lipton theorem）表明若P/poly在NP之中，則多項式層級（polynomial hierarchy）將會坍縮至第二層，這是一個不大可能的結果。這兩個結果結合起來表明，P/poly可以當作是分離NP與P的一個中間的工具，具體的途徑就是證明任一個NP完全問題的電路大小的下界。在直觀上說，電路複雜性也繞過了NP與P問題的第一個困難：相對化證明困難（relativizing proofs）。
在1980年代，電路複雜性途逕取得了一系列的成功，其中包括奇偶性函數（Parity function）在



A

C

0




{\displaystyle AC^{0}}

中的下界為指數，以及團問題（clique problem）在單調性電路（monotone circuit）中的下界為指數。然而在1994年Razborov（英語：Alexander Razborov）和Rudich（英語：Steven Rudich）的著名論文自然性證明（Natural proof）中指出，上面所用證明電路下界的方法，在單向函數存在的前提下是不可能分離NP和P的。該結果使很多專家對證明電路下界來分離NP和P的前景表示不樂觀。
其它NP與P關係問題相關的理論[編輯]

去隨機化理論：包括偽隨機數發生器dom generator）和extractor的構造等；
不可近似性：以PCP定理為基礎，基於NP≠P和更強的唯一性遊戲假設（Unique game conjecture），可以證明對一些問題不存在某近似比的近似算法；

理論與實踐[編輯]
計算複雜性的初衷是理解不同算法問題的難度，特別的是一些重要算法問題的困難性。為了確切的描述一個問題的困難性，計算複雜性的第一步抽象是認為多項式時間是有效的，非多項式時間是困難的。這基於指數函數增長速度的「違反直覺」的特性：如果一個算法的時間複雜性為




2

n




{\displaystyle 2^{n}}

，取輸入的規模是100，在運算速度是




10

12




{\displaystyle 10^{12}}

每秒（關於CPU速度，參見Instructions per second，其中報告截止2009年，主流個人電腦的運算速度可以看作是



4
×

10

10




{\displaystyle 4\times 10^{10}}

每秒）的情況下，該程序將會運行



4
×

10

10




{\displaystyle 4\times 10^{10}}

年，幾乎是宇宙年齡。這為多項式時間被看作是有效時間提供了直觀上的證據。
然而多項式的指數很大的時候，算法在實踐中也不能看作是有效的。如




n

10




{\displaystyle n^{10}}

的多項式算法，取問題規模大小為1000，那麼幾乎就是




2

100




{\displaystyle 2^{100}}

的大小。另一方面，即便一個問題沒有多項式算法，它可能會有近似比很好的近似算法（參見近似算法），或有很好的啟發式算法（heuristics）。啟發式算法的特點是在理論上沒有精確的行為的分析，或者可以表明存在很壞的輸入，在這些輸入上運行很慢。然而在大多數時候，它都能快速解決問題。計算複雜性中對應的理論分析是平均複雜性理論（average-case complexity theory）和光滑分析（smooth analysis）。實際中的例子包括Presburger arithmetic（英語：Presburger arithmetic）、布爾可滿足性問題（參見SAT solver）和背包問題。
參考[編輯]


^ Khuller, S. and Vazirani, V. V. 1991. Planar graph coloring is not self-reducible, assuming P≠NP . Theor. Comput. Sci. 88, 1 (Oct. 1991), 183-183.
^ Ladner, Richard E. On the structure of polynomial time reducibility (PDF). Journal of the ACM (JACM). 1975, 22 (1): 151–171. doi:10.1145/321864.321877. 



外部連結[編輯]

The Complexity Zoo










閱
論
編


重要的複雜度類（完整列表）






易解複雜度類




對數空間相關



DLOGTIME
AC0（英語：AC0）
ACC0（英語：ACC0）
TC0（英語：TC0）
L · FL · SL · NL
NC
SC
PolyL








多項式空間相關



P（P-完全）
FP（英語：FP (complexity)）
ZPP
RP
BPP
BQP（QMA（英語：QMA）
PostBQP（英語：PostBQP）
EQP（英語：EQP））














懷疑難解複雜度類



UP
NP（NP完全
NP困難
反NP
反NP完全（英語：co-NP-complete））
FNP（英語：FNP (complexity)）（TFNP（英語：TFNP (complexity)））
PH
PP
#P（#P-完全（英語：Sharp-P-complete））
PSPACE（PSPACE完全（英語：PSPACE-complete））








難解複雜度類



EXPTIME
NEXPTIME
EXPSPACE
ELEMENTARY
PR
R
RE
ALL








複雜度類的譜系



多項式譜系（英語：Polynomial hierarchy）
指數譜系
Grzegorczyk譜系（英語：Grzegorczyk hierarchy）
算術譜系








相關複雜度族



DTIME
NTIME
DSPACE（英語：DSPACE）
NSPACE
可能性核對證明（英語：Probabilistically checkable proof）
交互式證明系統
量子複雜性理論
















閱
論
編


電腦科學






數學基礎

數理邏輯 · 集合論 · 數論 · 圖論 · 類型論 · 範疇論 · 數值分析 · 資訊理論






計算理論

自動機 · 可計算性理論 · 計算複雜性理論 · 量子計算 · 數值計算方法






算法和資料結構

算法分析 · 算法設計 · 計算幾何






程式語言和編譯器

語法分析器 · 解釋器 · 編程範型（過程化編程 · 物件導向程序編程 · 函數式編程 · 邏輯編程等）






並發、並行和分佈式系統

多處理器 · 網格計算 · 並發控制






軟體工程

需求分析 · 軟體設計 · 程序設計 · 形式化方法 · 軟體測試 · 軟體開發過程






系統架構

電腦系統架構 · 微處理器體系結構 · 作業系統






電信與網絡

路由 · 網絡拓撲 · 密碼學






資料庫

資料庫管理系統 · 關係資料庫 · 結構化查詢語言 · NoSQL · 事務處理 · 資料庫索引 · 數據挖掘






人工智慧

自動推理 · 計算語言學 · 計算機視覺 · 進化計算 · 專家系統 · 機器學習 · 自然語言處理 · 機器人學






計算機圖形學

可視化 · 計算機動畫 · 圖像處理






人機互動

計算機輔助功能 · 用戶界面 · 可穿戴計算機 · 普適計算 · 虛擬現實 · 聊天機器人






科學計算

人工生命 · 生物信息學 · 認知科學 · 計算化學 · 計算神經科學 · 計算物理學 · 數值算法 · 符號計算







註：計算機科學領域也可根據ACM-2012分類系統進行分類。











權威控制



GND: 4120591-1












 
						取自 "https://zh.wikipedia.org/w/index.php?title=計算複雜性理論&oldid=43820301"					
2 個分類：理論計算機科學計算複雜性理論隱藏分類：包含規範控制信息的維基百科條目 



導覽選單


個人工具

沒有登入對話貢獻建立帳號登入 



命名空間

條目
討論




台灣正體



不轉換
簡體
繁體
大陸簡體
香港繁體
澳門繁體
馬新簡體
台灣正體






查看

閱讀
編輯
檢視歷史



更多







搜尋



 







導航


首頁分類索引特色內容新聞動態近期變更隨機條目 



說明


說明維基社群方針與指引互助客棧知識問答字詞轉換IRC即時聊天聯絡我們關於維基百科資助維基百科 



其他專案


維基共享資源 



列印/匯出


下載成 PDF 



工具


連結至此的頁面相關變更上傳檔案特殊頁面可列印版靜態連結頁面資訊維基數據 項目引用此頁面 



其他語言


العربيةБългарскиবাংলাCatalàČeštinaDeutschΕλληνικάEnglishEspañolEestiفارسیFrançaisעבריתHrvatskiItaliano日本語한국어LietuviųBahasa MelayuNederlandsNorsk bokmålPolskiPortuguêsRomânăРусскийSrpskohrvatski / српскохрватскиSimple EnglishSlovenčinaСрпски / srpskiSvenskaไทยTagalogTürkçeУкраїнськаTiếng Việt 
編輯連結 





 本頁面最後修訂於2017年3月31日 (週五) 16:29。
本站的全部文字在創用CC 姓名標示-相同方式分享 3.0 協議之條款下提供，附加條款亦可能應用（請參閱使用條款）。
Wikipedia®和維基百科標誌是維基媒體基金會的註冊商標；維基™是維基媒體基金會的商標。
維基媒體基金會是在美國佛羅里達州登記的501(c)(3)免稅、非營利、慈善機構。


隱私政策
關於維基百科
免責聲明
開發人員
Cookie 聲明
手機版檢視



 

 









時間複雜度 - 維基百科，自由的百科全書






























 







時間複雜度

維基百科，自由的百科全書


					前往：					導覽，					搜尋







本條目存在以下問題，請協助改善本條目或在討論頁針對議題發表看法。






本條目包含過多行話或專業術語，可能需要簡化或提出進一步解釋。（2016年8月9日） 
請在討論頁中發表對於本議題的看法，並移除或解釋本條目中的行話。 







本條目需要編修，以確保文法、用詞、語氣、格式、標點等使用恰當。（2016年8月9日） 
請按照校對指引，幫助編輯這個條目。（幫助、討論） 







本條目可參照英語維基百科相應條目來擴充。（2017年3月） 
若您熟悉來源語言和主題，請協助參考外語維基擴充條目。請勿直接提交機械翻譯，也不要翻譯不可靠、低品質內容。依版權協議，譯文需在編輯摘要註明來源，或於討論頁頂部標記{{Translated page}}標籤。 












在電腦科學中，演算法的時間複雜度是一個函式，它定量描述了該演算法的執行時間。這是一個代表演算法輸入值的字串的長度的函式。時間複雜度常用大O符號表述，不包括這個函式的低階項和首項係數。使用這種方式時，時間複雜度可被稱為是漸近的，亦即考察輸入值大小趨近無窮時的情況。例如，如果一個演算法對於任何大小為 n （必須比 n0 大）的輸入，它至多需要 5n3 + 3n 的時間執行完畢，那麼它的漸近時間複雜度是 O(n3)。
為了計算時間複雜度，我們通常會估計演算法的操作單元數量，每個單元執行的時間都是相同的。因此，總運行時間和演算法的操作單元數量最多相差一個常量係數。
相同大小的不同輸入值仍可能造成演算法的執行時間不同，因此我們通常使用演算法的最壞情況複雜度（英語：Worst-case complexity），記為 T(n) ，定義為任何大小的輸入 n 所需的最大執行時間。另一種較少使用的方法是平均情況複雜度（英語：average-case complexity），通常有特別指定才會使用。時間複雜度可以用函式 T(n) 的自然特性加以分類，舉例來說，有著 T(n) = O(n) 的演算法被稱作「線性時間演算法」；而 T(n) = O(Mn) 和 Mn= O(T(n)) ，其中 M ≥ n > 1 的演算法被稱作「指數時間演算法」。



目錄


1 常見時間複雜度列表
2 常數時間
3 對數時間
4 冪對數時間
5 次線性時間
6 線性時間
7 線性對數（準線性）時間
8 多項式時間

8.1 強多項式時間與弱多項式時間
8.2 複雜度類


9 超越多項式（superpolynomial）時間
10 準多項式時間
11 次指數時間

11.1 第一定義
11.2 第二定義


12 指數時間
13 雙重指數時間
14 參見
15 參考資料



常見時間複雜度列表[編輯]
以下表格統整了一些常用的時間複雜度類別。表中，poly(x) = xO(1)，也就是 x 的多項式。


名稱
複雜度類
執行時間（



T
(
n
)


{\displaystyle T(n)}

）
執行時間舉例
演算法舉例


常數時間





O
(
1
)


{\displaystyle O(1)}


10
判斷一個二進位數的奇偶


反阿克曼時間





O
(
α
(
n
)
)


{\displaystyle O(\alpha (n))}



並查集的單個操作的平攤時間


疊代對數時間





O
(

log

∗


⁡
n
)


{\displaystyle O(\log ^{*}n)}



分散式圓環著色問題


對數對數時間





O
(
log
⁡
log
⁡
n
)


{\displaystyle O(\log \log n)}



有界優先佇列的單個操作[1]


對數時間
DLOGTIME




O
(
log
⁡
n
)


{\displaystyle O(\log n)}






log
⁡
n


{\displaystyle \log n}

，



log
⁡

n

2




{\displaystyle \log n^{2}}


二分搜尋


冪對數時間





(
log
⁡
n

)

O
(
1
)




{\displaystyle (\log n)^{O(1)}}






(
log
⁡
n

)

2




{\displaystyle (\log n)^{2}}





（小於1次）冪時間





O
(

n

c


)


{\displaystyle O(n^{c})}

，其中



0
<
c
<
1


{\displaystyle 0<c<1}







n


1
2





{\displaystyle n^{\frac {1}{2}}}

，




n


2
3





{\displaystyle n^{\frac {2}{3}}}


K-d樹的搜尋操作


線性時間





O
(
n
)


{\displaystyle O(n)}






n


{\displaystyle n}


無序陣列的搜尋


線性疊代對數時間





O
(
n

log

∗


⁡
n
)


{\displaystyle O(n\log ^{*}n)}



萊姆德·賽德爾（英語：Raimund Seidel）的三角分割多邊形（英語：Polygon triangulation）演算法


線性對數時間





O
(
n
log
⁡
n
)


{\displaystyle O(n\log n)}






n
log
⁡
n


{\displaystyle n\log n}

，



log
⁡
n
!


{\displaystyle \log n!}


最快的比較排序


二次時間





O
(

n

2


)


{\displaystyle O(n^{2})}







n

2




{\displaystyle n^{2}}


氣泡排序、插入排序


三次時間





O
(

n

3


)


{\displaystyle O(n^{3})}







n

3




{\displaystyle n^{3}}


矩陣乘法的基本實現，計算部分相關性（英語：Partial correlation）


多項式時間
P





2

O
(
log
⁡
n
)


=

n

O
(
1
)




{\displaystyle 2^{O(\log n)}=n^{O(1)}}






n


{\displaystyle n}

，



n
log
⁡
n


{\displaystyle n\log n}

，




n

10




{\displaystyle n^{10}}


線性規劃中的卡馬卡演算法（英語：Karmarkar's algorithm），AKS質數測試


準多項式時間
QP





2

(
log
⁡
n

)

O
(
1
)






{\displaystyle 2^{(\log n)^{O(1)}}}



關於有向斯坦納樹問題（英語：Steiner tree problem）最著名的



O
(

log

2


⁡
n
)


{\displaystyle O(\log ^{2}n)}

近似演算法


次指數時間（第一定義）
SUBEXP




O
(

2


n

ϵ




)


{\displaystyle O(2^{n^{\epsilon }})}

，對任意的ε > 0




O
(

2

(
log
⁡
n

)

log
⁡
log
⁡
n




)


{\displaystyle O(2^{(\log n)^{\log \log n}})}


假設複雜性理論推測，BPP 包含在 SUBEXP 中。[2]


次指數時間（第二定義）

2o(n）
2n1/3
用於整數分解與圖形同構問題（英語：Graph isomorphism problem）的著名演算法


指數時間
E
2O(n)
1.1n, 10n
使用動態規劃解決旅行推銷員問題


階乘時間

O(n!)
n!
通過暴力搜尋解決旅行推銷員問題


指數時間
EXPTIME
2poly(n)
2n, 2n2



雙重指數時間
2-EXPTIME
22poly(n)
22n
在預膨脹算術（英語：Presburger arithmetic）中決定一個給定描述的真實性


常數時間[編輯]
主條目：常數時間
若對於一個演算法，



T
(
n
)


{\displaystyle T(n)}

的上界與輸入大小無關，則稱其具有常數時間，記作



O
(
1
)


{\displaystyle O(1)}

時間。一個例子是存取陣列中的單個元素，因為存取它只需要一條指令。但是，找到無序陣列中的最小元素則不是，因為這需要遍歷所有元素來找出最小值。這是一項線性時間的操作，或稱



O
(
n
)


{\displaystyle O(n)}

時間。但如果預先知道元素的數量並假設數量保持不變，則該操作也可被稱為具有常數時間。
雖然被稱為「常數時間」，執行時間本身並不必須與問題規模無關，但它的上界必須是與問題規模無關的確定值。舉例，「如果a > b則交換a、b的值」這項操作，儘管具體時間會取決於條件「a > b」是否滿足，但它依然是常數時間，因為存在一個常量t使得所需時間總不超過t。
以下是一個常數時間的代碼片段：

int index = 5;
int item = list[index];
if (condition true) then
   perform some operation that runs in constant time
else
   perform some other operation that runs in constant time
for i = 1 to 100
   for j = 1 to 200
      perform some operation that runs in constant time

如果



T
(
n
)
=
O
(
c
)


{\displaystyle T(n)=O(c)}

，其中



c


{\displaystyle c}

是一個常數，這記法等價於標準記法



T
(
n
)
=
O
(
1
)


{\displaystyle T(n)=O(1)}

。
對數時間[編輯]
主條目：對數時間
若演算法的T(n) = O(log n)，則稱其具有對數時間。由於電腦使用二進位的記數系統，對數常常以2為底（即log2 n，有時寫作lg n）。然而，由對數的換底公式，loga n和logb n只有一個常數因子不同，這個因子在大O記法中被丟棄。因此記作O（log n），而不論對數的底是多少，是對數時間演算法的標準記法。
常見的具有對數時間的演算法有二元樹的相關操作和二分搜尋。
對數時間的演算法是非常有效的，因為每增加一個輸入，其所需要的額外計算時間會變小。
遞迴地將字串砍半並且輸出是這個類別函式的一個簡單例子。它需要O（log n）的時間因為每次輸出之前我們都將字串砍半。 這意味著，如果我們想增加輸出的次數，我們需要將字串長度加倍。


// 遞歸輸出一個字符串的右半部分
var right = function(str)
{
    var length = str.length;

    // 輔助函數
    var help = function(index)
    {

        // 遞歸情況：輸出右半部分
        if(index < length){

            // 輸出從index到數組末尾的部分
            console.log(str.substring(index, length));

            // 遞歸調用：調用輔助函數，將右半部分作為參數傳入
            help(Math.ceil((length + index)/2));
        }

        // 基本情況：什麼也不做
    }
    help(0);
}

冪對數時間[編輯]
對於某個常數k，若演算法的T(n) = O((log n)k)，則稱其具有冪對數時間。例如，矩陣鏈排序可以通過一個PRAM模型.[3]被在冪對數時間內解決。
次線性時間[編輯]
對於一個演算法，若其符合T(n) = o(n)，則其時間複雜度為次線性時間（sub-linear time或sublinear time）。實際上除了符合以上定義的演算法，其他一些演算法也擁有次線性時間的時間複雜度。例如有O(n½) 葛羅佛搜尋（英語：Grover's algorithm）演算法。
常見的非合次線性時間演算法都採用了諸如平行處理（就像NC1 matrix行列式計算那樣）、非古典處理（英語：Quantum algorithm）（如同葛羅佛搜尋那樣），又或者選擇性地對有保證的輸入結構作出假設（如冪對數時間的二分搜尋）。不過，一些情況，例如在頭 log(n) 位元中每個字串有一個位元作為索引的字串組就可能依賴於輸入的每個位元，但又符合次線性時間的條件。
「次線性時間演算法」通常指那些不符合前一段的描述的演算法。它們通常執行於傳統電腦架構系列並且不容許任何對輸入的事先假設。[4]但是它們可以是隨機化演算法，而且必須是真隨機演算法除了特殊情況。
線性時間[編輯]
如果一個演算法的時間複雜度為O(n)，則稱這個演算法具有線性時間，或O(n)時間。非正式地說，這意味著對於足夠大的輸入，執行時間增加的大小與輸入成線性關係。例如，一個計算列表所有元素的和的程式，需要的時間與列表的長度成正比。這個描述是稍微不準確的，因為執行時間可能顯著偏離一個精確的比例，尤其是對於較小的n。
線性對數（準線性）時間[編輯]
若一個演算法時間複雜度T(n) = O(nlog n)，則稱這個演算法具有線性對數時間。因此，從其運算式我們也可以看到，線性對數時間增長得比線性時間要快，但是對於任何含有n，且n的冪指數大於1的多項式時間來說，線性對數時間卻增長得慢。
多項式時間[編輯]
強多項式時間與弱多項式時間[編輯]
複雜度類[編輯]
從多項式時間的概念出發，在計算複雜度理論中可以得到一些複雜度類。以下是一些重要的例子。

P：包含可以使用確定型圖靈機在多項式時間內解決的決定性問題。
NP：包含可以使用非確定型圖靈機在多項式時間內解決的決定性問題。
ZPP：包含可以使用機率圖靈機在多項式時間內零錯誤解決的決定性問題。
RP：包含可以使用機率圖靈機在多項式時間內解決的決定性問題，但它給出的兩種答案中(是或否）只有一種答案是一定正確的，另一種則有幾率不正確。
BPP：包含可以使用機率圖靈機在多項式時間內解決的決定性問題，它給出的答案有錯誤的機率在某個小於0.5的常數之內。
BQP：包含可以使用量子圖靈機在多項式時間內解決的決定性問題，它給出的答案有錯誤的機率在某個小於0.5的常數之內。

在機器模型可變的情況下，P在確定性機器上是最小的時間複雜度類。例如，將單帶圖靈機換成多帶圖靈機可以使演算法執行速度以二次階提升，但所有具有多項式時間的演算法依然會以多項式時間執行。一種特定的抽象機器會有自己特定的複雜度類分類。
超越多項式（superpolynomial）時間[編輯]
如果一個演算法的時間 T(n) 沒有任何多項式上界，則稱這個演算法具有超越多項式時間。在這種情況下，對於所有常數 c 我們都有 T(n) = ω(nc)，其中 n 是輸入參數，通常是輸入的資料量（位元數）。指數時間顯然屬於超越多項式時間，但是有些演算法僅僅是很弱的超越多項式演算法。例如，Adleman-Pomerance-Rumely 質數測試（英語：Adleman–Pomerance–Rumely primality test）對於 n 位元的輸入需要運行 nO(log log n) 時間；對於足夠大的 n，這時間比任何多項式都快；但是輸入要大得不切實際，時間才能真正超過低階的多項式。
準多項式時間[編輯]
準多項式時間演算法是運算慢於多項式時間的演算法，但不會像指數時間那麼慢。對一些固定的 



c
>
0


{\displaystyle c>0}

，準多項式時間演算法的最壞情況運行時間是 




2

O
(
(
log
⁡
n

)

c


)




{\displaystyle 2^{O((\log n)^{c})}}

。如果準多項式時間演算法定義中的常數「c」等於1，則得到多項式時間演算法；如果小於1，則得到一個次線性時間演算法。
次指數時間[編輯]
術語次指數時間用於表示某些演算法的運算時間可能比任何多項式增長得快，但仍明顯小於指數。在這種狀況下，具有次指數時間演算法的問題比那些僅具有指數演算法的問題更容易處理。「次指數」的確切定義並沒有得到普遍的認同，[5]我們列出了以下兩個最廣泛使用的。
第一定義[編輯]
如果一個問題解決的運算時間的對數值比任何多項式增長得慢，則可以稱其為次指數時間。更準確地說，如果對於每個 ε> 0，存在一個能於時間 O(2nε) 內解決問題的演算法，則該問題為次指數時間。所有這些問題的集合是複雜性SUBEXP，可以按照 DTIME 的方式定義如下。[2][6][7][8]






SUBEXP

=

⋂

ε
>
0



DTIME


(

2


n

ε




)



{\displaystyle {\text{SUBEXP}}=\bigcap _{\varepsilon >0}{\text{DTIME}}\left(2^{n^{\varepsilon }}\right)}



第二定義[編輯]
一些作者將次指數時間定義為 2o(n) 的運算時間。[9][10][11]該定義允許比次指數時間的第一個定義更多的運算時間。這種次指數時間演算法的一個例子，是用於整數因式分解的最著名古典演算法——普通數域篩選法，其運算時間約為 




2




O
~



(

n

1

/

3


)




{\displaystyle 2^{{\tilde {O}}(n^{1/3})}}

，其中輸入的長度為 n。另一個例子是圖形同構問題（英語：Graph isomorphism problem）的最著名演算法，其運算時間為 




2

O
(


n
log
⁡
n


)




{\displaystyle 2^{O({\sqrt {n\log n}})}}

。
指數時間[編輯]
若T(n) 是以 2poly(n)為上界，其中 poly(n) 是 n 的多項式，則演算法被稱為指數時間。更正規的講法是：若 T(n) 對某些常數 k是由 O(2nk) 所界定，則演算法被稱為指數時間。在確定性圖靈機上認定為指數時間演算法的問題，形成稱為EXP的複雜性級別。






EXP

=

⋃

c
∈

N




DTIME


(

2


n

c




)



{\displaystyle {\text{EXP}}=\bigcup _{c\in \mathbb {N} }{\text{DTIME}}\left(2^{n^{c}}\right)}



有時侯，指數時間用來指稱具有 T(n) = 2O(n) 的演算法，其中指數最多為 n 的線性函式。這引起複雜性等級 E。






E

=

⋃

c
∈

N




DTIME


(

2

c
n


)



{\displaystyle {\text{E}}=\bigcup _{c\in \mathbb {N} }{\text{DTIME}}\left(2^{cn}\right)}



雙重指數時間[編輯]
若 T(n) 是以 22poly(n) 為上界，其中 poly(n) 是 n 的多項式，則演算法被稱為雙重指數時間。這種演算法屬於複雜性等級 2-EXPTIME。






2-EXPTIME

=

⋃

c
∈

N




DTIME


(

2


2


n

c






)



{\displaystyle {\mbox{2-EXPTIME}}=\bigcup _{c\in \mathbb {N} }{\mbox{DTIME}}\left(2^{2^{n^{c}}}\right)}



眾所周知的雙重指數時間演算法包括：

預膨脹算術（英語：Presburger arithmetic）的決策程式
計算葛洛拿基底（英語：Gröbner basis）（在最差狀況[12]）
實封閉體的量詞消去至少耗費雙重指數時間，[13]而且可以在這樣的時間內完成。[14]

參見[編輯]

L-notation

參考資料[編輯]


^ Mehlhorn, Kurt; Naher, Stefan. Bounded ordered dictionaries in O(log log N) time and O(n) space. Information Processing Letters. 1990, 35 (4): 183. doi:10.1016/0020-0190(90)90022-P. 
^ 2.0 2.1 Babai, László; Fortnow, Lance; Nisan, N.; Wigderson, Avi. BPP has subexponential time simulations unless EXPTIME has publishable proofs. Computational Complexity (Berlin, New York: Springer-Verlag). 1993, 3 (4): 307–318. doi:10.1007/BF01275486. 
^ Bradford, Phillip G.; Rawlins, Gregory J. E.; Shannon, Gregory E. Efficient Matrix Chain Ordering in Polylog Time. SIAM Journal on Computing (Philadelphia: Society for Industrial and Applied Mathematics). 1998, 27 (2): 466–490. ISSN 1095-7111. doi:10.1137/S0097539794270698. 
^ Kumar, Ravi; Rubinfeld, Ronitt. Sublinear time algorithms (PDF). SIGACT News. 2003, 34 (4): 57–67. 
^ Aaronson, Scott. A not-quite-exponential dilemma. Shtetl-Optimized. 5 April 2009 [2 December 2009]. 
^ Complexity Zoo: Class SUBEXP: Deterministic Subexponential-Time
^ Moser, P. Baire's Categories on Small Complexity Classes. Lecture Notes in Computer Science (Berlin, New York: Springer-Verlag). 2003: 333–342. ISSN 0302-9743. 
^ Miltersen, P.B. DERANDOMIZING COMPLEXITY CLASSES. Handbook of Randomized Computing (Kluwer Academic Pub). 2001: 843. 
^ 參照錯誤：沒有為名為ETH的參考文獻提供內容
^ Kuperberg, Greg. A Subexponential-Time Quantum Algorithm for the Dihedral Hidden Subgroup Problem. SIAM Journal on Computing (Philadelphia: Society for Industrial and Applied Mathematics). 2005, 35 (1): 188. ISSN 1095-7111. doi:10.1137/s0097539703436345. 
^ Oded Regev. A Subexponential Time Algorithm for the Dihedral Hidden Subgroup Problem with Polynomial Space. arXiv:quant-ph/0406151v1 [quant-ph]. 2004. 
^ Mayr,E. & Mayer,A.: The Complexity of the Word Problem for Commutative Semi-groups and Polynomial Ideals. Adv. in Math. 46(1982) pp. 305-329
^ J.H. Davenport & J. Heintz: Real Quantifier Elimination is Doubly Exponential. J. Symbolic Comp. 5(1988) pp. 29-35.
^ G.E. Collins: Quantifier Elimination for Real Closed Fields by Cylindrical Algebraic Decomposition. Proc. 2nd. GI Conference Automata Theory & Formal Languages (Springer Lecture Notes in Computer Science 33) pp. 134-183






 
						取自 "https://zh.wikipedia.org/w/index.php?title=時間複雜度&oldid=44250799"					
3 個分類：算法分析計算複雜性理論計算資源隱藏分類：有參考文獻錯誤的頁面自2016年8月包含過多行話或專業術語的條目自2016年8月需要校對的頁面自2017年3月需要從英語維基百科翻譯的條目需要從英語維基百科翻譯的條目含有多個問題的條目 



導覽選單


個人工具

沒有登入對話貢獻建立帳號登入 



命名空間

條目
討論




台灣正體



不轉換
簡體
繁體
大陸簡體
香港繁體
澳門繁體
馬新簡體
台灣正體






查看

閱讀
編輯
檢視歷史



更多







搜尋



 







導航


首頁分類索引特色內容新聞動態近期變更隨機條目 



說明


說明維基社群方針與指引互助客棧知識問答字詞轉換IRC即時聊天聯絡我們關於維基百科資助維基百科 



列印/匯出


下載成 PDF 



工具


連結至此的頁面相關變更上傳檔案特殊頁面可列印版靜態連結頁面資訊維基數據 項目引用此頁面 



其他語言


العربيةČeštinaDanskDeutschEnglishفارسیSuomiFrançaisעבריתItaliano한국어Norsk bokmålPortuguêsRomânăРусскийСрпски / srpski 
編輯連結 





 本頁面最後修訂於2017年5月5日 (週五) 19:19。
本站的全部文字在創用CC 姓名標示-相同方式分享 3.0 協議之條款下提供，附加條款亦可能應用（請參閱使用條款）。
Wikipedia®和維基百科標誌是維基媒體基金會的註冊商標；維基™是維基媒體基金會的商標。
維基媒體基金會是在美國佛羅里達州登記的501(c)(3)免稅、非營利、慈善機構。


隱私政策
關於維基百科
免責聲明
開發人員
Cookie 聲明
手機版檢視



 

 








計算時間複雜度(Time Complexity)要如何計算? | Yahoo奇摩知識+




















 









   ⌂首頁信箱新聞股市名人娛樂氣象運動App下載購物中心商城拍賣更多⋁知識+汽車機車電影字典遊戲旅遊理財房地產時尚美妝折扣城   Yahoo 奇摩知識+                        👤 登入    ✉ 信箱     ⚙ 服務說明    帳號資料 服務說明 意見回報        
















Yahoo奇摩知識+ 首頁











所有分類
 
健康
 
商業與財經
 
娛樂與音樂
 
家居與園藝
 
家庭與人際關係
 
寵物
 
懷孕與育兒
 
政治與政府
 
教育與參考
 
新聞與活動
 
旅遊
 
汽車與交通
 
消費電子產品
 
環境
 
社會科學
 
社會與文化
 
科學
 
美容與造型
 
藝術與人文
 
遊戲與休閒活動
 
運動
 
電腦與網際網路
 
食品與飲料
 
餐廳與小吃
 





世界Yahoo 








阿根廷





澳洲





巴西





加拿大





法國





德國





印度





印尼





義大利





馬來西亞





墨西哥







紐西蘭





菲律賓





魁北克





新加坡





香港





西班牙





泰國





英國與愛爾蘭





美國





越南





西班牙文







關於





關於 Yahoo奇摩知識+
社群指南
排行榜
點數與等級
部落格
如何安全地使用 Yahoo奇摩

 








 電腦與網際網路

 程式設計


 看另一則問題 










            計算時間複雜度(Time Complexity)要如何計算?
        


請問一下,下列程式的計算時間複雜度(Time Complexity)要如何計算呢？ 
i := 2 
while i < n do 
begin 
i := i2 
x := x + 1 
end 

感謝大家的幫忙.

更新: 
不好意思,我打錯了, 
i=i^2才對. 

謝謝您的詳細解答. :-)





 
1 個人正在追蹤 


 
 2 個解答 
2


檢舉不當使用









您確定要刪除此解答嗎？
是
否












 









抱歉，似乎發生一些問題。



Trending Now





 

解答














最佳解答: 
             i := i2 是打錯或顯示問題. 底下假設兩種常出現的狀況: 
(1)  
假設正確的是: i2 為 i+2 
則, i 的值從 2 起, 每做一次 [begin 和 end 之間的運算] 會加上 2, 
一直到 i 的值 >= n 就停. 
因此,  [begin 和 end 之間的運算] 做了約 n/2 次. 
[begin 和 end 之間的運算] 只是兩個基本運算, 
所以共做了約 n 個基本運算. 
因此時間複雜度是 O(n). 
(2) 
假設正確的是: i2 為 i^2 (即, i 的平方) 
則, i 的值從 2 起, 每做一次 [begin 和 end 之間的運算] 會變成平方值, 
一直到 i 的值 >= n 就停. 
因此,  [begin 和 end 之間的運算] 做了約 log n (底為 2) 次. 
[begin 和 end 之間的運算] 只是兩個基本運算, 
所以共做了約 2 log n 個基本運算. 
因此時間複雜度是 O(log n). 

 2009-02-24 15:20:36 補充： 
對不起, 我的答案 O(log n) 是錯的. 

因為 i = i^2, 因此 i 不是 2, 4, 8, 16, 32 ,... 

應該是 2, 4, 16, 256, ... (每次 i 變成 i^2) 才對. 

所以, 這數列是 A(1)=2, A(i)=(A(i-1))^2, i=1,2,3,4,... 

也就是 A(i)=2^(2^(i-1)), i=1,2,3,4,... 

上式, 當 A(i)=n 時, 2^(i-1)=log n, 

i-1 就是 log log n, 因此答案是 O(log log n). 

 2009-02-24 15:22:23 補充： 
對不起, 我今天才上 Yahoo 知識+, 所以回應也許太遲了. 

 2009-02-25 08:14:33 補充： 
A(1)=2 且 
A(i)=(A(i-1))^2, i=2,3,4,... 
可以如下解出 A(i) 

A(i)=(A(i-1))^2 
=((A(i-2))^2)^2= (A(i-2))^4 
=(((A(i-3))^2)^2)^2= (A(i-3))^8 
=...... 
=(A(i-k))^(2^k) 
=...... 
=(A(i-(i-1)))^(2^(i-1)) 
=(A(1))^(2^(i-1)) 
=2^(2^(i-1)) 

您是好學生! 




 參考資料： 
 DS & Algorithm textbooks 


Leslie
 · 9 年前 





0
真讚



0
真遜





檢舉不當使用


意見





 




新增意見











送出












 · 剛才不久













                  發問者的評分
                















 很奇怪剛剛看解答竟然是O(loglog n).有人知道是為甚麼嗎? 

 2009-02-24 17:59:28 補充： 
你好,謝謝你的回答,但是我還是有些不懂,可以在跟你請教一下嗎? 


所以, 這數列是 A(1)=2, A(i)=(A(i-1))^2, i=1,2,3,4,... 

也就是 A(i)=2^(2^(i-1)), i=1,2,3,4,...   <== 為何會變成A(i)=2^(2^(i-1)) 

 2009-02-25 09:16:18 補充： 
太感謝了.真是謝謝您.





koeiandy
 · 9 年前 




0
真讚



0
真遜





檢舉不當使用


意見







 




新增意見











送出












 · 剛才不久















 

檢舉不當使用

 我認為此問題違反社群指南 
聊天或爭嚷、成人內容、垃圾信、侮辱其他成員、顯示更多
我認為此問題違反服務條款
對未成年兒童有害、帶有暴力或脅迫意味、騷擾或侵犯隱私權、假冒或不實陳述、欺詐或網路釣魚、 顯示更多

其他詳細資料

若您認為自己的智慧財產權受到侵害，並想提出申訴，請參閱我們的版權/智慧財產權政策

檢舉不當使用


取消




檢舉不當使用

 我認為此解答違反社群規範 
聊天或爭嚷、成人內容、垃圾信、侮辱其他成員、顯示更多
我認為此解答違反服務條款
對未成年兒童有害、帶有暴力或脅迫意味、騷擾或侵犯隱私權、假冒或不實陳述、欺詐或網路釣魚、 顯示更多

其他詳細資料

若您認為自己的智慧財產權受到侵害，並想提出申訴，請參閱我們的版權/智慧財產權政策

檢舉不當使用


取消




檢舉不當使用

 我認為此意見違反社群規範 
聊天或爭嚷、成人內容、垃圾信、侮辱其他成員、顯示更多
我認為此意見違反服務條款
對未成年兒童有害、帶有暴力或脅迫意味、騷擾或侵犯隱私權、假冒或不實陳述、欺詐或網路釣魚、 顯示更多

其他詳細資料

若您認為自己的智慧財產權受到侵害，並想提出申訴，請參閱我們的版權/智慧財產權政策

檢舉不當使用


取消



 

你可能對以下搜尋感興趣：


高效率學習程式設計

揉捏按壓在家輕鬆舒緩疲勞

日本旅遊讓你天天上網超方便

最火熱線上遊戲












發問問題
通常可在幾分鐘內獲得解答！







展開»






詳細資料



詳細資料






現有問題




更多





請多詳述您的問題
上傳處理中




上傳失敗。 請上傳大於 100x100 像素的檔案
目前發生問題，請再試一次。
您只能上傳 PNG、JPG 或 JPEG 等類型的檔案。
您只能上傳 3GP、3GPP、MP4、MOV、AVI、MPG、MPEG 或 RM 等類型的檔案。
您只能上傳不超過 5 MB 的相片。
您只能上傳不超過 600 MB 的影片。
您只能上傳相片 (png, jpg, jpeg) 或影片 (3gp, 3gpp, mp4, mov, avi, mpg, mpeg, rm)。
您只能上傳相片或影片。
影片不應超過 <b>600mb/5 分鐘</b>
相片不應超過 <b>5mb</b>
影片不應超過 <b>600mb/5 分鐘</b>相片不應超過 <b>5mb</b>
  







解答問題


C# cmd.CommandText的問題?



 

公司想整個網頁,有無咩網頁公司推薦?



 

公司想搵網頁設計公司重做網頁?



 

(C Sharp) 使用cmd.CommandText執行SQL指令出現錯誤訊息?



 


發燒問題




如何用EXCEL亂數產生210~230之間的亂數,間距為5
210、215、220、225---?

                  6 個解答
              

 

想自學遊戲設計，有什麼書籍是可以買來自己看的?

                  7 個解答
              

 

Dreamweaver做完為什麼是file:///C:/Users/.......，怎麼把它改掉?

                  5 個解答
              

 
更多問題





本人想學程式語言 但這方面什麼都不懂 什麼迴圈阿 函數之類的 請問有什麼方法可以入門程式語言嗎?

             5 個解答
         

 

誰能認真教我做出一個簡單的網站
稍微設計一點程式就好了
要交大學專題用的
可以一步一步交的
會給回饋?

             5 個解答
         

 

想請問去職訓局學程式設計 對就業上的幫助?

             7 個解答
         

 

  








服務條款


隱私權


RSS















﻿
演算法筆記 - Algorithm

Algorithm

演算法是什麼？

演算法是計算機科學非常重要的基礎科目。簡單來說，演算法就是用電腦算數學的學問（古代人用算盤算、現代人用電腦算），可以說是數學科目。
想要解決現實生活當中的各種問題，電腦科學家就把現實問題對應到數學問題，然後設計公式、把公式寫成程式，讓電腦執行程式計算答案──這些公式就叫做演算法了。
儘管這裡用了「公式」這個字眼來形容演算法，然而並不是各位印象中的數學公式。由於電腦能夠執行繁複的計算，所以公式可以設計成好幾十行、好幾百行，甚至用到很多數學理論。
因此呢，就算學習過演算法的人，也不見得懂得設計演算法；因為數學、程式的東西實在太複雜了。想把現實問題對應到數學問題，那就更複雜了。
電腦只會算數字
回過頭來，電腦又是什麼？電腦是個很潮的中文翻譯，不過實際上電腦的原意是「計算機」。電腦的英文叫做computer，而計算的英文就叫做compute。
電腦是一臺計算機，只會計算、判斷、儲存數字。又快又準。
程式是一連串計算、判斷、儲存數字的步驟。
電腦只會處理數字（二進位數字）。電腦裡的每一個文字、每一種顏色、每一種聲音，其實都有相對應的數字。
打個比方，我們規定：用1代表「一」，用2代表「乙」，用3代表「人」，……。一個數字對應一個中文字。電腦裡面的所有中文字，都依循人為規定，變作了數字。
再打個比方，「人」這個字，呈現電腦螢幕上是個「人」樣。電腦螢幕的畫面，是由許多小光點組成的；電腦螢幕上的「人」也是由許多小光點組成的。我們以「人」的左下角為座標原點，橫向為X軸，直向為Y軸，那麼「人」其實是(0,1)、(1,2)、(2,3)、...這些座標畫上黑點後所形成的。「人」這個字的的形狀，在電腦中變作了一連串的數字。
同樣的道理，呈現在電腦螢幕畫面上的文字、顏色、圖片、影像、聲音，全部都可以化作數字。一切事物在電腦裡面都是數字。
電腦並沒有想像中的那麼神奇。不過電腦最厲害的地方並不是電腦本身，而是在於電腦可以接上各式各樣的設備。接上攝影機與螢幕，就可以把色彩變成數字、把數字變成色彩；接上麥克風與耳機，就可以把聲音變成數字、把數字變成聲音。
電腦一旦接上了設備，就額外有用處。接上話機和基地台，就可以互通有無；接上數位相機和印表機，就可以製造回憶；接上重量儀和篩子，電腦也會揀土豆；接上車廂、接上警示燈、再雜七雜八接上一堆東西，就變成了大眾運輸系統。
若要用電腦解決現實問題，通常要考慮兩個方面：一、電腦應該接上那些設備？如何用電腦控制這些設備？二、現實問題如何對應到數學問題？如何設計演算法？
程式用來比對數字、改變數字、儲存數字
舉個例子，我們希望把螢幕上的「人」變成斜體字。過程大略是這樣──首先呢，把「人」的形狀(0,1)、(1,2)、(2,3)、...這些數字拿出來；然後呢，位置越高的座標，就往右移動多一點，如此一來就成為斜體字了。想讓座標往右移動，就是讓電腦做數字加法計算，然後把相加結果儲存起來。
再舉個例子，用滑鼠點選一個資料夾，資料夾的顏色會反白。過程大略是這樣──首先呢，電腦偵測到滑鼠點擊的座標之後，把座標轉換成數字；然後呢，再把螢幕畫面的資料拿出來，看看螢幕上每個東西的座標，是哪一個與滑鼠的座標相符合；噢，原來是一個資料夾的圖示，把資料夾的顯示顏色給反白過來。
再舉個例子，電腦據說會揀選土豆。過程大略是這樣──把每一顆土豆拿出來，利用特殊的儀器，把形狀、重量、色澤、氣味統統轉換成數字，儲存在電腦裡面；然後呢，用電腦比較這些數字，找出優良的土豆，如此一來就有綿綿鬆鬆的土豆了！
編寫程式，計算數字，這就是程式設計師的工作。
數學和程式這麼複雜，為什麼要用電腦解決現實問題？
電腦的計算速度可說是非常的快，一秒鐘可以進行好幾千萬次。就算文字多麼的多，圖片多麼的大，電腦處理起來，也是輕鬆寫意，順暢無比。
打開電腦裡的任何一份文件，用滑鼠捲動一下文件畫面，眼睛都還沒眨一下，正確畫面馬上就呈現在螢幕上了。事實上在捲動畫面的時候，電腦已經經過幾千萬次的計算，僅使用了極短的時間，就把螢幕上應該呈現的資料全部計算好了。
人類會想要用電腦解決問題，正是仰賴電腦的計算速度、正確性，以及電腦會自動按照程式計算的特性。程式設計師只要花心思寫出一支好程式，接下來的工作就可以讓電腦代勞了。電腦做的比人類更快更好，電腦做得到人類做不到的事情；儘管數學和程式很複雜，還是有很多人選擇使用電腦解決問題。
那些現實問題是用演算法解決的？
現代人的生活已經離不開演算法了。比如說你的手機裡面就有上百個演算法。你可以Google一下新聞。下麵的表格是隨手整理出來的，可以參考看看。

物理 ⑴
化學 ⑴ ⑵
醫學 ⑴
藥學 ⑴
生物 ⑴
農業 ⑴ ⑵
天文
地理 ⑴
海洋 
太空 ⑴ ⑵
地球 ⑴
環境 ⑴ ⑵
生態 ⑴
社會 ⑴ ⑵
心理
居家 ⑴ ⑵
生活 ⑴
設計 ⑴
藝術 ⑴
美術 ⑴
音樂 ⑴
文學 ⑴
歷史 ⑴ ⑵
遊戲 ⑴ ⑵
玩具 ⑴
演藝 ⑴ ⑵
經濟
金融 ⑴ ⑵
訊息 ⑴
交通 ⑴
運輸 ⑴ ⑵
物流 ⑴
鑑識 ⑴
治安 ⑴ ⑵
國防 ⑴
政治 ⑴
教育 ⑴ ⑵
救護 ⑴
安全 ⑴ ⑵
機械 ⑴
工廠 ⑴ ⑵
資源 ⑴
能源


Algorithm

演算法是什麼？
演算法由三個部分組成：輸入、計算步驟、輸出。介紹這件事情的時候，有人連結到函數的概念，也有人連結到黑箱白箱的概念。

          -----------------
input --->| computational |
          | sequence      |---> output
          -----------------

輸入、輸出是一堆數字。實務上是將這些數字放在資料結構，例如array、list。輸入來源，通常是硬碟裡面儲存的檔案，或者是藉由硬體裝置擷取到的數字，例如數位相機、麥克風等等。輸出去處，通常是硬碟裡面儲存的檔案，或者是藉由硬體裝置轉換之後以其他型態呈現，例如數位電視、數位音響等等。
計算步驟是一連串處理數字的指令。指令有兩種類型，一類是運算，例如數學運算加減乘除、邏輯運算且或非、比較運算大於等於小於、位元運算左右反且或異或。另一類是讀寫，例如讀取某處的數字、儲存數字至某處，就跟計算機的MR、M+按鍵的意義相似。
古人定義演算法，規定計算步驟的數量是必須是有限步，不是無限步。用程式語言的術語來說就是：演算法不能有無窮迴圈。
古人當初規定有限步，是為了方便統計總步數。但是實務上，很多電腦程式是開啟之後就保持執行狀態，直到當機、重開機，例如網路傳輸的演算法。因此實務上可以是無限步。
如何記載一個演算法？
有人用虛擬碼來記載一個演算法。如要設計電腦程式，虛擬碼是比較恰當的。

GREATEST_COMMON_DIVISOR(a, b)
1   while a ≠ b do
2       if a > b then
3           a ← a - b
4       else
5           b ← b - a
6   return a

有人用流程圖來記載一個演算法。如要設計電子電路，流程圖是比較恰當的。

大多數時候，我們無法光從虛擬碼和流程圖徹底理解演算法，就如同我們無法光從數學公式徹底理解數學概念。想要理解演算法，通常還是得藉由文字、圖片的輔助說明。
如何實作一個演算法？
實作的意思是：實際去操作、實際去運行。
對於資工系學生來說，自然就是把演算法撰寫成電腦程式，例如C或者C++程式，然後在個人電腦上面執行程式。

int gcd(int a, int b) {
	while (a != b)
		if (a > b)
			a -= b;
		else
			b -= a;
	return a;
}

對於電機系學生來說，自然就是把演算法設計成電子電路，在麵包板、印刷電路板、PLD上面執行。

電子電路也有加法器、減法器、AND邏輯閘、OR邏輯閘等等，所以也可以用電子電路實作演算法。例如電子錶、隨身聽、悠遊卡等等，都是直接將演算法做死在晶片上面。在個人電腦、智慧型手機還沒流行之前，以往都是用電子電路實作演算法。
電子電路的執行速度是飛快的，電腦程式的執行速度慢了一點。然而，製作電子電路的過程相當麻煩，需要精密的設備、複雜的製程、大量的人力和經費，而且製成之後就無法修改；相對地，寫程式就簡單輕鬆多了，在電腦上面很容易調整程式碼，又可以儲存很多程式碼，最主要的是家家戶戶都有電腦。
時間複雜度、空間複雜度
要評斷一個演算法的好壞，最基本的指標是時間和空間。
最直覺的方式，就是測量程式的執行時間、程式的記憶體使用量。但是由於相同演算法於不同電腦的執行時間會有差異，又由於每個人實作演算法所採用的程式語言、程式設計技巧都不一樣，所以執行時間、記憶體使用量不是一個穩定的評斷標準。
數學家於是計算步驟數量。

BUBBLESORT(A, n)                  | steps   
1 for i ← 0 to n-1 do             | n       
2     for j ← i to n-i-1 do       | n(n-1)/2
3         if A[j] < A[j+1] then   | n(n-1)/2
4             temp ← A[j]         | n(n-1)/2
5             A[j] ← A[j+1]       | n(n-1)/2
6             A[j+1] ← temp       | n(n-1)/2


total = n + 5n(n-1)/2
      = n + 2.5n² - 2.5n
      = 2.5n² - 1.5n
      = O(n²)

數學家把步驟數量寫成代數式子。例如當輸入資料有n = 1000個數字，步驟數量一共是2.5×1000² - 1.5×1000 = 2498500步。
有了步驟數量之後，還可以進一步粗估執行時間。假設一個步驟需要10個clock，而電腦中央處理器CPU的時脈是2GHz：每秒鐘執行2000000個clock，那麼程式執行時間大約12.4925秒。
但是這不是精準的步驟數量。由於實作的關係，係數很容易變動，所以係數的意義不大。因此數學家只取出代數式子的最高次方，並且規定n必須足夠大（類似微積分的趨近無限大）。儘管這是非常不精準的估算方式，不過還是可以對常見的演算法進行簡易分類，粗略地比較快慢。

               | time*       | space
---------------+-------------+--------
bubble sort    | O(n²)       | O(n)
insertion sort | O(n²)       | O(n)
merge sort     | O(n log(n)) | O(n)
quicksort      | O(n²)       | O(n)
heapsort       | O(n log(n)) | O(n)
counting sort  | O(n+r)      | O(n+r)

*worst case

空間的計算方式與時間類似，就不多提了。
解決問題的成效
要評斷一個演算法的好壞，除了時間和空間的用量以外，主要還是看演算法解決問題的成效如何。
數學問題，通常可以明定解答好壞，例如數字越大越好。通常這種情況，有多種演算法可以求得正解，那麼這些演算法的成效是一樣好的。
真實世界的問題，通常難以界定絕對的好壞優劣，例如美醜、樂音噪音、喜怒哀樂、是非對錯等等，此時演算法的成效，則由人類自行判斷，利用兩兩比較、投票表決等等方式來決定成效。
數學與計算學
數學是以基本元件來構築事物、表達概念。而數學家藉由數，嘗試構築每一件事物、表達每一個概念，拼湊出世界的全貌。比如位置、形狀、關係、轉換、遞迴、極限、比較、排列、正反、假設，這些東西都是數。又比如有、無、聚、散、疏、密、盈、虧、彎、直、交、錯、動、靜，這些東西也都是數。與物體的行為有關的數，就是物理；與物質性質變化有關的數，就是化學；與生命運作有關的數，就是生物學。繼續細分下去的話，我們所知的各種東西，其實皆可說是數。
在數當中，可以用數量來表示的，便可以計量。像是情緒、風格、謀略，難以用數量來表示，也就難以計量，甚至不可計量。像是動作、旋律、次序，可以部分地或完全地用數量表示，便得以計量。計算學是以數量來構築事物、表達概念。而計算學家藉由數量，嘗試量度各種事物、各種概念，掌握其確切的程度與層次。

Algorithm

學習程式語言
學習程式語言，有兩個層次：一、程式語言本身的語法；二、把想法轉換成程式碼。
第一個層次稱做「程式語言Programming Language」。目標是背熟規格書、靈活運用程式語言。
第二個層次稱做「程式設計Programming」。目標是設計程式碼解決問題。然而現今世界上還沒有一套公認的、固定的學習流程。
學習演算法
學習演算法，有兩個層次：一、演算法本身的運作過程；二、把想法轉換成演算法。
第一個層次稱做「演算法Algorithm」。目標是理解演算法、靈活運用演算法。讀者可以參考本站首頁的各大欄位，例如圖論、計算幾何、字串學等等。
第二個層次稱做「演算法設計Algorithm Design」。目標是設計計算步驟解決問題。讀者可以參考本站首頁的Algorithm Design欄位，以及從各種演算法當中汲取經驗、擷取靈感。
學習函式庫、工具
很多現實問題及其計算步驟，已經成為標準流程SOP，沒有什麼改動的餘地，成為了演算法。因此科學家就把這些演算法編寫成函式庫（Library），接著把現實生活的常見需求編寫成工具（Toolkit），讓程式設計的過程更加迅速。
時間就是金錢。現今的軟體產業當中，絕大部分都是直接使用現成的函式庫、工具，只有從事研發才會從無到有設計程式碼、設計演算法。優秀的工程師，總是擅於活用函式庫、工具，快速實現自己想要的功能。網路上已經有許多現成的函式庫和工具，通常也附帶詳細的使用說明書，方便工程師運用。
由於大家看事情習慣只看錶面，因此衍生了一種奇怪的現象：大家把使用工具稱做「使用技術」，大家把背熟使用說明書、依樣畫葫蘆稱做「學習技術」。大家常常自詡擁有許多「技術」，將「技術」奉為圭臬；但是卻很少人懂得背後的程式碼技巧、演算法原理，也很少人有能力研發、創新、解決目前尚未解決的現實問題。這是本末倒置的奇怪現象。
演算法營隊

臺大資訊系資訊之芽
熱心學生自動自發舉辦的高中營隊

演算法書籍









演算法網站

Jeff Erickson
演算法課程網站，有許多課程講義。

Erik Demaine
演算法課程網站，有許多特殊主題。

David Eppstein
計算幾何和圖論。維基百科有很多內容是他寫的。

GeeksforGeeks
程式語言、數學、演算法益智問題。

Algorithms Notes
演算法益智問題。

高中職資訊科技融入教學網
提供很多教學flash。

演算法論文

Two Minute Papers
短片介紹計算機科學的前沿論文，主攻多媒體領域。

arXiv
收集物理學、數學、計算機科學、生物學的論文草稿。
有機會可以找到一些期刊論文的草稿。

CiteSeer，CiteSeerX
資訊學術論文的搜尋引擎，統計論文引用情形。有時可以抓到論文的電子檔。

SODA、FOCS、STOC
頂級的演算法學術會議，這幾個是偏向數學理論的。

Scimago Journal & Country Rank
收集期刊的出版數據，用來判斷期刊優劣。

國家教育研究院：雙語詞彙、學術名詞暨辭書資訊網
提供英文對繁體中文的學術名詞翻譯。

全國科學技術名詞審定委員會：術語知識服務平臺
提供英文對簡體中文的學術名詞翻譯。

演算法故事書






繁：《勇闖資訊新未來：打造資訊科技的幕後英雄》
簡：《奇思妙想：15位計算機天才及其重大發現》

繁：《改變世界的九大演算法：讓今日電腦無所不能的最強概念》
簡：《改變未來的九大算法》

繁：《演算法統治世界》介紹此書的廣播節目
簡：《算法帝國》

數學網站

Matrix67
一位中國學生Matrix67的個人部落格，
他的專長是文史，然而他閒暇之餘也喜歡研究數理。
作者經常寫下令人驚艷的數學文章！
偶爾也會談談有趣的演算法！
是非常值得常常去逛的網站。

Wolfram Math World
這個網站收集了豐富的數學資料，同時也不斷的收集新知放到網站上。
如果遇到了數學問題，可以到這裡查詢資料。
這個網站是Wolfram公司製作的一個數學網站。
該公司在數學領域上有很多研究，開發了有名的mathmatica軟體。

planetmath.org
這個網站的目標是成為數學的百科全書。
收集了豐富的數學資料，同時也不斷的收集新知放到網站上。
可以找到很多好讀的數學文章。

AMS Open Math Notes
數學家的教學筆記。

The On-Line Encyclopedia of Integer Sequences
這個網站含有各式各樣、包羅萬象的數列資訊。
你可以參考網站的操作範例，輸入一串數列，就可以找到該數列的詳細資料，
有名稱、公式、解釋、相關連結。包你看的目不暇給、眼花撩亂。
若是你遇到了莫名奇妙的數列，可以試著來這裡找找看，鐵定找得到！


Competitive Programming

Competitive Programming
「Association for Computing Machinery (ACM)」是一個致力於電腦科學教育的協會，出版大量的專業期刊文獻，舉辦重大的計算機科學會議，在資訊界舉足輕重、名聞遐邇。
ACM每年度都會舉辦一次「The ACM-ICPC International Collegiate Programming Contest (ACM-ICPC)」，是一個給全世界大專院校學生參加的演算法程式設計比賽，比賽目的在於考驗選手臨場的演算法設計能力、程式編寫能力。ACM首先在世界各地舉辦初賽，再從各個賽區選拔出表現優秀的隊伍，角逐世界總決賽。
ACM-ICPC帶動了演算法程式設計的風氣。世界上許多大專院校的資訊系所，仿照ACM-ICPC的比賽模式，紛紛自行開發出即時線上比賽系統，能夠自動批改、評分、計時、統計。學生不必齊聚一堂，藉由網際網路，就可以相互切磋程式設計技巧。比賽結束之後，便將比賽題目編列題庫，開放線上批改程式的功能，供學生賽後練習檢討。這套系統大家普遍稱呼為「Online Judge」。
從事這項活動，不僅可以熟悉程式設計、學習演算法、鍛鍊智力，還可以培養自主學習與獨立解題的能力──此即程式設計師的核心價值。
這項活動開始獲得大家重視。產業界舉行演算法競賽，發掘優異人才；學術界開設課程，促進演算法的研究發展。由於競賽的緣故，大家將這項活動稱呼為「Competitive Programming」。
UVa Online Judge工具網站
最古老、最有知名度的Online Judge，是由西班牙知名的瓦雅多利大學「Universidad de Valladolid (UVa)」開發的「UVa Online Judge」。資源非常豐富。

Lucky貓的ACM園地、Ruby兔的ACM園地、Unfortunate狗的ACM園地、uniDog的ACM園地
UVa Online Judge題目中譯！非常偉大的工作，請大家要心懷感激！

uHunt
可以查詢自己在UVa Online Judge的解題進度、簡單題列表、世界排名等等。
另外也整理了一套題庫，適合初學者循序練習。輸入使用者名稱就會出現。
是你不得不知道的網站！

uDebug
提供UVa Online Judge題目解答的執行檔，
自行輸入資料，可以生成正確輸出，進而測試自己的程式。

World of 7
uHunt站長的兄弟所製作。
整理了UVa Online Judge題目的解法提示、演算法動畫。

Problem Classification on Spanish Archive
題目分類。

演算法題庫

UVa Online Judge
西班牙Valladolid大學的Online Judge。
是最古老也是全世界最知名的Online Judge，題庫目前約有4000+題。
題目類型非常廣泛。絕大部分的題目難度偏易，適合初學者磨練程式設計功力。

PKU JudgeOnline
中國北京大學的Online Judge。中國最大的Online Judge。
題目類型偏向演算法競賽，可以找到比賽常見題型。
好處是網路上能輕鬆找到中文的解題報告。

Timus Online Judge
俄國Ural大學的Online Judge。俄國最大的Online Judge。
有比較進階的演算法題目，難度偏高。

Sphere Online Judge
波蘭Sphere實驗室建立的Online Judge。波蘭最大的Online Judge。
會員可自創題目，題目很有特色，但是品質良莠不齊。

Kattis
瑞典Kattis公司成立的Online Judge。瑞典最大的Online Judge。

URI Online Judge
巴西最大的Online Judge。

高中生程式解題系統 ZeroJudge
台灣高雄師大附中建立的Online Judge。台灣最大的Online Judge。

演算法例賽

TopCoder，簡介
全世界規模最大的程式競賽網站，其中包含了演算法競賽。

Codeforces
俄國最大的演算法例賽。
題目較有挑戰性。賽後會提供詳細的題目講評，是個自主學習的好地方！

CodeChef
印度最大的演算法例賽。

AtCoder
日本最大的演算法例賽。

BestCoder
中國最大的演算法例賽。由中國杭州電子科技大學維護。

ITSA & PTC 線上程式設計競賽
台灣最大的演算法例賽。台灣教育部提供的例行賽事。

演算法面試考題

leetcode
世界知名的演算法面試考題網站。
想要省時省力的面試主考官從裡面挑題目，
於是求職者不得不去練習這些題目。
然而工作上用不到這些知識，已經發展到了病態的地步。

PAT計算機程序設計能力考試
中國的證照考試。

CPE大學程式能力檢定
台灣某些教授聯手搞出來的證照考試，你懂的。

演算法競賽



2016TW、2015TW、2014TW

ACM International Collegiate Programming Contest
縮寫：ACM-ICPC
對象：大專院校學生
　　　（學士班一年級至碩士班一年級）
時間：台灣站11～12月
　　　亞洲各站是8～12月
　　　世界總決賽是隔年5～7月
主辦：Association for Computing Machinery
承辦：台灣賽區由台灣大專院校輪流承辦




ACM SIGMOD Programming Contest
對象：大專院校學生
時期：2～4月




Google Code Jam
對象：社會大眾
時期：4月～7月




TopCoder Open
對象：社會大眾
時期：4月～8月

比賽項目相當多元，其中一個項目是演算法競賽。




Facebook Hacker Cup
對象：社會大眾
時期：1月～3月


Taipei

HP CodeWars
對象：高中學生、大專院校學生，各分公司就地舉辦
時期：臺北4月




Internet Problem Solving Contest
對象：社會大眾
時期：5～6月


NCPC
2016、2015、2014

全國大專電腦軟體設計競賽
縮寫：NCPC
對象：台灣大專院校學生
時間：9～10月
主辦：教育部
承辦：由臺灣師範大學與中山大學輪流辦理


NCPU
2016、2015、2014

全國私立大專院校程式競賽
縮寫：NCPU
對象：台灣私立大專院校學生
時間：6月
主辦：各私立大學輪流辦理
備註：ICPC台灣站衍生賽事


NCTU
2016

全國科技大專院校程式競賽
縮寫：NCTU
對象：台灣科技大專院校學生
時間：6月
主辦：各科技大學輪流辦理
備註：ICPC台灣站衍生賽事


NPSC

網際網路程式設計全國大賽
縮寫：NPSC
對象：台灣高中學生、國中學生
時期：11～12月
主辦：科技部
承辦：台灣大學


ACM International Collegiate Programming Contest
資訊界規模最大、歷史最悠久的競賽，最近幾屆競賽皆有上千所學校、數萬名選手參加。
ACM-ICPC是一個氣氛相當活潑，非常具有特色的競賽。一場ACM-ICPC的賽事，由許多活動所組成，主軸當然是現場上機競賽，另外還有安排晚餐宴會、娛樂表演、城市遊覽等行程。整個賽程為期兩至三天，過程有吃有玩，遊樂的成分比競賽的成分還多，對於參賽選手來說是相當新鮮的體驗。活動細節請參考歷年的ACM-ICPC區域賽網站。
ACM-ICPC的競賽方式是三人一隊，並且要有一位同校教授作為領隊教練。教練的主要作用，是負責向大會接洽賽事行程，替選手打點賽事期間的生活細節，讓選手無後顧之憂，得以傾盡全力比賽，教練就如同經紀人的角色。另外，報名時可以額外登記一名後備隊員，發生緊急狀況時得替補上陣。
現場上機競賽的過程，是所有隊伍聚集於會場，一支隊伍分配一張桌子、三張椅子、一臺電腦、一份英文題本。開賽後所有隊伍同時開始作答，選手必須迅速調校好電腦環境，然後編寫程式解決問題，將程式碼上傳給裁判批改。
所有作答皆是即時批改，幾分鐘內回覆結果，結果只有對與錯兩大類，答錯還可以再答。成績的計算方式，是以答對題數作為主要的排名依據；但是作答的錯誤次數、上傳答案的時刻，統統列入扣分，最後作為次要的排名依據。因此選手除了要盡力答出問題，也要盡快答出問題，還要盡量避免答錯問題又一錯再錯。實力在伯仲之間的隊伍，勝負的差距往往取決於審題與答題的效率。動作慢人一步，或者大意發生失誤，就很可能名落千丈。
選手有五小時時間，要解出十道左右的演算法問題，期間可以喝水、外出上廁所、享用大會提供的奢華點心、在題本上塗鴉、把題本拆了摺紙鶴、睡覺、談情說愛、玩電腦遊戲；唯一的限制，就是不得與隊伍之外的人交流。
比賽規則看似輕佻，但是事實上，五小時時間解十道左右的題目，電腦卻只有一臺，所以比賽過程是非常緊迫的，就算是技藝高超的選手，也幾乎無暇休息，必須分工合作、爭取時間。通常是一人隨時坐在電腦前作答，充分運用電腦，發揮時效；另外兩人則在旁解讀其餘題目，在腦中羅織解法，伺機輪換上陣。五小時的比賽過程，選手剋服環境限制、調適心理壓力、發揮大腦潛能，也可以說是一場精神的對抗賽。
至於教練必須在會場外等待，不得與選手交談。不過教練們可以彼此交流，也可以觀戰和吃點心。現場上機競賽可以說是教練在整個賽程當中最輕鬆的時刻，也是辛苦之後驗收成果的時刻。
現場上機競賽還有許許多多的有趣的地方，此處只做初步介紹，詳細過程留給各位選手們自行體驗吧！

歷年比賽題目：ACM-ICPC Live Archive
ACM-ICPC官方消息：https://www.facebook.com/ICPCNews
ACM-ICPC亞洲區指導員：西傑的博客與阿雄
台灣ACM-ICPC非官方協會：ACM-ICPC Contest Council for Taiwan
中國ACM-ICPC非官方協會：ACM-ICPC中國區競賽指導委員會
中國非官方消息：ACM/ICPC信息站
日本非官方消息：ACM-ICPC Japanese Alumni Group
教練感想：2016 ACM-ICPC World Finals — MZ’s log

根據規定，ACM-ICPC區域賽必須要有全國性（或者兩省以上）的預賽。台灣歷年都是以NCPC作為預賽，然而實際上NCPC根本就不是預賽。會有這種現象，主要原因是台灣的參賽隊伍十分稀少，無從篩選隊伍。直至2015年，台灣才開始正式舉辦網路預賽，跟隨亞洲各國的比賽模式，時序如下：
一、區域預賽（網路賽）：由ACM-ICPC台灣區負責人負責組織比賽，各大專院校教授熱情協助。國內外選手透過網路比賽，最後根據當年承辦人員的戰鬥力，從中選出40至80隊，參加現場賽。由於國外隊伍出國參加現場賽，需要時間打點準備，所以網路賽往往很早舉辦，3至6個月前就會舉辦。
二、全國賽：與ACM-ICPC無關。台灣教育部舉辦的NCPC，全國學生一較高下。成績優秀的隊伍，教育部全額補助參加ACM-ICPC。
三、區域正式賽（現場賽）：請參考前面介紹的內容，國內外選手齊聚一堂進行較量。最後依照複雜的公式和規則，評量各個區域的戰鬥力之後，從各賽區選出至少1隊，參加世界總決賽。
四、世界總決賽：每年都從世界五大洲輪流選擇一間學校，作為主辦學校；從全世界篩選一百多隊參加總決賽。以往台灣大專院校實力較差，總是被國外學校痛宰，鮮少晉級總決賽。直到近年才有改善跡象，與國外學校互有進退（一群無名英雄前僕後繼苦心經營數年的成果）；同時也積極的參與其他國家的區域賽，爭取其他賽區的總決賽門票。目前臺灣僅台灣大學、交通大學有能力進入總決賽。
營隊

臺灣大學程式解題競賽培訓營
熱心學生自動自發努力辦理的營隊。

交大競技程式訓練冬令營、夏令營
熱心老師和學生自動自發努力辦理的營隊。

競程日記
關於競賽活動的大小事

講義

臺大資訊系資訊之芽算法班
熱心學生自動自發舉辦的高中營隊以及教材。

板橋高中資訊社演算法講義
熱心學生自動自發努力彙整的教材。

建國中學資訊科培訓講義
熱心學生自動自發努力彙整的教材。

交通大學PSPT課程講義
熱心老師自動自發努力彙整的教材。

成功大學ACM課程講義
熱心學生自動自發努力彙整的教材。

Stanford CS 97SI: Introduction to Competitive Programming Contests
Stanford大學開設的課程。

Competitive Programmer's Handbook
芬蘭IOI國家隊訓練教材

書籍



Discrete Mathematics and Its Applications
Kenneth Rosen
McGraw-Hill

離散數學，資工系用書，演算法的數學知識。
此書含有許多程式解題的基礎概念。
細讀此書，對程式解題有一定幫助。
此書有繁體中文譯本。




數學思考
臺北市建國高中第49屆314班合譯
九章出版社

很有趣的數學書籍，教導如何解決數學問題。
書中提到的思考方式，其實和程式解題是相通的。
這本書由《Thinking Mathematically》改著，
原書作者為John Mason。




How to Solve It
G. Pólya
Princeton University Press

經典的數學教育著作。
這本書有繁體中文譯本《怎樣解題》。




名題精選百則:技巧篇
冼鏡光
儒林出版社

收集程式設計的經典問題，
而且這些問題不會用到特殊的資料結構與演算法。
題目大多小巧精緻，非常具有啟發性。




Cracking the Coding Interview
Gayle Laakmann McDowell
CareerCup

收集面試問題，
其中包含許多演算法益智問題！

這本書有繁體中文譯本
《來自程式的試鍊：
專為程式開發人員所寫的技術面試完全攻略》。




Competitive Programming
Steven Halim, Felix Halim
Lulu

世界上第一本演算法競賽教科書！
詳細介紹競賽常用演算法，
精心挑選大量UVa Online Judge練習題，
配有追蹤解題進度的網站UVa Hunting，
規劃相當完善的教材。




프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략
구종만
인사이트

將演算法競賽的所有經典主題分門別類，
依照學習順序編排例題，仔細說明解題思路。

這本書有簡體中文譯本《算法問題實戰策略》。




プログラミングコンテストチャレンジブック
秋葉拓哉、岩田陽一、北川宜稔
マイナビ

選錄大量題目，以題目為主角，介紹各種演算法。

這本書有繁體中文譯本
《培養與鍛鍊程式設計的邏輯腦：
世界級程式設計大賽的知識、心得與解題分享》。





算法競賽入門經典
劉汝佳
清華大學出版社

算法競賽入門經典——訓練指南
劉汝佳、陳鋒
清華大學出版社

http://code.google.com/p/aoapc-book/
這是一套系列作，目前只出版兩本。
知識水平是所有書籍之中最高的。
想要躋身高手行列的人，絕對不要錯過此系列作。

第一本書有繁體中文譯本
《打下好基礎：程式設計與演算法競賽入門經典》。

第二本書有繁體中文譯本
《提升程式設計的解題思考力─
國際演算法程式設計競賽訓練指南》。



Computer Science

國內的資訊工程系學些什麼？
計算機的學問，分成計算機工程（Computer Engineering）與計算機科學（Computer Science）兩大系列。
計算機工程。製造電腦、操控電腦的學問（台灣把計算機翻譯成電腦）。製造電腦的部分，屬於電機系的專業；操控電腦的部分，屬於資工系的專業。在國外，有些學校乾脆把電機系和資工系合在一起，讓整件事情完美圓滿。下麵列出國內資工系應該學得到的計算機工程課程：

電子學：討論電流與電子元件的行為。
數位邏輯：操控電流與電子元件的行為，並且賦予意義。
微處理機：討論中央處理器。等登等登。
計算機組織與結構：討論電腦如何組成、如何運作，討論電腦的零件。
組合語言：操控電腦的指令。
程式設計：程式語言也是操控電腦的指令，設計成稍微貼近人類思惟。通常學C或C++。
編譯器：如何把程式碼變成操控電腦的指令。
系統程式：發揮電腦零件功能的程式，讓電腦執行特定作業。
作業系統：人與電腦的介面，讓使用者便於執行系統程式。
資料庫：電腦結合儲存設備，用來記錄。
計算機網路：電腦結合網路設備，用來通訊。
分散式系統：電腦結合網路設備、儲存設備，用來分工合作。
嵌入式系統：電腦結合其他機械，有著各種功能。
程式語言：如何設計程式語言，方便人類撰寫、方便電腦作業。
軟體工程：程式員很多、程式碼很長的情況，要如何應對。
人機互動：人類如何操控電腦。
普適計算：電腦與這個世界如何相互依存。

計算機科學。運用電腦實施計算、達成任務的學問。電腦是計算機，只會算數學，因此計算機科學皆是數學。計算機科學是資工系學生必備的基礎理論，是計算機的深奧之處。事實上，計算機工程的後半課程，就需要計算機科學的知識作為輔助。下麵列出國內資工系應該學得到的計算機科學課程：

資料結構：電腦實施計算時、儲存資料的方法。
演算法：電腦計算的方法。
平行處理：許多台電腦一起計算的方法。
自動機理論：討論電腦的計算模式，用數學表達。
計算理論：討論電腦的計算能力，用數學表達。
字串學：連成一串的文字（數列）的數學知識，著重比對。
數位訊號處理：連成一串的數列的數學知識，著重轉化。
密碼學：改變資料外觀的數學知識。
資訊理論：資料本身的數學知識。entropy！
編碼理論：壓縮資料的數學知識。用到資訊理論。
模式識別：比對資料的數學知識。
機器學習：分析資料的數學知識。用到模式識別。
人工智慧：搜尋資料的數學知識。用到機器學習。

緊接著列出計算機科學的實際應用課程。通常會在大四、研究所開課，通常只能學到皮毛；若要有所小成，就必須加入相對應的實驗室，認真做研究：

資料探勘：用數學解析、轉化數值資料。
自然語言處理：用數學解析、轉化文字資料。
語音處理：用數學解析、轉化聲音資料。
影像處理：用數學解析、轉化圖片資料、影片資料。
計算機圖學：用數學製造圖片、影片。
計算機視覺：用數學辨識圖片、影片。
幾何處理：用數學解析、轉化物體資料。
數值方法：用電腦計算數學方程式。
計算幾何：用電腦計算數學幾何。
計算物理：用電腦解決物理問題。
計算化學：用電腦解決化學問題。
生物資訊：用電腦解決生物學、醫學問題。
機器人學：上述所有東西加上機械設備，計算機工程與計算機科學集大成。

另外還有一些數學課程。計算機科學的各個應用領域都會用到數學，因此數學課程通常在大一、大二就會用力教完。雖說是數學，但是資工系與數學系的學習方向有著極大差異──資工系屬於實務導向，所以沒有太多晦澀的內容，也不需要推導定理，只要懂得原理、懂得運用就可以了，內容反而比數學系有趣。下麵列出國內資工系的基礎數學課程：

線性代數、機率論、離散數學。

另一方面還有理工科系的共同課程：微積分、工程數學。微積分就不討論了，總是有人認為有用、有人認為沒用，各人心裡有底。至於工程數學，計算機科學用不到，計算機工程用得比較多，尤其是在製造電腦、操控機械方面。
還有一些其他的數學，計算機科學有時候會用到，像是統計學、隨機過程、賽局理論、圖論、組合最佳化、數論等等。有些課程資工系沒有開課，電機系、數學系才有開課。
國外的計算機科學系學些什麼？
國外大學的課程更加豐富細膩！請大家看看UIUC和UCSD這兩間大學的課程總表：
https://cs.illinois.edu/courses/full-curriculum
http://ucsd.edu/catalog/courses/CSE.html
這兩間大學的計算機科學系樂於分享教材，絕大部分課程都公開了課程講義。大家可以透過網路自主學習：將課名代號、課名全名，放到Google搜尋，馬上就能找到課程講義。有時候則是要搜尋開課教授的姓名，從教授的個人網頁找到課程網站連結。
課程總表實在太籠統。有人依照工作性質，將課程歸類。
http://www.computerscienceonline.org/courses/
除了學校的正規課程，也有網路的影音課程。諸如Coursera、Udacity、edX，都有計算機科學的課程。課程種類正在持續增加當中，大家可以一睹國外教授的風採。
https://www.coursera.org/browse/computer-science
如果還不過癮，那麼還可以找QS世界大學排名，找前100大計算機科學系，再用Google搜尋這些學校的課程。
https://www.topuniversities.com/university-rankings/university-subject-rankings/2017/computer-science-information-systems
世界上還有許多比台清交更優秀的學校。打開心胸放眼全世界，不要自我設限，相信大家會有更多的收穫。
資訊工程系
資訊工程不是主流詞彙。從字面上來看，意思是處理資料的工程──架設一些電腦設備、運用一些計算機科學，來處理資料這樣。
資訊工程系是非常奇怪的系名。國外大學的計算機科學系所，系名都沒有包含資訊工程的字眼。在台灣，資訊工程系的英文系名是Department of Computer Science and Information Engineering，直接翻譯是「計算機科學與資訊工程系」，故意在計算機科學的後方添上了資訊工程，而且只取資訊工程的部分當成了中文系名。我不清楚這種亂象是如何產生的，或許是當時某些老人家想要譁眾取寵、追逐潮流，因此更改系名，欺騙學生就讀、保全自己地位。各位可以參考台灣交通大學資訊工程系的改名歷程：
https://www.cs.nctu.edu.tw/cswebsite/intro/history
國內計算機科學發展
台灣政府接受美援，引進國外設備，建造電子工廠、電腦工廠。台灣政府指派黨政軍人士前往海外觀摩，回國後設立研究院和大學，擔任校長和教授，督促學生解讀技術原理、創業開工廠。因此台灣並未發展計算機科學。
以學界而言，許多大學教授的水準，不如自學的中學生。比如引入計算機科學的先驅，只寫得出虛有其表的爛教材。資工系畢業生，一個班級只有兩三人學會寫程式。
以業界而言，只要去補習班接受短期訓練，就能寫程式，完全不必經過資工系的專業訓練。程式員如同臨時工，花錢請就有，人力流動相當頻繁。大部份公司都沒有完善的專案管理機制，修改規格、程式出錯、加班工作是家常便飯。
在台灣，光是學會寫程式，就是個大問題，更遑論計算機科學。如果你對計算機科學有興趣，就必須自立自強，學校教育幫不了你。
國外計算機科學發展
請參考維基百科以及谷歌搜尋結果。


C++時間複雜度的計算 | Yahoo奇摩知識+




















 









   ⌂首頁信箱新聞股市名人娛樂氣象運動App下載購物中心商城拍賣更多⋁知識+汽車機車電影字典遊戲旅遊理財房地產時尚美妝折扣城   Yahoo 奇摩知識+                        👤 登入    ✉ 信箱     ⚙ 服務說明    帳號資料 服務說明 意見回報        
















Yahoo奇摩知識+ 首頁











所有分類
 
健康
 
商業與財經
 
娛樂與音樂
 
家居與園藝
 
家庭與人際關係
 
寵物
 
懷孕與育兒
 
政治與政府
 
教育與參考
 
新聞與活動
 
旅遊
 
汽車與交通
 
消費電子產品
 
環境
 
社會科學
 
社會與文化
 
科學
 
美容與造型
 
藝術與人文
 
遊戲與休閒活動
 
運動
 
電腦與網際網路
 
食品與飲料
 
餐廳與小吃
 





世界Yahoo 








阿根廷





澳洲





巴西





加拿大





法國





德國





印度





印尼





義大利





馬來西亞





墨西哥







紐西蘭





菲律賓





魁北克





新加坡





香港





西班牙





泰國





英國與愛爾蘭





美國





越南





西班牙文







關於





關於 Yahoo奇摩知識+
社群指南
排行榜
點數與等級
部落格
如何安全地使用 Yahoo奇摩

 








 電腦與網際網路

 程式設計


 看另一則問題 




 


            C++時間複雜度的計算
        


請問這題的時間複雜度怎麼計算呢? 
for(i=1;i<=n;i++) 
{ 
  k=i+1; 
  do{ 
   x=x+1; 
    } while(k++<=n); 
}





 
1 個人正在追蹤 


 
 1 個解答 
1


檢舉不當使用









您確定要刪除此解答嗎？
是
否












 









抱歉，似乎發生一些問題。



Trending Now





 

解答














最佳解答: 
             如果出題者是故意出成這樣，那這題實在出的不錯。 
如果只是希望得到 O(n*n) 這種回答，那就有點該打屁股了。 

=== 分隔線 === 

這段程式碼的複雜度其實是無法計算的，因為完全不知道變數的型態。 

C++ 支援「運算子多載」，若不知道變數的型態，就無法得知你是否有多載這些（=、<=、 +、 postfix ++）運算子。 
不知道你是否有多載這些運算子，就無從得知實作方式。 
不知道你怎麼實作的，自然就沒辦法計算時間複雜度。 

=== 分隔線 === 

不過，若把這些運算子通通當成 O(1) 操作來計算，可以計算這段程式碼的最低複雜度。 

我喜歡由內而外，讓我先從最裡面那層開始： 

x = x + 1; 是兩個 O(1) 操作，所以還是 O(1)。 

do { ... } while(k++<=n); 由於 ++ 是等差級數遞增操作，所以這個迴圈會是 O(n)。 

k = k + 1; 跟上面一樣，O(1)。 

for (i = 1; i <= n; i++) { ... } 也是等差級數遞增，所以也是 O(n)。 

把上面說的整理一下標記起來： 
for(i=1;i<=n;i++) // O(n) 
{ 
  k=i+1; // O(1) 
  do 
  { 
    x=x+1; // O(1) 
  } 
  while(k++<=n); // O(n) 
} 

所以是 O(n) * (O(1) + (O(n) * (O(1))))，乘出來的結果是 O(n*n)。 

=== 分隔線 === 

所以說，這樣的程式碼，其複雜度至少有 O(n*n)，至多則無上限。 

 2012-03-09 04:53:53 補充： 
其實 C 也會遇到這種問題，尤其是你不知道使用韓式的複雜度的時候。 

例如，你有 10000 個字串要連接在一起，可是卻用 strcat() 一個一個跑。 
那麼本來 O(n) 的東西就會變成 O(n*n)： 
int i; 
char *str[10000] = { ... }, sum[10000000] = { '\0' }; 
for (i = 0;i < 10000;++i) 
strcat(sum, str); 




 參考資料： 
 


其威
 · 5 年前 





0
真讚



0
真遜





檢舉不當使用


意見





 




新增意見











送出












 · 剛才不久













                  發問者的評分
                







 

檢舉不當使用

 我認為此問題違反社群指南 
聊天或爭嚷、成人內容、垃圾信、侮辱其他成員、顯示更多
我認為此問題違反服務條款
對未成年兒童有害、帶有暴力或脅迫意味、騷擾或侵犯隱私權、假冒或不實陳述、欺詐或網路釣魚、 顯示更多

其他詳細資料

若您認為自己的智慧財產權受到侵害，並想提出申訴，請參閱我們的版權/智慧財產權政策

檢舉不當使用


取消




檢舉不當使用

 我認為此解答違反社群規範 
聊天或爭嚷、成人內容、垃圾信、侮辱其他成員、顯示更多
我認為此解答違反服務條款
對未成年兒童有害、帶有暴力或脅迫意味、騷擾或侵犯隱私權、假冒或不實陳述、欺詐或網路釣魚、 顯示更多

其他詳細資料

若您認為自己的智慧財產權受到侵害，並想提出申訴，請參閱我們的版權/智慧財產權政策

檢舉不當使用


取消




檢舉不當使用

 我認為此意見違反社群規範 
聊天或爭嚷、成人內容、垃圾信、侮辱其他成員、顯示更多
我認為此意見違反服務條款
對未成年兒童有害、帶有暴力或脅迫意味、騷擾或侵犯隱私權、假冒或不實陳述、欺詐或網路釣魚、 顯示更多

其他詳細資料

若您認為自己的智慧財產權受到侵害，並想提出申訴，請參閱我們的版權/智慧財產權政策

檢舉不當使用


取消



 

你可能對以下搜尋感興趣：


最火熱線上遊戲

高效率學習程式設計

日本旅遊讓你天天上網超方便

解決你的網頁設計問題












發問問題
通常可在幾分鐘內獲得解答！







展開»






詳細資料



詳細資料






現有問題




更多





請多詳述您的問題
上傳處理中




上傳失敗。 請上傳大於 100x100 像素的檔案
目前發生問題，請再試一次。
您只能上傳 PNG、JPG 或 JPEG 等類型的檔案。
您只能上傳 3GP、3GPP、MP4、MOV、AVI、MPG、MPEG 或 RM 等類型的檔案。
您只能上傳不超過 5 MB 的相片。
您只能上傳不超過 600 MB 的影片。
您只能上傳相片 (png, jpg, jpeg) 或影片 (3gp, 3gpp, mp4, mov, avi, mpg, mpeg, rm)。
您只能上傳相片或影片。
影片不應超過 <b>600mb/5 分鐘</b>
相片不應超過 <b>5mb</b>
影片不應超過 <b>600mb/5 分鐘</b>相片不應超過 <b>5mb</b>
  







解答問題


公司想整個網頁,有無咩網頁公司推薦?



 

C# cmd.CommandText的問題?



 

語言學校老師 新莊　?



 

請問各位大大
在Console裡
怎麼寫出1~1000的費式數列?
要以Do /Loop Until呈現
謝謝~?



 


發燒問題




如何用EXCEL亂數產生210~230之間的亂數,間距為5
210、215、220、225---?

                  6 個解答
              

 

想自學遊戲設計，有什麼書籍是可以買來自己看的?

                  7 個解答
              

 

Dreamweaver做完為什麼是file:///C:/Users/.......，怎麼把它改掉?

                  5 個解答
              

 
更多問題





本人想學程式語言 但這方面什麼都不懂 什麼迴圈阿 函數之類的 請問有什麼方法可以入門程式語言嗎?

             5 個解答
         

 

誰能認真教我做出一個簡單的網站
稍微設計一點程式就好了
要交大學專題用的
可以一步一步交的
會給回饋?

             5 個解答
         

 

想請問去職訓局學程式設計 對就業上的幫助?

             7 個解答
         

 

  








服務條款


隱私權


RSS















資料結構筆記(一)：演算法、時間複雜度、空間複雜度  |  Noob's Space  
Noob's Space



 
2016-11-06

程式筆記


0 人推薦

by Noob資料結構筆記(一)：演算法、時間複雜度、空間複雜度  資料結構，據說要學好程式只要學好資料結構和演算法就好了。但這明明是資料結構筆記啊，怎麼會提到時間複雜度呢？我也不知道，第一章就從時間複雜度和空間複雜度開始吧 XD演算法由三個部分組成：輸入、計算步驟、輸出，它是明確的、有限的、且有效率的。註：演算法並不等於寫程式。
一個演算法除了可以虛擬碼或程式碼來記載，並編譯成電腦程式；也可以流程圖來記載，並設計成電子電路。而要評論一個演算法的好壞，最基本的方式就是計算它所使用的時間和空間。但一個演算法在不同效能的電腦上跑，可能會有不同的情況。所以我們用複雜度的方式來描述一算法的趨勢。簡單來說就是用比較科學的方法來描述演算法的可能複雜情況。時間複雜度一個程式的時間複雜度是指完全地執行程式所需的計算機時間。如果一個演算法執行的步驟是固定的，無關輸入的值而改變，那我們會記成 O(1)，例如：function(int n){
    print(n);
}
不管 n 輸入多少，這個程式永遠只會執行一次。而下麵這個演算法：function(int n){
    for(i=0;i<n;i++){
        print(i);
    }
}
這個演算法則是依據輸入的 n 的數量會跑 n 次，所以是 O(n)。但還有某一些比較複雜的例子，例如：function(int n){
    for(i=0;i<n;i++){
        for(j=0;j<n-1;j++){
            print(i*j);
        }
    }
}
這個演算法雖然跑了 n*(n-1) = n2-n 次，但我們還是會記做 O(n2)，也就是說，只要找出最高次方，並且把係數拿掉即可。常見的時間複雜度還有：O(nlog(n))、O(n2)、O(2n)、O(n3)…等等，不用特別去記，只要大概的數一下迴圈數量，大致上判斷一下丟進去的變數會讓程式執行幾次即可。註：大寫的英文字母 O 函數，代表演算法執行步驟數目上限空間複雜度而一個程式的空間複雜度是指完全地執行程式所需的記憶體量。所需的記憶體量，大概可以看成所用的變數量。例如下麵這個函式，不管程式跑了幾遍，都不會影響使用的變數數量：function(int n){
    for(int i=0;i<n;i++){
        print(i);
    }
}
故該函式的空間複雜度記做 O(1)。但下麵這個函式，會隨著丟進去的數字而影響變數的量，例如：funtcion(int n){
    int c[n];
    for(int i=0;i<n;i++){
        c[i] = i;
    }
}
丟進去 n，就換產生 n 個變數，故該函式空間複雜度為 O(n)。參考資料演算法筆記 – Algorithm Analysis演算法筆記 – Algorithmdifferences between time complexity and space complexity? – Stackoverflow複習一下？我要學會 C 語言(六)：繞啊繞轉啊轉的迴圈結構我要學會 JAVA (二)：物件導向其實很簡單資料結構筆記 目錄資料結構筆記(一)：演算法、時間複雜度、空間複雜度資料結構筆記(二)：陣列、字串與指標資料結構筆記(三)：抽象資料結構(ADT)與 Struct

    

你可能會有興趣......?    

廣告
SEO搜尋|感情問題解決|感情輓回諮詢|尋人價錢|免費法律諮詢電話|線上法律諮詢要錢嗎|離婚證人見證|徵信社收費標準|想知道徵信社價錢|委託徵信社尋人|誰是徵信社阿宅|應徵立達徵信|爸爸想要輓回感情|優良徵信社條件|基本SEO禁忌|感情破壞多少錢|先生包二奶|徵信社服務有哪些|立達徵信社FB|工商徵信調查|另一半外遇|徵信社委託查案|任何疑難雜症|私家偵探探員|立案桃園徵信公司|合法徵信社條件|徵信社推薦工作|心理測驗結果|婚姻輓回方法|離婚相關法律問題





贊助 Noob’s Space以任意金額贊助 Noob's Space
 最新文章
解決 Ubuntu 16 以後，有線網路未受管理的問題
世紀帝國決定版：4K 重製版的經典遊戲？
Fira Code：支援合字、適合寫程式的等寬字型
irremote 中 sendRaw 送出負號會掛掉的問題
Movavi Video Converter：操作簡單的影片轉檔軟體
 熱門文章如何拍下螢幕畫面？截圖別再截全螢幕了！Minecraft PE 0.10.5：自由度超高的好玩遊戲，當個創世神手機版Root 到底是什麼？Root 後能夠做什麼？Noob Wireless Share v5.1：把Win7、Win8當成無線基地台來分享網路PocketMine-MP：在 Raspberry Pi 上建立 Minecraft PE 伺服器WOL 實錄，透過 Android 手機遠端喚醒電腦towelroot：又一個一鍵 root Android 手機的神器！一鍵快速 Root 你的 Android 手機，幾乎適用所有手機！？LG G2 升級 Android 5.0 + Root 教學WOL 不夠看，出門在外也要喚醒電腦才行 (Wake-On-Wan)！
交換連結Pupil's World 台灣小吃札記DC's Base低調一點電腦故我在Licson's Tech Space小逢雜貨舖三兄弟 - 3Bro BlogTori's Fly資訊門Just Blog 網站狂人資料酷是阿不解釋Android Games and Apps 資訊更多...

              

